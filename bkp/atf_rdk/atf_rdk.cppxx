// Copyright (C) 2026 AlgoRND
//
// License: GPL
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Target: atf_rdk (exe) -- atf_rdk target
// Exceptions: yes
// Source: cpp/atf_rdk/atf_rdk.cpp -- rdkafka testing tool
//

#include "include/algo.h"
#include "include/algo.h"
#include "include/atf_rdk.h"

void atf_rdk::Main() {
    // Register signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    dir_init();

    if(_db.cmdline.mode == "custom"){
        // this mode will start multiple processes as needed
        env_check();
        vrfy(_db.cmdline.wrk_id=="", tempstr()
             << Keyval("comment", "custom mode does not support wrk_id parameter. it is the top level process")
             );
        if(_db.cmdline.test == "c"){
            test_custom();
        } else if (_db.cmdline.test == "r"){
            test_rebalance();
        } else {
            prlog("atf_rdk.err" << Keyval("comment", "Unknown test specified") << Keyval("test", _db.cmdline.test));
        }
    }  else if (_db.cmdline.mode == "c"  ) {
        //same process consume via mainloop
        vrfy(_db.cmdline.n_c==0 && _db.cmdline.n_p==0, tempstr()
             << Keyval("comment", "single consumer mode does not allow n_c/n_p parameters")
             );
        consume_run();
    } else if( _db.cmdline.mode == "p" ){
        // same process produce via mainloop
        vrfy(_db.cmdline.n_c==0 && _db.cmdline.n_p==0, tempstr()
             << Keyval("comment", "single producer mode does not allow n_c/n_p parameters")
             );
        produce_run();
    } else {
        prlog("atf_rdk.err"
              << Keyval("comment", "valid modes are p/c/custom")
              );
    }

}

// Test mltiple backends in one session
void atf_rdk::test_custom() {
    prlog("atf_rdk.info" << Keyval("comment", "custom test -compare multipe backends in one run"));
    prlog("atf_rdk.info" << Keyval("comment", "override cmdline parameters for test!!!!!!!!!!\n"));

    // _db.cmdline.max_msgs = 1e6;
    // _db.cmdline.max_msgs = 1e3;
    // _db.cmdline.max_msgs = 2;
    // _db.cmdline.max_msgs = 1e3;

    // _db.cmdline.max_topics = 1e5;
    // _db.cmdline.max_topics = 1;
    // _db.cmdline.max_topics = 1e4*1;
    // _db.cmdline.max_topics = 10;

    // _db.cmdline.msg_rate = 1e4;
    // _db.cmdline.msg_rate = 1;

    _db.cmdline.n_p = 1;

    _db.cmdline.broker = "nj1-4.kafka-1.ext-0:1643";
    test_produce_mult_session();

    // _db.cmdline.broker = "nj1-4.x2-3.ext-0:1519";
    // test_produce_mult_session();

    _db.cmdline.broker = "localhost:54005";
    // _db.cmdline.broker = "localhost:9092";
    test_produce_mult_session();

    return ;
}

// Test producing messages in one session
void atf_rdk::test_produce_mult_session() {
    auto N=1;
    frep_(i,N){
        produce_run();
    }
    return ;
}

// Check environment
void atf_rdk::env_check(){
    // check if an instance of atf_rdk is aleady running.. to avoid multiple root atf_rdk instances
    tempstr cmd("pidof -o %PPID -x atf_rdk ");
    tempstr cmd_out(SysEval(cmd,FailokQ(true),1024,EchoQ(false)));
    vrfy(cmd_out=="",tempstr()
         <<Keyval("cmd",cmd)
         <<Keyval("cmd_out",cmd_out)
         <<Keyval("comment","atf_rdk instance is already running, only one instance of the root atf_rdk is allowed")
         <<Keyval("comment","pkill -f atf_rdk ")
         );
}

// wrap sleep with  log for UX experience
void atf_rdk::env_sleep(int sec, strptr note){
    prlog("atf_rdk.info"
          << Keyval("comment", note)
          << Keyval("sec", sec)
          );
    sleep(sec);
}

//run kafka describe group and count partition distrubtuion among workers
void atf_rdk::kafka_validate_group_partitions(){
    //initialize partition count
    ind_beg(_db_zd_wrk_curs, wrk, _db)  if (wrk.mode=="c") {
        wrk.partition_count=0;
    } ind_end;

    // run kafka describe group
    algo_lib::Replscope R;
    Set(R,"$broker",_db.cmdline.broker);
    command::bash_proc       bash_proc;
    bash_proc.cmd.c=Subst(R,"/opt/kafka/current/bin/kafka-consumer-groups.sh --bootstrap-server $broker --describe --group test_group_id");
    algo_lib::FFildes read;
    ind_beg(algo::FileLine_curs,line_in,bash_StartRead(bash_proc,read)) if (line_in!=""){
        verblog(line_in);
        // parse output line looking for partition assignment for each worker
        ind_beg(_db_zd_wrk_curs, wrk, _db) if (wrk.mode=="c"){
            tempstr client_id;
            client_id << "atf_rdk_" << wrk.wrk ;
            if(FindStr(line_in, client_id) != -1){
                wrk.partition_count++;
                break;
            }
        } ind_end;
    }ind_end;

    ind_beg(_db_zd_wrk_curs, wrk, _db)  if (wrk.mode=="c") {
        verblog("atf_rdk.info"
                << Keyval("comment", "Worker partition assignment")
                << Keyval("wrk_id", wrk.wrk)
                << Keyval("partition_count", wrk.partition_count)
                );
    } ind_end;
}

// Test rebalance of 2 consumers in the same group
void atf_rdk::test_rebalance() {
    prlog("atf_rdk.info" << Keyval("comment", "test rebalance "));

    bool test_ok = true;
    auto wrk_prod = wrk_start(0, "p");
    wrk_wait_to_end(wrk_prod);

    // start first consumer
    auto wrk_cons0 = wrk_start(0, "c");
    env_sleep(1, "Waiting after starting consumer0");

    // add another consumer to the group
    auto wrk_cons1 = wrk_start(1, "c");

    env_sleep(3, "Waiting before describe group. Expect partitions to be shared between consumers");
    kafka_validate_group_partitions();
    prlog("atf_rdk.info"
          << Keyval("comment", "partition distribution for  2 consumers after rebalance")
          << Keyval("consumer0", wrk_cons0->partition_count )
          << Keyval("consumer1", wrk_cons1->partition_count )
          );
    if( (wrk_cons0->partition_count ==0) || (wrk_cons1->partition_count ==0) ){
        test_ok = false;
    }

    // terminate   consumer
    wrk_end(*wrk_cons1);
    env_sleep(3, "Waiting before describe group. Expect partitions to be moved to consumer0");
    kafka_validate_group_partitions();
    prlog("atf_rdk.info"
          << Keyval("comment", "partition distribution for  2 consumers after rebalance")
          << Keyval("consumer0", wrk_cons0->partition_count )
          << Keyval("consumer1", wrk_cons1->partition_count )
          );
    if (wrk_cons1->partition_count !=0) {
        test_ok = false;
    }

    wrk_end_all();
    vrfy(test_ok, tempstr()
         << Keyval("comment", "Rebalance test failed")
         );
    prlog("atf_rdk.info" << Keyval("comment", "Rebalance test passed"));

    return ;
}

// Start asynchronous bash process
pid_t atf_rdk::prc_start_async(command::bash_proc &bash_proc, strptr wrk_id){

    tempstr logfile;
    logfile=DirFileJoin( _db.mcb.logs_dir,tempstr()<<wrk_id << ".log");

    // background and capture pid
    bash_proc.cmd.c << " >" << logfile << " 2>&1 ";
    bash_proc.cmd.c << " & echo $!";

    // parse pid from output
    pid_t pid =0 ;
    algo_lib::FFildes read;
    ind_beg(algo::FileLine_curs,line_in,bash_StartRead(bash_proc,read)) if (line_in!=""){
        pid = ParseI64(line_in,0);
        verblog("atf_rdk.info"
                << Keyval("comment", "Started worker process")
                << Keyval("wrk_id", wrk_id)
                << Keyval("cmdline", bash_proc.cmd.c)
                << Keyval("pid", pid)
                );
        vrfy(pid!=0, tempstr()
             << Keyval("comment", "Failed to parse pid from bash command output")
             << Keyval("cmdline", bash_proc.cmd.c)
             << Keyval("line_in", line_in)
             );
        break;
    }ind_end;
    return pid;
};


// Start worker process
atf_rdk::FWrk*  atf_rdk::wrk_start(int wrk_id_int, strptr mode) {
    vrfy(mode=="p" || mode=="c", tempstr()
         << Keyval("comment", "Invalid mode for worker")
         << Keyval("mode", mode)
         );
    tempstr wrk_id;
    wrk_id << mode << "_" << wrk_id_int;
    prlog("atf_rdk.info"
          << Keyval("comment", "Starting worker")
          << Keyval("wrk_id", wrk_id)
          << Keyval("mode", mode)
          );

    atf_rdk::FWrk* wrk=&wrk_Alloc();
    wrk->wrk = wrk_id;
    wrk->mode = mode;
    vrfy_(wrk_XrefMaybe(*wrk));

    // build command string and inherit cmdline parameters
    command::atf_rdk atf_rdk_cmd;
    atf_rdk_cmd.broker =_db.cmdline.broker;
    atf_rdk_cmd.topic =_db.cmdline.topic;
    atf_rdk_cmd.max_topics =_db.cmdline.max_topics;
    atf_rdk_cmd.max_msgs =_db.cmdline.max_msgs;
    atf_rdk_cmd.msg_rate =_db.cmdline.msg_rate;
    atf_rdk_cmd.msg_max_size =_db.cmdline.msg_max_size;
    atf_rdk_cmd.progress =_db.cmdline.progress;
    atf_rdk_cmd.rd_stats =_db.cmdline.rd_stats;
    // override some
    atf_rdk_cmd.mode = mode;
    atf_rdk_cmd.wrk_id = wrk_id;

    command::bash_proc       bash_proc;
    bash_proc.cmd.c << atf_rdk_ToCmdline(atf_rdk_cmd);

    wrk->pid = prc_start_async(bash_proc, wrk_id);
    return  wrk;
}

// wait for process to finish
void atf_rdk::wrk_wait_to_end( atf_rdk::FWrk* wrk){
    while (kill(wrk->pid, 0) == 0) {
        sleep(1);
        prlog("atf_rdk.info"
              << Keyval("comment", "Worker still running")
              << Keyval("wrk_id", wrk->wrk)
              << Keyval("pid", wrk->pid)
              );
    }
    prlog("atf_rdk.info"
          << Keyval("comment", "Worker   finished")
          << Keyval("wrk_id", wrk->wrk)
          << Keyval("pid", wrk->pid)
          );
    wrk->pid =0 ;
};

// kill worker process
void atf_rdk::wrk_end( atf_rdk::FWrk &wrk){
    verblog("atf_rdk.info"
            << Keyval("comment", "Killing worker process")
            << Keyval("wrk_id", wrk.wrk)
            << Keyval("pid", wrk.pid)
            );
    kill(wrk.pid, SIGTERM);
}

// kill all worker processes
void atf_rdk::wrk_end_all(){
    prlog("atf_rdk.info"
          << Keyval("comment", "terminating all worker processes")
          );
    ind_beg(_db_zd_wrk_curs, wrk, _db) {
        if(wrk.pid != 0){
            wrk_end(wrk);
        }
    } ind_end;
}

// montor  step for MainLoop
void atf_rdk::rdk_mon_Step() {
    if(_db.cmdline.progress){
        if(_db.cmdline.mode == "p"  ) {
            produce_progress();
        } else if (_db.cmdline.mode == "c"  ) {
            consume_progress();
        } else {
            // do nothing for custom mode. todo add multi worker progress
        }
    }
}

// configure  single entry in rdkafka config
int  atf_rdk::rdk_kafka_conf_set_wrap(rd_kafka_conf_t *conf, strptr p_key , strptr p_value) {
    char errstr[512];
    int rc =0;
    tempstr key(p_key);
    tempstr value(p_value);
    verblog2("atf_rdk.info"
             << Keyval("comment", "Setting rdkafka config")
             << Keyval("key", key)
             << Keyval("value", value)
             );
    if (rd_kafka_conf_set(conf, Zeroterm(key), Zeroterm(value)  , errstr, sizeof(errstr)) != RD_KAFKA_CONF_OK) {
        prlog("atf_rdk.err"
              << Keyval("comment", "Failed to set  ")
              << Keyval("key", key)
              << Keyval("value", value)
              << Keyval("error", errstr)
              );
        rd_kafka_conf_destroy(conf);
        rc=1;
    }
    return rc;
}


// Statistics callback
int atf_rdk::rdk_stats_callback(rd_kafka_t *rk, char *json, size_t json_len, void *opaque) {
    (void)rk;
    (void)opaque;

    // json is NOT null-terminated
    strptr json_p(json, json_len);
    // save stats
    _db.mcb.rd_stats_json = json_p;
    return 0; // must return 0
}

// init fixed subfolder for solo capture
void atf_rdk::dir_init(){
    _db.mcb.logs_dir = "temp/atf_rdk_logs";
    auto rc=SysCmd(tempstr()<<"mkdir -p  " << _db.mcb.logs_dir);
    vrfy(rc==0, "Failed to create logs directory");
    if(_db.cmdline.wrk_id  ==""){
        // Clean directory by removing all files
        // only for top level root
        SysCmd(tempstr()<<"rm -f " << _db.mcb.logs_dir << "/*");
        prlog("atf_rdk.info"
              << Keyval("comment", "Logs directory cleaned")
              << Keyval("logs_dir", _db.mcb.logs_dir)
              );
    }
}

// Initialize mcb counters
void atf_rdk::mcb_init() {
    /// todo as one struct init
    _db.mcb.msg_req_count = 0;
    _db.mcb.msg_ack_count = 0;
    _db.mcb.msg_lat_total = 0;
    _db.mcb.err_ondelivery_count = 0;
    _db.mcb.err_onproduce_count = 0;
    _db.mcb.stop = false;
    _db.mcb.imsg = 0;

    _db.mcb.msg_consume_count =0;
    _db.mcb.msg_consume_lat_total =0;
    _db.mcb.poll_consume_count =0;
}


// Signal handler for graceful shutdown
void atf_rdk::signal_handler(int sig) {
    (void)sig;
    if(_db.cmdline.mode == "custom" ){
        //todo into main loop
        wrk_end_all();
    }
    _db.mcb.stop = true;
}
