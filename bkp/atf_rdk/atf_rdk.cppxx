// Copyright (C) 2026 AlgoRND
//
// License: GPL
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Target: atf_rdk (exe) -- atf_rdk target
// Exceptions: yes
// Source: cpp/atf_rdk/atf_rdk.cpp -- rdkafka testing tool
//

#include "include/algo.h"
#include "include/algo.h"
#include "include/atf_rdk.h"

void atf_rdk::Main() {
    // Register signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    dir_init();

    if(_db.cmdline.test != ""){
        // this mode will start multiple processes as needed
        env_check();
        if(_db.cmdline.test == "c"){
            test_custom();
        } else if (_db.cmdline.test == "r"){
            test_rebalance();
        } else {
            prlog("atf_rdk.err" << Keyval("comment", "Unknown test specified") << Keyval("test", _db.cmdline.test));
        }
    }  else if (_db.cmdline.n_c == 1  && _db.cmdline.n_p == 0){
        //same process consume via mainloop
        consume_run();
    } else if( _db.cmdline.n_p == 1 && _db.cmdline.n_c == 0){
        // same process produce via mainloop
        produce_run();
    } else {
        prlog("atf_rdk.err"
              << Keyval("comment", "multiple consumer/producer runners not implemented yet")
              );
    }

}

// Test mltiple backends in one session
void atf_rdk::test_custom() {
    prlog("atf_rdk.info" << Keyval("comment", "custom test -compare multipe backends in one run"));
    prlog("atf_rdk.info" << Keyval("comment", "override cmdline parameters for test!!!!!!!!!!\n"));

    // _db.cmdline.max_msgs = 1e6;
    // _db.cmdline.max_msgs = 1e3;
    // _db.cmdline.max_msgs = 2;
    // _db.cmdline.max_msgs = 1e3;

    // _db.cmdline.max_topics = 1e5;
    // _db.cmdline.max_topics = 1;
    // _db.cmdline.max_topics = 1e4*1;
    // _db.cmdline.max_topics = 10;

    // _db.cmdline.msg_rate = 1e4;
    // _db.cmdline.msg_rate = 1;

    _db.cmdline.n_p = 1;

    _db.cmdline.broker = "nj1-4.kafka-1.ext-0:1643";
    test_produce_mult_session();

    // _db.cmdline.broker = "nj1-4.x2-3.ext-0:1519";
    // test_produce_mult_session();

    _db.cmdline.broker = "localhost:54005";
    // _db.cmdline.broker = "localhost:9092";
    test_produce_mult_session();

    return ;
}

// Test producing messages in one session
void atf_rdk::test_produce_mult_session() {
    auto N=1;
    frep_(i,N){
        produce_run();
    }
    return ;
}

// Check environment
void atf_rdk::env_check(){
    // check if an instance of atf_rdk is aleady running.. to avoid multiple root atf_rdk instances
    tempstr cmd("pidof -o %PPID -x atf_rdk ");
    tempstr cmd_out(SysEval(cmd,FailokQ(true),1024,EchoQ(false)));
    vrfy(cmd_out=="",tempstr()
         <<Keyval("cmd",cmd)
         <<Keyval("cmd_out",cmd_out)
         <<Keyval("comment","atf_rdk instance is already running, only one instance of the root atf_rdk is allowed")
         <<Keyval("comment","pkill -f atf_rdk ")
         );
}

// wrap sleep with  log for UX experience
void atf_rdk::env_sleep(int sec, strptr note){
    prlog("atf_rdk.info"
          << Keyval("comment", "Sleeping")
          << Keyval("sec", sec)
          << Keyval("note", note)
          );
    sleep(sec);
}

//run kafka describe group
void atf_rdk::kafka_describe_group(){
    algo_lib::Replscope R;
    Set(R,"$broker",_db.cmdline.broker);
    cstring cmd;
    cmd=Subst(R,"/opt/kafka/current/bin/kafka-consumer-groups.sh --bootstrap-server $broker --describe --group test_group_id");
    SysCmd(cmd);
}

// Test rebalance callback
void atf_rdk::test_rebalance() {
    prlog("atf_rdk.info" << Keyval("comment", "test rebalance callback"));

    prlog("atf_rdk.info" << Keyval("comment", "starting producer"));
    auto wrk_prod = wrk_start("p_0", 1, 0);
    prc_wait(wrk_prod->pid);
    wrk_prod->pid =0 ;

    prlog("atf_rdk.info" << Keyval("comment", "starting consumer0"));
    auto wrk_cons0 = wrk_start("c_0", 0, 1);
    env_sleep(1, "waiting after starting consumer0");

    prlog("atf_rdk.info" << Keyval("comment", "starting consumer1"));
    auto wrk_cons1 = wrk_start("c_1", 0, 1);
    env_sleep(5, "waiting before describe group");
    kafka_describe_group();

    // fake wait ??
    prc_wait(wrk_cons0->pid);
    wrk_cons0->pid =0 ;
    (void)wrk_cons1;

    return ;
}

// Start asynchronous bash process
pid_t atf_rdk::prc_start_async(command::bash_proc &bash_proc, strptr run_id){
    prlog("atf_rdk.info"
          << Keyval("comment", "Starting async worker process")
          << Keyval("run_id", run_id)
          << Keyval("cmdline", bash_proc.cmd.c)
          );

    tempstr logfile;
    logfile=DirFileJoin( _db.mcb.logs_dir,tempstr()<<run_id << ".log");

    // background and capture pid
    bash_proc.cmd.c << " >" << logfile << " 2>&1 ";
    bash_proc.cmd.c << " & echo $!";

    // parse pid from output
    pid_t pid =0 ;
    algo_lib::FFildes read;
    ind_beg(algo::FileLine_curs,line_in,bash_StartRead(bash_proc,read)) if (line_in!=""){
        pid = ParseI64(line_in,0);
        prlog("atf_rdk.info"
              << Keyval("comment", "Started worker process")
              << Keyval("pid", pid)
              );
        break;
    }ind_end;
    return pid;
};

// wait for process to finish
void atf_rdk::prc_wait(pid_t pid){
    while (kill(pid, 0) == 0) {
        sleep(1);
        prlog("atf_rdk.info"
              << Keyval("comment", "Worker still running")
              << Keyval("pid", pid)
              );
    }
    prlog("atf_rdk.info"
          << Keyval("comment", "Worker   finished")
          << Keyval("pid", pid)
          );
};

// Start worker process for produce
atf_rdk::FWrk*  atf_rdk::wrk_start(strptr run_id, u64 n_p, u64 n_c) {
    prlog("atf_rdk.info"
          << Keyval("comment", "Starting worker")
          << Keyval("run_id", run_id)
          );

    atf_rdk::FWrk* wrk=&wrk_Alloc();
    wrk->wrk = run_id;
    vrfy_(wrk_XrefMaybe(*wrk));

    // build command string and inherit cmdline parameters
    command::atf_rdk atf_rdk_cmd;
    atf_rdk_cmd.broker =_db.cmdline.broker;
    atf_rdk_cmd.topic =_db.cmdline.topic;
    atf_rdk_cmd.max_topics =_db.cmdline.max_topics;
    atf_rdk_cmd.max_msgs =_db.cmdline.max_msgs;
    atf_rdk_cmd.msg_rate =_db.cmdline.msg_rate;
    atf_rdk_cmd.msg_max_size =_db.cmdline.msg_max_size;
    atf_rdk_cmd.progress =_db.cmdline.progress;
    atf_rdk_cmd.rd_stats =_db.cmdline.rd_stats;
    // override some
    atf_rdk_cmd.n_p =n_p;
    atf_rdk_cmd.n_c =n_c;
    atf_rdk_cmd.run_id =run_id;

    command::bash_proc       bash_proc;
    bash_proc.cmd.c << atf_rdk_ToCmdline(atf_rdk_cmd);

    wrk->pid = prc_start_async(bash_proc, run_id);
    return  wrk;
}

// ensure all worker processes are terminated
void atf_rdk::wrk_end_all(){
    prlog("atf_rdk.info"
          << Keyval("comment", "terminating all worker processes")
          );
    ind_beg(_db_zd_wrk_curs, wrk, _db) {
        if(wrk.pid != 0){
            prlog("atf_rdk.info"
                  << Keyval("comment", "Killing worker process")
                  << Keyval("pid", wrk.pid)
                  << Keyval("wrk", wrk.wrk)
                  );
            kill(wrk.pid, SIGTERM);
        }
    } ind_end;
}


// montor  step for MainLoop
void atf_rdk::rdk_mon_Step() {
    if(_db.cmdline.progress){
        if(_db.cmdline.n_p ==1 ){
            produce_progress();
        } else if (_db.cmdline.n_c == 1  ) {
            consume_progress();
        }
    }
}

// configure  single entry in rdkafka config
int  atf_rdk::rdk_kafka_conf_set_wrap(rd_kafka_conf_t *conf, strptr p_key , strptr p_value) {
    char errstr[512];
    int rc =0;
    tempstr key(p_key);
    tempstr value(p_value);
    verblog2("atf_rdk.info"
             << Keyval("comment", "Setting rdkafka config")
             << Keyval("key", key)
             << Keyval("value", value)
             );
    if (rd_kafka_conf_set(conf, Zeroterm(key), Zeroterm(value)  , errstr, sizeof(errstr)) != RD_KAFKA_CONF_OK) {
        prlog("atf_rdk.err"
              << Keyval("comment", "Failed to set  ")
              << Keyval("key", key)
              << Keyval("value", value)
              << Keyval("error", errstr)
              );
        rd_kafka_conf_destroy(conf);
        rc=1;
    }
    return rc;
}


// Statistics callback
int atf_rdk::rdk_stats_callback(rd_kafka_t *rk, char *json, size_t json_len, void *opaque) {
    (void)rk;
    (void)opaque;

    // json is NOT null-terminated
    strptr json_p(json, json_len);
    // save stats
    _db.mcb.rd_stats_json = json_p;
    return 0; // must return 0
}

// init fixed subfolder for solo capture
void atf_rdk::dir_init(){
    _db.mcb.logs_dir = "temp/atf_rdk_logs";
    auto rc=SysCmd(tempstr()<<"mkdir -p  " << _db.mcb.logs_dir);
    vrfy(rc==0, "Failed to create logs directory");
    if(_db.cmdline.run_id  ==""){
        // Clean directory by removing all files
        // only for top level root
        SysCmd(tempstr()<<"rm -f " << _db.mcb.logs_dir << "/*");
        prlog("atf_rdk.info"
              << Keyval("comment", "Logs directory cleaned")
              << Keyval("logs_dir", _db.mcb.logs_dir)
              );
    }
}

// Initialize mcb counters
void atf_rdk::mcb_init() {
    /// todo as one struct init
    _db.mcb.msg_req_count = 0;
    _db.mcb.msg_ack_count = 0;
    _db.mcb.msg_lat_total = 0;
    _db.mcb.err_ondelivery_count = 0;
    _db.mcb.err_onproduce_count = 0;
    _db.mcb.stop = false;
    _db.mcb.imsg = 0;

    _db.mcb.msg_consume_count =0;
    _db.mcb.msg_consume_lat_total =0;
    _db.mcb.poll_consume_count =0;
}


// Signal handler for graceful shutdown
void atf_rdk::signal_handler(int sig) {
    (void)sig;
    if(_db.cmdline.run_id != ""){
        // main loop mode
        _db.mcb.stop = true;
    } else {
        _db.mcb.stop = true;
        wrk_end_all();
    }
}
