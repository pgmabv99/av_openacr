
// --- x2gw.FAcl
// create: x2gw.FDb.acl (Lary)
// global access: acl (Lary, by rowid)
struct FAcl { // x2gw.FAcl
    algo_lib::Regx   user;     // Acr Regx
    algo_lib::Regx   stream;   // Acr Regx
    algo_lib::Regx   key;      // Acr Regx
private:
    // func:x2gw.FAcl..Ctor
    inline               FAcl() __attribute__((nothrow));
    friend x2gw::FAcl&          acl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FAcl*          acl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 acl_RemoveAll() __attribute__((nothrow));
    friend void                 acl_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FApiendpoint
// create: x2gw.FDb.apiendpoint (Lary)
// global access: apiendpoint (Lary, by rowid)
// global access: ind_apiendpoint (Thash, hash field apiendpoint)
struct FApiendpoint { // x2gw.FApiendpoint
    algo::Smallstr50              apiendpoint;            //
    algo::Comment                 comment;                //
    x2gw::apiendpoint_step_hook   step;                   //   NULL  Pointer to a function
    x2gw::FApiendpoint*           ind_apiendpoint_next;   // hash next
    // reftype Hook of x2gw.FApiendpoint.step prohibits copy
    // func:x2gw.FApiendpoint..AssignOp
    inline x2gw::FApiendpoint& operator =(const x2gw::FApiendpoint &rhs) = delete;
    // reftype Hook of x2gw.FApiendpoint.step prohibits copy
    // func:x2gw.FApiendpoint..CopyCtor
    inline               FApiendpoint(const x2gw::FApiendpoint &rhs) = delete;
private:
    // func:x2gw.FApiendpoint..Ctor
    inline               FApiendpoint() __attribute__((nothrow));
    // func:x2gw.FApiendpoint..Dtor
    inline               ~FApiendpoint() __attribute__((nothrow));
    friend x2gw::FApiendpoint&  apiendpoint_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FApiendpoint*  apiendpoint_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 apiendpoint_RemoveAll() __attribute__((nothrow));
    friend void                 apiendpoint_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FCmdreq
// create: x2gw.FDb.cmdreq (Tpool)
// global access: ind_cmdreq (Thash, hash field request_id)
// access: x2gw.FConn.zd_cmdreq (Llist)
// access: x2gw.FProcOutput.p_cmdreq (Upptr)
struct FCmdreq { // x2gw.FCmdreq
    x2gw::FConn*          p_conn;                // reference to parent row
    x2::RequestId         request_id;            //
    x2::RequestId         origin_request_id;     //
    x2gw::FProcOutput**   c_proc_output_elems;   // array of pointers
    u32                   c_proc_output_n;       // array of pointers
    u32                   c_proc_output_max;     // capacity of allocated array
    algo_lib::FTimehook   timeout;               //
    bool                  maketable;             //   false
    bool                  countlines;            //   false
    x2gw::FCmdreq*        zd_cmdreq_next;        // zslist link; -1 means not-in-list
    x2gw::FCmdreq*        zd_cmdreq_prev;        // previous element
    x2gw::FCmdreq*        cmdreq_next;           // Pointer to next free element int tpool
    x2gw::FCmdreq*        ind_cmdreq_next;       // hash next
    // reftype Ptrary of x2gw.FCmdreq.c_proc_output prohibits copy
    // value field x2gw.FCmdreq.timeout is not copiable
    // func:x2gw.FCmdreq..AssignOp
    inline x2gw::FCmdreq& operator =(const x2gw::FCmdreq &rhs) = delete;
    // reftype Ptrary of x2gw.FCmdreq.c_proc_output prohibits copy
    // value field x2gw.FCmdreq.timeout is not copiable
    // func:x2gw.FCmdreq..CopyCtor
    inline               FCmdreq(const x2gw::FCmdreq &rhs) = delete;
private:
    // func:x2gw.FCmdreq..Ctor
    inline               FCmdreq() __attribute__((nothrow));
    // func:x2gw.FCmdreq..Dtor
    inline               ~FCmdreq() __attribute__((nothrow));
    friend x2gw::FCmdreq&       cmdreq_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FCmdreq*       cmdreq_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cmdreq_Delete(x2gw::FCmdreq &row) __attribute__((nothrow));
};


// --- x2gw.FConn
// create: x2gw.FDb.conn (Tpool)
// global access: cur_conn (Ptr)
// global access: zd_conn (Llist)
// global access: zd_conn_del (Llist)
// global access: cd_conn_read (Llist)
// global access: cd_conn_eof (Llist)
// global access: cd_conn_outflow (Llist)
// global access: zd_conn_metric_sub (Llist)
// access: x2gw.FCmdreq.p_conn (Upptr)
// access: x2gw.FConn.p_conn (Upptr)
// access: x2gw.FConn.c_conn (Ptr)
// access: x2gw.FFraming.scan (Hook)
// access: x2gw.FGwport.zd_gwport_conn (Llist)
// access: x2gw.FMoentryKey.p_conn (Upptr)
// access: x2gw.FSessionConn.p_conn (Upptr)
// access: x2gw.FUser.zd_user_conn (Llist)
struct FConn { // x2gw.FConn
    u8                    out_elems[1048576];             // pointer to elements of inline array
    i32                   out_start;                      // beginning of valid bytes (in bytes)
    i32                   out_end;                        // end of valid bytes (in bytes)
    bool                  out_eof;                        // no more data will be written to buffer
    algo::Errcode         out_err;                        // system error code
    bool                  out_msgvalid;                   // current message is valid
    i32                   out_msglen;                     // current message length
    SSL*                  out_ssl;                        // TLS connection
    algo_lib::FIohook     out_iohook;                     // edge-triggered hook for emptying buffer
    bool                  out_zerocopy;                   // support zero-copy optimization
    u64                   out_n_eagain;                   // eagain counter
    u64                   out_n_write_byte;               // written bytes
    u64                   out_n_write_msg;                // written messages
    bool                  out_epoll_enable;               // use epoll?
    enum { out_max = 1048576 };
    algo::cstring         err;                            //
    u8                    in_elems[1048576];              // pointer to elements of inline array
    i32                   in_start;                       // beginning of valid bytes (in bytes)
    i32                   in_end;                         // end of valid bytes (in bytes)
    bool                  in_eof;                         // no more data will be written to buffer
    algo::Errcode         in_err;                         // system error code
    bool                  in_msgvalid;                    // current message is valid
    i32                   in_msglen;                      // current message length
    SSL*                  in_ssl;                         // TLS connection
    algo_lib::FIohook     in_iohook;                      // edge-triggered hook for refilling buffer
    u64                   in_n_read_byte;                 // read bytes
    u64                   in_n_read_msg;                  // read bytes
    bool                  in_epoll_enable;                // use epoll?
    enum { in_max = 1048576 };
    x2gw::FGwport*        p_gwport;                       // reference to parent row
    u8                    mqtt_version;                   //   0
    SSL*                  ssl;                            // optional pointer
    bool                  drain_and_close;                //   false
    x2gw::FSessionConn*   c_session_conn;                 // optional pointer
    x2gw::FFraming*       p_framing;                      // reference to parent row
    x2gw::FConn*          p_conn;                         // reference to parent row
    x2gw::FConn*          c_conn;                         // Child connection. optional pointer
    u64                   id;                             //   0
    x2gw::FUser*          p_user;                         // reference to parent row
    x2gw::FCmdreq*        zd_cmdreq_head;                 // zero-terminated doubly linked list
    i32                   zd_cmdreq_n;                    // zero-terminated doubly linked list
    x2gw::FCmdreq*        zd_cmdreq_tail;                 // pointer to last element
    x2gw::FMoentry*       zd_conn_moentry_head;           // zero-terminated doubly linked list
    i32                   zd_conn_moentry_n;              // zero-terminated doubly linked list
    x2gw::FMoentry*       zd_conn_moentry_tail;           // pointer to last element
    x2gw::FMoentry*       zd_conn_moentry_pending_head;   // zero-terminated doubly linked list
    i32                   zd_conn_moentry_pending_n;      // zero-terminated doubly linked list
    x2gw::FMoentry*       zd_conn_moentry_pending_tail;   // pointer to last element
    x2gw::FConnstat*      p_connstat;                     // reference to parent row
    i32                   metric_credit;                  //   -1
    i32                   metric_report;                  //   -1
    x2gw::FConn*          conn_next;                      // Pointer to next free element int tpool
    x2gw::FConn*          zd_conn_next;                   // zslist link; -1 means not-in-list
    x2gw::FConn*          zd_conn_prev;                   // previous element
    x2gw::FConn*          zd_conn_del_next;               // zslist link; -1 means not-in-list
    x2gw::FConn*          zd_conn_del_prev;               // previous element
    x2gw::FConn*          cd_conn_read_next;              // zslist link; -1 means not-in-list
    x2gw::FConn*          cd_conn_read_prev;              // previous element
    x2gw::FConn*          cd_conn_eof_next;               // zslist link; -1 means not-in-list
    x2gw::FConn*          cd_conn_eof_prev;               // previous element
    x2gw::FConn*          cd_conn_outflow_next;           // zslist link; -1 means not-in-list
    x2gw::FConn*          cd_conn_outflow_prev;           // previous element
    x2gw::FConn*          zd_conn_metric_sub_next;        // zslist link; -1 means not-in-list
    x2gw::FConn*          zd_conn_metric_sub_prev;        // previous element
    x2gw::FConn*          zd_gwport_conn_next;            // zslist link; -1 means not-in-list
    x2gw::FConn*          zd_gwport_conn_prev;            // previous element
    x2gw::FConn*          zd_user_conn_next;              // zslist link; -1 means not-in-list
    x2gw::FConn*          zd_user_conn_prev;              // previous element
    // field x2gw.FConn.out prevents copy
    // field x2gw.FConn.in prevents copy
    // user-defined fcleanup on x2gw.FConn.p_gwport prevents copy
    // user-defined fcleanup on x2gw.FConn.ssl prevents copy
    // x-reference on x2gw.FConn.c_session_conn prevents copy
    // reftype Llist of x2gw.FConn.zd_cmdreq prohibits copy
    // reftype Llist of x2gw.FConn.zd_conn_moentry prohibits copy
    // reftype Llist of x2gw.FConn.zd_conn_moentry_pending prohibits copy
    // func:x2gw.FConn..AssignOp
    x2gw::FConn&         operator =(const x2gw::FConn &rhs) = delete;
    // field x2gw.FConn.out prevents copy
    // field x2gw.FConn.in prevents copy
    // user-defined fcleanup on x2gw.FConn.p_gwport prevents copy
    // user-defined fcleanup on x2gw.FConn.ssl prevents copy
    // x-reference on x2gw.FConn.c_session_conn prevents copy
    // reftype Llist of x2gw.FConn.zd_cmdreq prohibits copy
    // reftype Llist of x2gw.FConn.zd_conn_moentry prohibits copy
    // reftype Llist of x2gw.FConn.zd_conn_moentry_pending prohibits copy
    // func:x2gw.FConn..CopyCtor
    FConn(const x2gw::FConn &rhs) = delete;
private:
    // func:x2gw.FConn..Ctor
    inline               FConn() __attribute__((nothrow));
    // func:x2gw.FConn..Dtor
    inline               ~FConn() __attribute__((nothrow));
    friend x2gw::FConn&         conn_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FConn*         conn_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 conn_Delete(x2gw::FConn &row) __attribute__((nothrow));
};


// --- x2gw.FConnstat
// create: x2gw.FDb.connstat (Lary)
// global access: connstat (Lary, by rowid)
// access: x2gw.FConn.p_connstat (Upptr)
struct FConnstat { // x2gw.FConnstat
    lib_x2::FMetric*   read_bytes;    // optional pointer
    lib_x2::FMetric*   read_msgs;     // optional pointer
    lib_x2::FMetric*   write_bytes;   // optional pointer
    lib_x2::FMetric*   write_msgs;    // optional pointer
    lib_x2::FMetric*   connected;     // optional pointer
private:
    // func:x2gw.FConnstat..Ctor
    inline               FConnstat() __attribute__((nothrow));
    friend x2gw::FConnstat&     connstat_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FConnstat*     connstat_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 connstat_RemoveAll() __attribute__((nothrow));
    friend void                 connstat_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FDb
// create: x2gw.FDb._db (Global)
struct FDb { // x2gw.FDb
    command::x2gw                 cmdline;                                       //
    u64                           stream_blocksize;                              // # bytes per block
    x2gw::FStream*                stream_free;                                   //
    u64                           fetch_blocksize;                               // # bytes per block
    x2gw::FFetch*                 fetch_free;                                    //
    x2gw::FStream**               ind_stream_buckets_elems;                      // pointer to bucket array
    i32                           ind_stream_buckets_n;                          // number of elements in bucket array
    i32                           ind_stream_n;                                  // number of elements in the hash table
    x2gw::FStream**               ind_stream_name_buckets_elems;                 // pointer to bucket array
    i32                           ind_stream_name_buckets_n;                     // number of elements in bucket array
    i32                           ind_stream_name_n;                             // number of elements in the hash table
    x2gw::FFetch*                 zd_fetch_head;                                 // zero-terminated doubly linked list
    i32                           zd_fetch_n;                                    // zero-terminated doubly linked list
    x2gw::FFetch*                 zd_fetch_tail;                                 // pointer to last element
    u64                           session_blocksize;                             // # bytes per block
    x2gw::FSession*               session_free;                                  //
    x2gw::FSession*               zd_session_head;                               // zero-terminated doubly linked list
    i32                           zd_session_n;                                  // zero-terminated doubly linked list
    x2gw::FSession*               zd_session_tail;                               // pointer to last element
    x2gw::FSession*               cur_session;                                   // optional pointer
    u64                           producer_blocksize;                            // # bytes per block
    x2gw::FProducer*              producer_free;                                 //
    x2gw::FProducer*              zd_producer_head;                              // zero-terminated doubly linked list
    i32                           zd_producer_n;                                 // zero-terminated doubly linked list
    x2gw::FProducer*              zd_producer_tail;                              // pointer to last element
    x2gw::FProducer**             ind_producer_buckets_elems;                    // pointer to bucket array
    i32                           ind_producer_buckets_n;                        // number of elements in bucket array
    i32                           ind_producer_n;                                // number of elements in the hash table
    x2gw::FStream*                zd_stream_head;                                // zero-terminated doubly linked list
    i32                           zd_stream_n;                                   // zero-terminated doubly linked list
    x2gw::FStream*                zd_stream_tail;                                // pointer to last element
    u64                           next_session_id;                               //   1
    u64                           packet_blocksize;                              // # bytes per block
    x2gw::FPacket*                packet_free;                                   //
    x2gw::FSession**              ind_session_clientid_buckets_elems;            // pointer to bucket array
    i32                           ind_session_clientid_buckets_n;                // number of elements in bucket array
    i32                           ind_session_clientid_n;                        // number of elements in the hash table
    x2gw::FConn*                  cur_conn;                                      // optional pointer
    u128                          netproto_data[sizeu128(x2gw::FNetproto,14)];   // place for data
    i32                           netproto_n;                                    // number of elems current in existence
    enum { netproto_max = 14 };
    x2gw::FNetproto**             ind_netproto_buckets_elems;                    // pointer to bucket array
    i32                           ind_netproto_buckets_n;                        // number of elements in bucket array
    i32                           ind_netproto_n;                                // number of elements in the hash table
    u128                          framing_data[sizeu128(x2gw::FFraming,7)];      // place for data
    i32                           framing_n;                                     // number of elems current in existence
    enum { framing_max = 7 };
    x2gw::FFraming**              ind_framing_buckets_elems;                     // pointer to bucket array
    i32                           ind_framing_buckets_n;                         // number of elements in bucket array
    i32                           ind_framing_n;                                 // number of elements in the hash table
    x2gw::FGwproto*               gwproto_lary[32];                              // level array
    i32                           gwproto_n;                                     // number of elements in array
    u64                           conn_blocksize;                                // # bytes per block
    x2gw::FConn*                  conn_free;                                     //
    x2gw::FConn*                  zd_conn_head;                                  // zero-terminated doubly linked list
    i32                           zd_conn_n;                                     // zero-terminated doubly linked list
    x2gw::FConn*                  zd_conn_tail;                                  // pointer to last element
    x2gw::FConn*                  zd_conn_del_head;                              // zero-terminated doubly linked list
    i32                           zd_conn_del_n;                                 // zero-terminated doubly linked list
    x2gw::FConn*                  zd_conn_del_tail;                              // pointer to last element
    x2gw::FGwport*                cd_accept_head;                                // zero-terminated doubly linked list
    i32                           cd_accept_n;                                   // zero-terminated doubly linked list
    x2gw::FConn*                  cd_conn_read_head;                             // zero-terminated doubly linked list
    i32                           cd_conn_read_n;                                // zero-terminated doubly linked list
    x2gw::FConn*                  cd_conn_eof_head;                              // zero-terminated doubly linked list
    i32                           cd_conn_eof_n;                                 // zero-terminated doubly linked list
    x2gw::FConn*                  cd_conn_outflow_head;                          // zero-terminated doubly linked list
    i32                           cd_conn_outflow_n;                             // zero-terminated doubly linked list
    u64                           session_conn_blocksize;                        // # bytes per block
    x2gw::FSessionConn*           session_conn_free;                             //
    u64                           next_conn_id;                                  //   1
    u64                           open_stream_blocksize;                         // # bytes per block
    x2gw::FOpenStream*            open_stream_free;                              //
    x2gw::FFetch**                ind_fetch_buckets_elems;                       // pointer to bucket array
    i32                           ind_fetch_buckets_n;                           // number of elements in bucket array
    i32                           ind_fetch_n;                                   // number of elements in the hash table
    u64                           user_blocksize;                                // # bytes per block
    x2gw::FUser*                  user_free;                                     //
    x2gw::FUser**                 ind_user_buckets_elems;                        // pointer to bucket array
    i32                           ind_user_buckets_n;                            // number of elements in bucket array
    i32                           ind_user_n;                                    // number of elements in the hash table
    i32                           ssl_conn_idx;                                  //   -1
    x2gw::FUser**                 c_user_sorted_elems;                           // array of pointers
    u32                           c_user_sorted_n;                               // array of pointers
    u32                           c_user_sorted_max;                             // capacity of allocated array
    x2gw::FUser*                  c_user_anon;                                   // optional pointer
    x2gw::FUser*                  c_user_root;                                   // optional pointer
    x2gw::FApiendpoint*           apiendpoint_lary[32];                          // level array
    i32                           apiendpoint_n;                                 // number of elements in array
    x2gw::FApiendpoint**          ind_apiendpoint_buckets_elems;                 // pointer to bucket array
    i32                           ind_apiendpoint_buckets_n;                     // number of elements in bucket array
    i32                           ind_apiendpoint_n;                             // number of elements in the hash table
    u64                           cmdreq_blocksize;                              // # bytes per block
    x2gw::FCmdreq*                cmdreq_free;                                   //
    x2gw::FCmdreq**               ind_cmdreq_buckets_elems;                      // pointer to bucket array
    i32                           ind_cmdreq_buckets_n;                          // number of elements in bucket array
    i32                           ind_cmdreq_n;                                  // number of elements in the hash table
    u64                           proc_output_blocksize;                         // # bytes per block
    x2gw::FProcOutput*            proc_output_free;                              //
    x2gw::FProcOutput**           ind_proc_output_buckets_elems;                 // pointer to bucket array
    i32                           ind_proc_output_buckets_n;                     // number of elements in bucket array
    i32                           ind_proc_output_n;                             // number of elements in the hash table
    x2gw::FProcOutput*            self_output;                                   // optional pointer
    x2gw::FConn*                  zd_conn_metric_sub_head;                       // zero-terminated doubly linked list
    i32                           zd_conn_metric_sub_n;                          // zero-terminated doubly linked list
    x2gw::FConn*                  zd_conn_metric_sub_tail;                       // pointer to last element
    x2gw::FMetric*                metric_lary[32];                               // level array
    i32                           metric_n;                                      // number of elements in array
    x2gw::FMetric**               ind_metric_buckets_elems;                      // pointer to bucket array
    i32                           ind_metric_buckets_n;                          // number of elements in bucket array
    i32                           ind_metric_n;                                  // number of elements in the hash table
    x2gw::FMetric**               ind_metric_id_buckets_elems;                   // pointer to bucket array
    i32                           ind_metric_id_buckets_n;                       // number of elements in bucket array
    i32                           ind_metric_id_n;                               // number of elements in the hash table
    x2gw::_db_h_pub_metric_hook   h_pub_metric;                                  //   NULL  Pointer to a function
    u64                           h_pub_metric_ctx;                              //   0  Callback context
    x2gw::_db_h_def_metric_hook   h_def_metric;                                  //   NULL  Pointer to a function
    u64                           h_def_metric_ctx;                              //   0  Callback context
    x2gw::FConnstat*              connstat_lary[32];                             // level array
    i32                           connstat_n;                                    // number of elements in array
    u64                           moentry_blocksize;                             // # bytes per block
    x2gw::FMoentry*               moentry_free;                                  //
    x2gw::FMoentry**              ind_moentry_buckets_elems;                     // pointer to bucket array
    i32                           ind_moentry_buckets_n;                         // number of elements in bucket array
    i32                           ind_moentry_n;                                 // number of elements in the hash table
    x2gw::FDisk*                  disk_lary[32];                                 // level array
    i32                           disk_n;                                        // number of elements in array
    x2gw::FDisk**                 ind_disk_buckets_elems;                        // pointer to bucket array
    i32                           ind_disk_buckets_n;                            // number of elements in bucket array
    i32                           ind_disk_n;                                    // number of elements in the hash table
    x2gw::FIntf*                  intf_lary[32];                                 // level array
    i32                           intf_n;                                        // number of elements in array
    x2gw::FIntf**                 ind_intf_buckets_elems;                        // pointer to bucket array
    i32                           ind_intf_buckets_n;                            // number of elements in bucket array
    i32                           ind_intf_n;                                    // number of elements in the hash table
    x2gw::FAcl*                   acl_lary[32];                                  // level array
    i32                           acl_n;                                         // number of elements in array
    u64                           kafka_acl_resource_blocksize;                  // # bytes per block
    x2gw::FKafkaAclResource*      kafka_acl_resource_free;                       //
    x2gw::FKafkaAclResource*      zd_kafka_acl_resource_head;                    // zero-terminated doubly linked list
    i32                           zd_kafka_acl_resource_n;                       // zero-terminated doubly linked list
    x2gw::FKafkaAclResource*      zd_kafka_acl_resource_tail;                    // pointer to last element
    x2gw::FKafkaAclResource**     ind_kafka_acl_resource_buckets_elems;          // pointer to bucket array
    i32                           ind_kafka_acl_resource_buckets_n;              // number of elements in bucket array
    i32                           ind_kafka_acl_resource_n;                      // number of elements in the hash table
    u64                           kafka_acl_blocksize;                           // # bytes per block
    x2gw::FKafkaAcl*              kafka_acl_free;                                //
    u64                           topic_blocksize;                               // # bytes per block
    x2gw::FTopic*                 topic_free;                                    //
    x2gw::FTopic**                ind_topic_buckets_elems;                       // pointer to bucket array
    i32                           ind_topic_buckets_n;                           // number of elements in bucket array
    i32                           ind_topic_n;                                   // number of elements in the hash table
    kafka2::RequestHeader*        cur_req;                                       // optional pointer
    u64                           kafka_fetch_blocksize;                         // # bytes per block
    x2gw::FKafkaFetch*            kafka_fetch_free;                              //
    x2gw::FTopic**                ind_topic_id_buckets_elems;                    // pointer to bucket array
    i32                           ind_topic_id_buckets_n;                        // number of elements in bucket array
    i32                           ind_topic_id_n;                                // number of elements in the hash table
    x2gw::FTopic*                 zd_topic_head;                                 // zero-terminated doubly linked list
    i32                           zd_topic_n;                                    // zero-terminated doubly linked list
    x2gw::FTopic*                 zd_topic_tail;                                 // pointer to last element
    u64                           group_blocksize;                               // # bytes per block
    x2gw::FGroup*                 group_free;                                    //
    x2gw::FGroup**                ind_group_buckets_elems;                       // pointer to bucket array
    i32                           ind_group_buckets_n;                           // number of elements in bucket array
    i32                           ind_group_n;                                   // number of elements in the hash table
    u64                           member_blocksize;                              // # bytes per block
    x2gw::FMember*                member_free;                                   //
    x2gw::FGroup*                 zd_group_head;                                 // zero-terminated doubly linked list
    i32                           zd_group_n;                                    // zero-terminated doubly linked list
    x2gw::FGroup*                 zd_group_tail;                                 // pointer to last element
    x2gw::FGwport*                gwport_lary[32];                               // level array
    i32                           gwport_n;                                      // number of elements in array
    x2gw::FGwproto**              ind_gwproto_buckets_elems;                     // pointer to bucket array
    i32                           ind_gwproto_buckets_n;                         // number of elements in bucket array
    i32                           ind_gwproto_n;                                 // number of elements in the hash table
    x2gw::FProc*                  proc_lary[32];                                 // level array
    i32                           proc_n;                                        // number of elements in array
    x2gw::FProc**                 ind_proc_buckets_elems;                        // pointer to bucket array
    i32                           ind_proc_buckets_n;                            // number of elements in bucket array
    i32                           ind_proc_n;                                    // number of elements in the hash table
    x2gw::trace                   trace;                                         //
};


// --- x2gw.FDisk
// create: x2gw.FDb.disk (Lary)
// global access: disk (Lary, by rowid)
// global access: ind_disk (Thash, hash field disk)
struct FDisk { // x2gw.FDisk
    x2gw::FDisk*       ind_disk_next;   // hash next
    algo::Smallstr50   disk;            //
    algo::Smallstr16   device;          //
    algo::Smallstr50   model;           //
    x2::Operstate      state;           //
    // func:x2gw.FDisk..AssignOp
    inline x2gw::FDisk&  operator =(const x2gw::FDisk &rhs) = delete;
    // func:x2gw.FDisk..CopyCtor
    inline               FDisk(const x2gw::FDisk &rhs) = delete;
private:
    // func:x2gw.FDisk..Ctor
    inline               FDisk() __attribute__((nothrow));
    // func:x2gw.FDisk..Dtor
    inline               ~FDisk() __attribute__((nothrow));
    friend x2gw::FDisk&         disk_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FDisk*         disk_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 disk_RemoveAll() __attribute__((nothrow));
    friend void                 disk_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FFetch
// create: x2gw.FDb.fetch (Tpool)
// global access: zd_fetch (Llist)
// global access: ind_fetch (Thash, hash field request_id)
// access: x2gw.FFetch.rd_fetch_prev (Ptr)
// access: x2gw.FFetch.rd_fetch_next (Ptr)
// access: x2gw.FKafkaFetch.zd_kafka_fetch_fetch (Llist)
// access: x2gw.FPacket.p_fetch (Upptr)
// access: x2gw.FSession.zd_session_fetch (Llist)
// access: x2gw.FSession.zd_session_fetch_queue (Llist)
// access: x2gw.FSession.cd_session_fetch_queue (Llist)
// access: x2gw.FStream.zd_stream_fetch (Llist)
struct FFetch { // x2gw.FFetch: Tracks a single fetch request
    x2gw::FFetch*                   fetch_next;                    // Pointer to next free element int tpool
    x2gw::FFetch*                   zd_fetch_next;                 // zslist link; -1 means not-in-list
    x2gw::FFetch*                   zd_fetch_prev;                 // previous element
    x2gw::FFetch*                   ind_fetch_next;                // hash next
    x2::RequestId                   request_id;                    //
    x2::RequestId                   origin_request_id;             //
    algo::SeqType                   beg_seq;                       //
    algo::SeqType                   end_seq;                       //
    i32                             rsp_topic_index;               //   -1
    i32                             rsp_partition_index;           //   -1  Kafka API version
    algo::cstring                   sid;                           //
    algo::cstring                   subject;                       //
    algo::cstring                   channel;                       //
    mqtt::Qos                       qos;                           //
    x2gw::RespFetchOp               op;                            //
    i32                             n_suspend;                     //   0  Counter of # of suspensions
    i32                             n_send;                        //   0  Counter of # of Sends
    i32                             n_resume;                      //   0  Counter of # of resumes
    x2gw::FSession*                 p_session;                     // reference to parent row
    x2gw::FStream*                  p_stream;                      // reference to parent row
    x2gw::FKafkaFetch*              p_kafka_fetch;                 // reference to parent row
    algo_lib::FTimehook             timeout;                       //
    x2gw::FPacket*                  zd_packet_queue_head;          // zero-terminated doubly linked list
    i32                             zd_packet_queue_n;             // zero-terminated doubly linked list
    x2gw::FPacket*                  zd_packet_queue_tail;          // pointer to last element
    mqtt::SubscriptionIdentifiers   subs_ids;                      //
    bool                            suspend;                       //   false
    x2gw::fetch_h_msg_hook          h_msg;                         //   NULL  Pointer to a function
    u64                             h_msg_ctx;                     //   0  Callback context
    algo::ByteAry                   key;                           //
    lib_ams::FShm*                  p_shm;                         // optional pointer
    algo_lib::FTimehook             linger;                        //
    x2gw::FFetch*                   rd_fetch_prev;                 // optional pointer
    x2gw::FFetch*                   rd_fetch_next;                 // optional pointer
    x2gw::FFetch*                   zd_kafka_fetch_fetch_next;     // zslist link; -1 means not-in-list
    x2gw::FFetch*                   zd_kafka_fetch_fetch_prev;     // previous element
    x2gw::FFetch*                   zd_session_fetch_next;         // zslist link; -1 means not-in-list
    x2gw::FFetch*                   zd_session_fetch_prev;         // previous element
    x2gw::FFetch*                   zd_session_fetch_queue_next;   // zslist link; -1 means not-in-list
    x2gw::FFetch*                   zd_session_fetch_queue_prev;   // previous element
    x2gw::FFetch*                   cd_session_fetch_queue_next;   // zslist link; -1 means not-in-list
    x2gw::FFetch*                   cd_session_fetch_queue_prev;   // previous element
    x2gw::FFetch*                   zd_stream_fetch_next;          // zslist link; -1 means not-in-list
    x2gw::FFetch*                   zd_stream_fetch_prev;          // previous element
    // value field x2gw.FFetch.timeout is not copiable
    // reftype Llist of x2gw.FFetch.zd_packet_queue prohibits copy
    // reftype Hook of x2gw.FFetch.h_msg prohibits copy
    // value field x2gw.FFetch.linger is not copiable
    // func:x2gw.FFetch..AssignOp
    x2gw::FFetch&        operator =(const x2gw::FFetch &rhs) = delete;
    // value field x2gw.FFetch.timeout is not copiable
    // reftype Llist of x2gw.FFetch.zd_packet_queue prohibits copy
    // reftype Hook of x2gw.FFetch.h_msg prohibits copy
    // value field x2gw.FFetch.linger is not copiable
    // func:x2gw.FFetch..CopyCtor
    FFetch(const x2gw::FFetch &rhs) = delete;
private:
    // func:x2gw.FFetch..Ctor
    inline               FFetch() __attribute__((nothrow));
    // func:x2gw.FFetch..Dtor
    inline               ~FFetch() __attribute__((nothrow));
    friend x2gw::FFetch&        fetch_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FFetch*        fetch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fetch_Delete(x2gw::FFetch &row) __attribute__((nothrow));
};


// --- x2gw.FFraming
// create: x2gw.FDb.framing (Inlary)
// global access: ind_framing (Thash, hash field framing)
// access: x2gw.FConn.p_framing (Upptr)
// access: x2gw.FGwproto.p_framing (Upptr)
struct FFraming { // x2gw.FFraming
    algo::Smallstr50          framing;            //
    bool                      create_session;     //   false
    algo::Comment             comment;            //
    x2gw::framing_read_hook   read;               //   NULL  Pointer to a function
    x2gw::framing_scan_hook   scan;               //   NULL  Pointer to a function
    x2gw::FFraming*           ind_framing_next;   // hash next
    // reftype Hook of x2gw.FFraming.read prohibits copy
    // reftype Hook of x2gw.FFraming.scan prohibits copy
    // func:x2gw.FFraming..AssignOp
    inline x2gw::FFraming& operator =(const x2gw::FFraming &rhs) = delete;
    // func:x2gw.FFraming..Ctor
    inline               FFraming() __attribute__((nothrow));
    // func:x2gw.FFraming..Dtor
    inline               ~FFraming() __attribute__((nothrow));
    // reftype Hook of x2gw.FFraming.read prohibits copy
    // reftype Hook of x2gw.FFraming.scan prohibits copy
    // func:x2gw.FFraming..CopyCtor
    inline               FFraming(const x2gw::FFraming &rhs) = delete;
};


// --- x2gw.FGroup
// create: x2gw.FDb.group (Tpool)
// global access: ind_group (Thash, hash field group)
// global access: zd_group (Llist)
// access: x2gw.FMember.p_group (Upptr)
struct FGroup { // x2gw.FGroup
    x2gw::FGroup*         group_next;             // Pointer to next free element int tpool
    x2gw::FGroup*         ind_group_next;         // hash next
    x2gw::FGroup*         zd_group_next;          // zslist link; -1 means not-in-list
    x2gw::FGroup*         zd_group_prev;          // previous element
    algo::Smallstr255     group;                  //
    x2gw::FMember*        zd_group_member_head;   // zero-terminated doubly linked list
    i32                   zd_group_member_n;      // zero-terminated doubly linked list
    x2gw::FMember*        zd_group_member_tail;   // pointer to last element
    algo::cstring         protocol_type;          //
    kafka::GroupState     state;                  //
    algo::cstring         protocol_data;          //
    x2gw::FMember*        c_leader;               // optional pointer
    i32                   generation_id;          //   0
    algo_lib::FTimehook   timeout;                //
    // reftype Llist of x2gw.FGroup.zd_group_member prohibits copy
    // x-reference on x2gw.FGroup.c_leader prevents copy
    // value field x2gw.FGroup.timeout is not copiable
    // func:x2gw.FGroup..AssignOp
    inline x2gw::FGroup& operator =(const x2gw::FGroup &rhs) = delete;
    // reftype Llist of x2gw.FGroup.zd_group_member prohibits copy
    // x-reference on x2gw.FGroup.c_leader prevents copy
    // value field x2gw.FGroup.timeout is not copiable
    // func:x2gw.FGroup..CopyCtor
    inline               FGroup(const x2gw::FGroup &rhs) = delete;
private:
    // func:x2gw.FGroup..Ctor
    inline               FGroup() __attribute__((nothrow));
    // func:x2gw.FGroup..Dtor
    inline               ~FGroup() __attribute__((nothrow));
    friend x2gw::FGroup&        group_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FGroup*        group_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 group_Delete(x2gw::FGroup &row) __attribute__((nothrow));
};


// --- x2gw.FGwport
// create: x2gw.FDb.gwport (Lary)
// global access: cd_accept (Llist)
// global access: gwport (Lary, by rowid)
// access: x2gw.FConn.p_gwport (Upptr)
// access: x2gw.FProc.zd_gwport (Llist)
struct FGwport { // x2gw.FGwport: Gateway listening port
    x2gw::FGwport*      cd_accept_next;        // zslist link; -1 means not-in-list
    x2gw::FGwport*      cd_accept_prev;        // previous element
    algo::Smallstr50    gwport;                // dev4.x2gw-0-0/https-0
    i32                 port;                  //   0  Port number
    algo::Smallstr50    intf;                  // Interface to listen on
    algo::Comment       comment;               //
    x2gw::FGwproto*     p_gwproto;             // reference to parent row
    x2gw::FConn*        zd_gwport_conn_head;   // zero-terminated doubly linked list
    i32                 zd_gwport_conn_n;      // zero-terminated doubly linked list
    x2gw::FConn*        zd_gwport_conn_tail;   // pointer to last element
    algo_lib::FIohook   iohook;                //
    SSL_CTX*            ssl_ctx;               // optional pointer
    algo::cstring       err;                   //
    u64                 n_accept;              //   0  Number of connections accepted
    u64                 n_read_byte;           //   0
    u64                 n_write_byte;          //   0
    u64                 n_read_msg;            //   0
    u64                 n_write_msg;           //   0
    x2gw::FGwport*      zd_gwport_next;        // zslist link; -1 means not-in-list
    x2gw::FGwport*      zd_gwport_prev;        // previous element
    // x-reference on x2gw.FGwport.p_gwproto prevents copy
    // reftype Llist of x2gw.FGwport.zd_gwport_conn prohibits copy
    // value field x2gw.FGwport.iohook is not copiable
    // user-defined fcleanup on x2gw.FGwport.ssl_ctx prevents copy
    // func:x2gw.FGwport..AssignOp
    x2gw::FGwport&       operator =(const x2gw::FGwport &rhs) = delete;
    // x-reference on x2gw.FGwport.p_gwproto prevents copy
    // reftype Llist of x2gw.FGwport.zd_gwport_conn prohibits copy
    // value field x2gw.FGwport.iohook is not copiable
    // user-defined fcleanup on x2gw.FGwport.ssl_ctx prevents copy
    // func:x2gw.FGwport..CopyCtor
    FGwport(const x2gw::FGwport &rhs) = delete;
private:
    // func:x2gw.FGwport..Ctor
    inline               FGwport() __attribute__((nothrow));
    // func:x2gw.FGwport..Dtor
    inline               ~FGwport() __attribute__((nothrow));
    friend x2gw::FGwport&       gwport_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FGwport*       gwport_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gwport_RemoveAll() __attribute__((nothrow));
    friend void                 gwport_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FGwproto
// create: x2gw.FDb.gwproto (Lary)
// global access: gwproto (Lary, by rowid)
// global access: ind_gwproto (Thash, hash field netproto)
// access: x2gw.FGwport.p_gwproto (Upptr)
struct FGwproto { // x2gw.FGwproto
    x2gw::FGwproto*    ind_gwproto_next;   // hash next
    algo::Smallstr50   netproto;           //
    algo::Smallstr50   framing;            //
    i32                dfltport;           //   0
    i32                offset;             //   0
    algo::Comment      comment;            //
    x2gw::FNetproto*   p_netproto;         // reference to parent row
    x2gw::FFraming*    p_framing;          // reference to parent row
    // x-reference on x2gw.FGwproto.p_netproto prevents copy
    // x-reference on x2gw.FGwproto.p_framing prevents copy
    // func:x2gw.FGwproto..AssignOp
    inline x2gw::FGwproto& operator =(const x2gw::FGwproto &rhs) = delete;
    // x-reference on x2gw.FGwproto.p_netproto prevents copy
    // x-reference on x2gw.FGwproto.p_framing prevents copy
    // func:x2gw.FGwproto..CopyCtor
    inline               FGwproto(const x2gw::FGwproto &rhs) = delete;
private:
    // func:x2gw.FGwproto..Ctor
    inline               FGwproto() __attribute__((nothrow));
    // func:x2gw.FGwproto..Dtor
    inline               ~FGwproto() __attribute__((nothrow));
    friend x2gw::FGwproto&      gwproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FGwproto*      gwproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gwproto_RemoveAll() __attribute__((nothrow));
    friend void                 gwproto_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FIntf
// create: x2gw.FDb.intf (Lary)
// global access: intf (Lary, by rowid)
// global access: ind_intf (Thash, hash field intf)
struct FIntf { // x2gw.FIntf
    x2gw::FIntf*       ind_intf_next;   // hash next
    algo::Smallstr50   intf;            //
    algo::Smallstr16   device;          //
    algo::Smallstr50   model;           //
    i64                speed;           //   0
    x2::Operstate      state;           //
    // func:x2gw.FIntf..AssignOp
    inline x2gw::FIntf&  operator =(const x2gw::FIntf &rhs) = delete;
    // func:x2gw.FIntf..CopyCtor
    inline               FIntf(const x2gw::FIntf &rhs) = delete;
private:
    // func:x2gw.FIntf..Ctor
    inline               FIntf() __attribute__((nothrow));
    // func:x2gw.FIntf..Dtor
    inline               ~FIntf() __attribute__((nothrow));
    friend x2gw::FIntf&         intf_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FIntf*         intf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 intf_RemoveAll() __attribute__((nothrow));
    friend void                 intf_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FKafkaAcl
// create: x2gw.FDb.kafka_acl (Tpool)
// access: x2gw.FKafkaAclResource.zd_acl (Llist)
struct FKafkaAcl { // x2gw.FKafkaAcl
    x2gw::FKafkaAcl*           kafka_acl_next;    // Pointer to next free element int tpool
    algo::cstring              principal;         //
    algo::cstring              host;              //
    kafka::AclOperationType    operation;         //
    kafka::AclPermissionType   permission_type;   //
    x2gw::FKafkaAclResource*   p_resource;        // reference to parent row
    x2gw::FKafkaAcl*           zd_acl_next;       // zslist link; -1 means not-in-list
    x2gw::FKafkaAcl*           zd_acl_prev;       // previous element
    // func:x2gw.FKafkaAcl..AssignOp
    inline x2gw::FKafkaAcl& operator =(const x2gw::FKafkaAcl &rhs) = delete;
    // func:x2gw.FKafkaAcl..CopyCtor
    inline               FKafkaAcl(const x2gw::FKafkaAcl &rhs) = delete;
private:
    // func:x2gw.FKafkaAcl..Ctor
    inline               FKafkaAcl() __attribute__((nothrow));
    // func:x2gw.FKafkaAcl..Dtor
    inline               ~FKafkaAcl() __attribute__((nothrow));
    friend x2gw::FKafkaAcl&     kafka_acl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FKafkaAcl*     kafka_acl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 kafka_acl_Delete(x2gw::FKafkaAcl &row) __attribute__((nothrow));
};


// --- x2gw.FKafkaAclResource
// create: x2gw.FDb.kafka_acl_resource (Tpool)
// global access: zd_kafka_acl_resource (Llist)
// global access: ind_kafka_acl_resource (Thash, hash field key)
// access: x2gw.FKafkaAcl.p_resource (Upptr)
struct FKafkaAclResource { // x2gw.FKafkaAclResource
    x2gw::FKafkaAclResource*    kafka_acl_resource_next;       // Pointer to next free element int tpool
    x2gw::FKafkaAclResource*    zd_kafka_acl_resource_next;    // zslist link; -1 means not-in-list
    x2gw::FKafkaAclResource*    zd_kafka_acl_resource_prev;    // previous element
    x2gw::FKafkaAclResource*    ind_kafka_acl_resource_next;   // hash next
    x2gw::KafkaAclResourceKey   key;                           //
    x2gw::FKafkaAcl*            zd_acl_head;                   // zero-terminated doubly linked list
    i32                         zd_acl_n;                      // zero-terminated doubly linked list
    x2gw::FKafkaAcl*            zd_acl_tail;                   // pointer to last element
    // reftype Llist of x2gw.FKafkaAclResource.zd_acl prohibits copy
    // func:x2gw.FKafkaAclResource..AssignOp
    inline x2gw::FKafkaAclResource& operator =(const x2gw::FKafkaAclResource &rhs) = delete;
    // reftype Llist of x2gw.FKafkaAclResource.zd_acl prohibits copy
    // func:x2gw.FKafkaAclResource..CopyCtor
    inline               FKafkaAclResource(const x2gw::FKafkaAclResource &rhs) = delete;
private:
    // func:x2gw.FKafkaAclResource..Ctor
    inline               FKafkaAclResource() __attribute__((nothrow));
    // func:x2gw.FKafkaAclResource..Dtor
    inline               ~FKafkaAclResource() __attribute__((nothrow));
    friend x2gw::FKafkaAclResource& kafka_acl_resource_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FKafkaAclResource* kafka_acl_resource_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 kafka_acl_resource_Delete(x2gw::FKafkaAclResource &row) __attribute__((nothrow));
};


// --- x2gw.FKafkaFetch
// create: x2gw.FDb.kafka_fetch (Tpool)
// access: x2gw.FFetch.p_kafka_fetch (Upptr)
// access: x2gw.FSession.zd_session_kafka_fetch (Llist)
struct FKafkaFetch { // x2gw.FKafkaFetch
    x2gw::FKafkaFetch*      kafka_fetch_next;              // Pointer to next free element int tpool
    kafka2::FetchResponse   rsp;                           //
    x2gw::FSession*         p_session;                     // reference to parent row
    x2gw::FFetch*           zd_kafka_fetch_fetch_head;     // zero-terminated doubly linked list
    i32                     zd_kafka_fetch_fetch_n;        // zero-terminated doubly linked list
    x2gw::FFetch*           zd_kafka_fetch_fetch_tail;     // pointer to last element
    algo_lib::FTimehook     timeout;                       //
    x2gw::FKafkaFetch*      zd_session_kafka_fetch_next;   // zslist link; -1 means not-in-list
    x2gw::FKafkaFetch*      zd_session_kafka_fetch_prev;   // previous element
    // reftype Llist of x2gw.FKafkaFetch.zd_kafka_fetch_fetch prohibits copy
    // value field x2gw.FKafkaFetch.timeout is not copiable
    // func:x2gw.FKafkaFetch..AssignOp
    inline x2gw::FKafkaFetch& operator =(const x2gw::FKafkaFetch &rhs) = delete;
    // reftype Llist of x2gw.FKafkaFetch.zd_kafka_fetch_fetch prohibits copy
    // value field x2gw.FKafkaFetch.timeout is not copiable
    // func:x2gw.FKafkaFetch..CopyCtor
    inline               FKafkaFetch(const x2gw::FKafkaFetch &rhs) = delete;
private:
    // func:x2gw.FKafkaFetch..Ctor
    inline               FKafkaFetch() __attribute__((nothrow));
    // func:x2gw.FKafkaFetch..Dtor
    inline               ~FKafkaFetch() __attribute__((nothrow));
    friend x2gw::FKafkaFetch&   kafka_fetch_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FKafkaFetch*   kafka_fetch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 kafka_fetch_Delete(x2gw::FKafkaFetch &row) __attribute__((nothrow));
};


// --- x2gw.FMember
// create: x2gw.FDb.member (Tpool)
// access: x2gw.FGroup.zd_group_member (Llist)
// access: x2gw.FGroup.c_leader (Ptr)
// access: x2gw.FSession.zd_session_member (Llist)
struct FMember { // x2gw.FMember
    x2gw::FMember*          member_next;              // Pointer to next free element int tpool
    x2gw::FMember*          zd_group_member_next;     // zslist link; -1 means not-in-list
    x2gw::FMember*          zd_group_member_prev;     // previous element
    x2gw::FGroup*           p_group;                  // reference to parent row
    x2gw::FSession*         p_session;                // reference to parent row
    algo::Smallstr255       member;                   //
    algo::cstring           client_id;                //
    algo::cstring           client_host;              //
    kafka::MemberState      state;                    //
    i32                     session_timeout_ms;       //   0
    i32                     rebalance_timeout_ms;     //   0
    i16                     request_api_version;      //   0
    i32                     correlation_id;           //   0
    bool                    leader;                   //   false
    x2gw::MemberProtocol*   protocol_elems;           // pointer to elements
    u32                     protocol_n;               // number of elements in array
    u32                     protocol_max;             // max. capacity of array before realloc
    algo::ByteAry           assignment;               //
    bool                    assigned;                 //   false
    algo_lib::FTimehook     timeout;                  //
    x2gw::FMember*          zd_session_member_next;   // zslist link; -1 means not-in-list
    x2gw::FMember*          zd_session_member_prev;   // previous element
    // user-defined fcleanup on x2gw.FMember.p_group prevents copy
    // value field x2gw.FMember.timeout is not copiable
    // func:x2gw.FMember..AssignOp
    x2gw::FMember&       operator =(const x2gw::FMember &rhs) = delete;
    // user-defined fcleanup on x2gw.FMember.p_group prevents copy
    // value field x2gw.FMember.timeout is not copiable
    // func:x2gw.FMember..CopyCtor
    FMember(const x2gw::FMember &rhs) = delete;
private:
    // func:x2gw.FMember..Ctor
    inline               FMember() __attribute__((nothrow));
    // func:x2gw.FMember..Dtor
    inline               ~FMember() __attribute__((nothrow));
    friend x2gw::FMember&       member_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FMember*       member_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 member_Delete(x2gw::FMember &row) __attribute__((nothrow));
};


// --- x2gw.FMetric
// create: x2gw.FDb.metric (Lary)
// global access: metric (Lary, by rowid)
// global access: ind_metric (Thash, hash field metric)
// global access: ind_metric_id (Thash, hash field id)
// global access: h_pub_metric (Hook)
// global access: h_def_metric (Hook)
// access: x2gw.FMoentryKey.p_metric (Upptr)
struct FMetric { // x2gw.FMetric
    x2gw::FMetric*      ind_metric_next;          // hash next
    x2gw::FMetric*      ind_metric_id_next;       // hash next
    algo::Smallstr150   metric;                   // Unique key
    x2::MetricType      type;                     // Metric/counter/gauge
    x2::MetricId        id;                       // Unique ID
    algo::UnTime        tend;                     // Interval end time
    u64                 vmin;                     //   0  Minimum value within the interval
    u64                 vmax;                     //   0  Maximum value within the interval
    u64                 vend;                     //   0  Value at the end of interval
    u64                 n;                        //   0  Number of value changes within the interval
    x2gw::FMoentry*     zd_metric_moentry_head;   // zero-terminated doubly linked list
    i32                 zd_metric_moentry_n;      // zero-terminated doubly linked list
    x2gw::FMoentry*     zd_metric_moentry_tail;   // pointer to last element
    // reftype Llist of x2gw.FMetric.zd_metric_moentry prohibits copy
    // func:x2gw.FMetric..AssignOp
    inline x2gw::FMetric& operator =(const x2gw::FMetric &rhs) = delete;
    // reftype Llist of x2gw.FMetric.zd_metric_moentry prohibits copy
    // func:x2gw.FMetric..CopyCtor
    inline               FMetric(const x2gw::FMetric &rhs) = delete;
private:
    // func:x2gw.FMetric..Ctor
    inline               FMetric() __attribute__((nothrow));
    // func:x2gw.FMetric..Dtor
    inline               ~FMetric() __attribute__((nothrow));
    friend x2gw::FMetric&       metric_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FMetric*       metric_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 metric_RemoveAll() __attribute__((nothrow));
    friend void                 metric_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FMoentry
// create: x2gw.FDb.moentry (Tpool)
// global access: ind_moentry (Thash, hash field key)
// access: x2gw.FConn.zd_conn_moentry (Llist)
// access: x2gw.FConn.zd_conn_moentry_pending (Llist)
// access: x2gw.FMetric.zd_metric_moentry (Llist)
struct FMoentry { // x2gw.FMoentry: Metric Outflow Entry
    x2gw::FMoentry*     zd_conn_moentry_next;           // zslist link; -1 means not-in-list
    x2gw::FMoentry*     zd_conn_moentry_prev;           // previous element
    x2gw::FMoentry*     zd_conn_moentry_pending_next;   // zslist link; -1 means not-in-list
    x2gw::FMoentry*     zd_conn_moentry_pending_prev;   // previous element
    x2gw::FMoentry*     moentry_next;                   // Pointer to next free element int tpool
    x2gw::FMoentry*     ind_moentry_next;               // hash next
    x2gw::FMoentry*     zd_metric_moentry_next;         // zslist link; -1 means not-in-list
    x2gw::FMoentry*     zd_metric_moentry_prev;         // previous element
    x2gw::FMoentryKey   key;                            //
    bool                isnew;                          //   false
    u64                 vmin;                           //   0  Min value within the interval
    u64                 vmax;                           //   0  Max value within the interval
    u64                 n;                              //   0  Number of samples in the interval
    // func:x2gw.FMoentry..AssignOp
    inline x2gw::FMoentry& operator =(const x2gw::FMoentry &rhs) = delete;
    // func:x2gw.FMoentry..CopyCtor
    inline               FMoentry(const x2gw::FMoentry &rhs) = delete;
private:
    // func:x2gw.FMoentry..Ctor
    inline               FMoentry() __attribute__((nothrow));
    // func:x2gw.FMoentry..Dtor
    inline               ~FMoentry() __attribute__((nothrow));
    friend x2gw::FMoentry&      moentry_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FMoentry*      moentry_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 moentry_Delete(x2gw::FMoentry &row) __attribute__((nothrow));
};


// --- x2gw.FMoentryKey
#pragma pack(push,1)
struct FMoentryKey { // x2gw.FMoentryKey: Key of FmMoentry
    x2gw::FConn*     p_conn;     // reference to parent row
    x2gw::FMetric*   p_metric;   // reference to parent row
    // func:x2gw.FMoentryKey..EqOp
    inline bool          operator ==(const x2gw::FMoentryKey &rhs) const __attribute__((nothrow));
    // func:x2gw.FMoentryKey..NeOp
    inline bool          operator !=(const x2gw::FMoentryKey &rhs) const __attribute__((nothrow));
    // func:x2gw.FMoentryKey..Ctor
    inline               FMoentryKey() __attribute__((nothrow));
    // func:x2gw.FMoentryKey..FieldwiseCtor
    explicit inline               FMoentryKey(x2gw::FConn* in_p_conn, x2gw::FMetric* in_p_metric) __attribute__((nothrow));
};
#pragma pack(pop)


// --- x2gw.FNetproto
// create: x2gw.FDb.netproto (Inlary)
// global access: ind_netproto (Thash, hash field netproto)
// access: x2gw.FGwproto.p_netproto (Upptr)
struct FNetproto { // x2gw.FNetproto
    algo::Smallstr50   netproto;            //
    bool               tls;                 //   false
    algo::Comment      comment;             //
    x2gw::FNetproto*   ind_netproto_next;   // hash next
    // func:x2gw.FNetproto..AssignOp
    inline x2gw::FNetproto& operator =(const x2gw::FNetproto &rhs) = delete;
    // func:x2gw.FNetproto..Ctor
    inline               FNetproto() __attribute__((nothrow));
    // func:x2gw.FNetproto..Dtor
    inline               ~FNetproto() __attribute__((nothrow));
    // func:x2gw.FNetproto..CopyCtor
    inline               FNetproto(const x2gw::FNetproto &rhs) = delete;
};


// --- x2gw.FOpenStream
// create: x2gw.FDb.open_stream (Tpool)
// access: x2gw.FSession.ind_stream_user_id (Thash)
struct FOpenStream { // x2gw.FOpenStream
    x2gw::FOpenStream*   open_stream_next;          // Pointer to next free element int tpool
    x2gw::FSession*      p_session;                 // reference to parent row
    x2gw::FStream*       p_stream;                  // reference to parent row
    x2::StreamId         user_id;                   //
    x2gw::FOpenStream*   ind_stream_user_id_next;   // hash next
    // func:x2gw.FOpenStream..AssignOp
    inline x2gw::FOpenStream& operator =(const x2gw::FOpenStream &rhs) = delete;
    // func:x2gw.FOpenStream..CopyCtor
    inline               FOpenStream(const x2gw::FOpenStream &rhs) = delete;
private:
    // func:x2gw.FOpenStream..Ctor
    inline               FOpenStream() __attribute__((nothrow));
    // func:x2gw.FOpenStream..Dtor
    inline               ~FOpenStream() __attribute__((nothrow));
    friend x2gw::FOpenStream&   open_stream_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FOpenStream*   open_stream_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 open_stream_Delete(x2gw::FOpenStream &row) __attribute__((nothrow));
};


// --- x2gw.FPacket
// create: x2gw.FDb.packet (Tpool)
// access: x2gw.FFetch.zd_packet_queue (Llist)
// access: x2gw.FSession.ind_unacked (Thash)
// access: x2gw.FSession.zd_session_packet (Llist)
struct FPacket { // x2gw.FPacket
    x2gw::FPacket*           packet_next;              // Pointer to next free element int tpool
    x2gw::FPacket*           zd_packet_queue_next;     // zslist link; -1 means not-in-list
    x2gw::FPacket*           zd_packet_queue_prev;     // previous element
    x2gw::FSession*          p_session;                // reference to parent row
    x2gw::FFetch*            p_fetch;                  // reference to parent row
    mqtt::PacketIdentifier   packet_identifier;        //
    bool                     received;                 //   false
    algo::cstring            application_message;      //
    x2gw::FPacket*           ind_unacked_next;         // hash next
    x2gw::FPacket*           zd_session_packet_next;   // zslist link; -1 means not-in-list
    x2gw::FPacket*           zd_session_packet_prev;   // previous element
    // func:x2gw.FPacket..AssignOp
    inline x2gw::FPacket& operator =(const x2gw::FPacket &rhs) = delete;
    // func:x2gw.FPacket..CopyCtor
    inline               FPacket(const x2gw::FPacket &rhs) = delete;
private:
    // func:x2gw.FPacket..Ctor
    inline               FPacket() __attribute__((nothrow));
    // func:x2gw.FPacket..Dtor
    inline               ~FPacket() __attribute__((nothrow));
    friend x2gw::FPacket&       packet_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FPacket*       packet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 packet_Delete(x2gw::FPacket &row) __attribute__((nothrow));
};


// --- x2gw.FProc
// create: x2gw.FDb.proc (Lary)
// global access: proc (Lary, by rowid)
// global access: ind_proc (Thash, hash field proc)
struct FProc { // x2gw.FProc
    x2gw::FProc*       ind_proc_next;    // hash next
    algo::Smallstr50   proc;             // E.g. dev1.sup-0
    algo::Smallstr50   core;             //
    i32                hbtimeout;        //   30
    algo::Comment      comment;          //
    x2gw::FGwport*     zd_gwport_head;   // zero-terminated doubly linked list
    i32                zd_gwport_n;      // zero-terminated doubly linked list
    x2gw::FGwport*     zd_gwport_tail;   // pointer to last element
    lib_x2::FX2node*   p_x2node;         // reference to parent row
    // reftype Llist of x2gw.FProc.zd_gwport prohibits copy
    // x-reference on x2gw.FProc.p_x2node prevents copy
    // func:x2gw.FProc..AssignOp
    x2gw::FProc&         operator =(const x2gw::FProc &rhs) = delete;
    // reftype Llist of x2gw.FProc.zd_gwport prohibits copy
    // x-reference on x2gw.FProc.p_x2node prevents copy
    // func:x2gw.FProc..CopyCtor
    FProc(const x2gw::FProc &rhs) = delete;
private:
    // func:x2gw.FProc..Ctor
    inline               FProc() __attribute__((nothrow));
    // func:x2gw.FProc..Dtor
    inline               ~FProc() __attribute__((nothrow));
    friend x2gw::FProc&         proc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FProc*         proc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 proc_RemoveAll() __attribute__((nothrow));
    friend void                 proc_RemoveLast() __attribute__((nothrow));
};


// --- x2gw.FProcOutput
// create: x2gw.FDb.proc_output (Tpool)
// global access: ind_proc_output (Thash, hash field request_proc_id)
// global access: self_output (Ptr)
// access: x2gw.FCmdreq.c_proc_output (Ptrary)
struct FProcOutput { // x2gw.FProcOutput
    x2gw::FProcOutput*   proc_output_next;              // Pointer to next free element int tpool
    x2gw::FProcOutput*   ind_proc_output_next;          // hash next
    x2::RequestProcId    request_proc_id;               //
    algo::cstring        output;                        //
    bool                 done;                          //   false
    x2gw::FCmdreq*       p_cmdreq;                      // reference to parent row
    bool                 cmdreq_c_proc_output_in_ary;   //   false  membership flag
    // x-reference on x2gw.FProcOutput.p_cmdreq prevents copy
    // func:x2gw.FProcOutput..AssignOp
    inline x2gw::FProcOutput& operator =(const x2gw::FProcOutput &rhs) = delete;
    // x-reference on x2gw.FProcOutput.p_cmdreq prevents copy
    // func:x2gw.FProcOutput..CopyCtor
    inline               FProcOutput(const x2gw::FProcOutput &rhs) = delete;
private:
    // func:x2gw.FProcOutput..Ctor
    inline               FProcOutput() __attribute__((nothrow));
    // func:x2gw.FProcOutput..Dtor
    inline               ~FProcOutput() __attribute__((nothrow));
    friend x2gw::FProcOutput&   proc_output_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FProcOutput*   proc_output_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 proc_output_Delete(x2gw::FProcOutput &row) __attribute__((nothrow));
};


// --- x2gw.FProducer
// create: x2gw.FDb.producer (Tpool)
// global access: zd_producer (Llist)
// global access: ind_producer (Thash, hash field request_id)
// access: x2gw.FSession.zd_session_producer (Llist)
// access: x2gw.FSession.ind_produce_pi (Thash)
struct FProducer { // x2gw.FProducer: A single producer request
    x2gw::FProducer*            producer_next;              // Pointer to next free element int tpool
    x2gw::FProducer*            zd_producer_next;           // zslist link; -1 means not-in-list
    x2gw::FProducer*            zd_producer_prev;           // previous element
    x2gw::FProducer*            ind_producer_next;          // hash next
    x2gw::FSession*             p_session;                  // reference to parent row
    x2gw::FStream*              p_stream;                   // reference to parent row
    x2::RequestId               origin_request_id;          //
    x2::RequestId               request_id;                 //
    i16                         api_version;                //   0
    algo::cstring               topic;                      //
    i32                         partition;                  //   0
    mqtt::PacketIdentifier      packet_identifier;          //
    mqtt::Qos                   qos;                        //
    bool                        acked;                      //   false
    x2gw::producer_h_ack_hook   h_ack;                      //   NULL  Pointer to a function
    u64                         h_ack_ctx;                  //   0  Callback context
    x2gw::RespProduceOp         op;                         //
    i32                         kafka_acks;                 //   0
    kafka2::ResponseHeader*     rsp;                        // optional pointer
    x2gw::FProducer*            zd_session_producer_next;   // zslist link; -1 means not-in-list
    x2gw::FProducer*            zd_session_producer_prev;   // previous element
    x2gw::FProducer*            ind_produce_pi_next;        // hash next
    // reftype Hook of x2gw.FProducer.h_ack prohibits copy
    // user-defined fcleanup on x2gw.FProducer.rsp prevents copy
    // func:x2gw.FProducer..AssignOp
    x2gw::FProducer&     operator =(const x2gw::FProducer &rhs) = delete;
    // reftype Hook of x2gw.FProducer.h_ack prohibits copy
    // user-defined fcleanup on x2gw.FProducer.rsp prevents copy
    // func:x2gw.FProducer..CopyCtor
    FProducer(const x2gw::FProducer &rhs) = delete;
private:
    // func:x2gw.FProducer..Ctor
    inline               FProducer() __attribute__((nothrow));
    // func:x2gw.FProducer..Dtor
    inline               ~FProducer() __attribute__((nothrow));
    friend x2gw::FProducer&     producer_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FProducer*     producer_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 producer_Delete(x2gw::FProducer &row) __attribute__((nothrow));
};


// --- x2gw.FSession
// create: x2gw.FDb.session (Tpool)
// global access: zd_session (Llist)
// global access: cur_session (Ptr)
// global access: ind_session_clientid (Thash, hash field client_identifier)
// access: x2gw.FFetch.p_session (Upptr)
// access: x2gw.FKafkaFetch.p_session (Upptr)
// access: x2gw.FMember.p_session (Upptr)
// access: x2gw.FOpenStream.p_session (Upptr)
// access: x2gw.FPacket.p_session (Upptr)
// access: x2gw.FProducer.p_session (Upptr)
// access: x2gw.FSessionConn.p_session (Upptr)
struct FSession { // x2gw.FSession
    x2gw::FSession*          session_next;                       // Pointer to next free element int tpool
    x2gw::FSession*          zd_session_next;                    // zslist link; -1 means not-in-list
    x2gw::FSession*          zd_session_prev;                    // previous element
    x2gw::FSession*          ind_session_clientid_next;          // hash next
    u64                      id;                                 //   0
    u16                      receive_maximum;                    //   0
    algo::cstring            client_identifier;                  //
    u32                      expiry_interval;                    //   0
    x2gw::FFetch*            zd_session_fetch_head;              // zero-terminated doubly linked list
    i32                      zd_session_fetch_n;                 // zero-terminated doubly linked list
    x2gw::FFetch*            zd_session_fetch_tail;              // pointer to last element
    x2gw::FProducer*         zd_session_producer_head;           // zero-terminated doubly linked list
    i32                      zd_session_producer_n;              // zero-terminated doubly linked list
    x2gw::FProducer*         zd_session_producer_tail;           // pointer to last element
    x2gw::FFetch*            zd_session_fetch_queue_head;        // zero-terminated doubly linked list
    i32                      zd_session_fetch_queue_n;           // zero-terminated doubly linked list
    x2gw::FFetch*            zd_session_fetch_queue_tail;        // pointer to last element
    bool                     suspend;                            //   false
    x2gw::FProducer**        ind_produce_pi_buckets_elems;       // pointer to bucket array
    i32                      ind_produce_pi_buckets_n;           // number of elements in bucket array
    i32                      ind_produce_pi_n;                   // number of elements in the hash table
    mqtt::PacketIdentifier   next_packet_identifier;             //   1
    x2gw::FPacket**          ind_unacked_buckets_elems;          // pointer to bucket array
    i32                      ind_unacked_buckets_n;              // number of elements in bucket array
    i32                      ind_unacked_n;                      // number of elements in the hash table
    algo_lib::FTimehook      timeout;                            //
    x2gw::FPacket*           zd_session_packet_head;             // zero-terminated doubly linked list
    i32                      zd_session_packet_n;                // zero-terminated doubly linked list
    x2gw::FPacket*           zd_session_packet_tail;             // pointer to last element
    x2gw::FFetch*            cd_session_fetch_queue_head;        // zero-terminated doubly linked list
    i32                      cd_session_fetch_queue_n;           // zero-terminated doubly linked list
    x2gw::FSessionConn*      c_session_conn;                     // optional pointer
    x2gw::FOpenStream**      ind_stream_user_id_buckets_elems;   // pointer to bucket array
    i32                      ind_stream_user_id_buckets_n;       // number of elements in bucket array
    i32                      ind_stream_user_id_n;               // number of elements in the hash table
    x2::StreamId             next_stream_user_id;                //   1
    i32                      resp_protover;                      //   2
    algo::cstring            resp_client_name;                   //
    nats::ConnectOptions     nats_connect_opts;                  //
    x2gw::FKafkaFetch*       zd_session_kafka_fetch_head;        // zero-terminated doubly linked list
    i32                      zd_session_kafka_fetch_n;           // zero-terminated doubly linked list
    x2gw::FKafkaFetch*       zd_session_kafka_fetch_tail;        // pointer to last element
    i64                      producer_id;                        //   -1  Kafka idempotent ot trasactional PID
    x2gw::FMember*           zd_session_member_head;             // zero-terminated doubly linked list
    i32                      zd_session_member_n;                // zero-terminated doubly linked list
    x2gw::FMember*           zd_session_member_tail;             // pointer to last element
    // reftype Llist of x2gw.FSession.zd_session_fetch prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_producer prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_fetch_queue prohibits copy
    // reftype Thash of x2gw.FSession.ind_produce_pi prohibits copy
    // reftype Thash of x2gw.FSession.ind_unacked prohibits copy
    // value field x2gw.FSession.timeout is not copiable
    // reftype Llist of x2gw.FSession.zd_session_packet prohibits copy
    // reftype Llist of x2gw.FSession.cd_session_fetch_queue prohibits copy
    // x-reference on x2gw.FSession.c_session_conn prevents copy
    // reftype Thash of x2gw.FSession.ind_stream_user_id prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_kafka_fetch prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_member prohibits copy
    // func:x2gw.FSession..AssignOp
    x2gw::FSession&      operator =(const x2gw::FSession &rhs) = delete;
    // reftype Llist of x2gw.FSession.zd_session_fetch prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_producer prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_fetch_queue prohibits copy
    // reftype Thash of x2gw.FSession.ind_produce_pi prohibits copy
    // reftype Thash of x2gw.FSession.ind_unacked prohibits copy
    // value field x2gw.FSession.timeout is not copiable
    // reftype Llist of x2gw.FSession.zd_session_packet prohibits copy
    // reftype Llist of x2gw.FSession.cd_session_fetch_queue prohibits copy
    // x-reference on x2gw.FSession.c_session_conn prevents copy
    // reftype Thash of x2gw.FSession.ind_stream_user_id prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_kafka_fetch prohibits copy
    // reftype Llist of x2gw.FSession.zd_session_member prohibits copy
    // func:x2gw.FSession..CopyCtor
    FSession(const x2gw::FSession &rhs) = delete;
private:
    // func:x2gw.FSession..Ctor
    inline               FSession() __attribute__((nothrow));
    // func:x2gw.FSession..Dtor
    inline               ~FSession() __attribute__((nothrow));
    friend x2gw::FSession&      session_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FSession*      session_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 session_Delete(x2gw::FSession &row) __attribute__((nothrow));
};


// --- x2gw.FSessionConn
// create: x2gw.FDb.session_conn (Tpool)
// access: x2gw.FConn.c_session_conn (Ptr)
// access: x2gw.FSession.c_session_conn (Ptr)
struct FSessionConn { // x2gw.FSessionConn
    x2gw::FSessionConn*   session_conn_next;   // Pointer to next free element int tpool
    x2gw::FSession*       p_session;           // reference to parent row
    x2gw::FConn*          p_conn;              // reference to parent row
    // func:x2gw.FSessionConn..AssignOp
    inline x2gw::FSessionConn& operator =(const x2gw::FSessionConn &rhs) = delete;
    // func:x2gw.FSessionConn..CopyCtor
    inline               FSessionConn(const x2gw::FSessionConn &rhs) = delete;
private:
    // func:x2gw.FSessionConn..Ctor
    inline               FSessionConn() __attribute__((nothrow));
    // func:x2gw.FSessionConn..Dtor
    inline               ~FSessionConn() __attribute__((nothrow));
    friend x2gw::FSessionConn&  session_conn_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FSessionConn*  session_conn_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 session_conn_Delete(x2gw::FSessionConn &row) __attribute__((nothrow));
};


// --- x2gw.FStream
// create: x2gw.FDb.stream (Tpool)
// global access: ind_stream (Thash, hash field stream_id)
// global access: ind_stream_name (Thash, hash field name)
// global access: zd_stream (Llist)
// access: x2gw.FFetch.p_stream (Upptr)
// access: x2gw.FOpenStream.p_stream (Upptr)
// access: x2gw.FProducer.p_stream (Upptr)
struct FStream { // x2gw.FStream
    x2gw::FStream*     stream_next;            // Pointer to next free element int tpool
    x2gw::FStream*     ind_stream_next;        // hash next
    x2gw::FStream*     ind_stream_name_next;   // hash next
    x2gw::FStream*     zd_stream_next;         // zslist link; -1 means not-in-list
    x2gw::FStream*     zd_stream_prev;         // previous element
    algo::cstring      name;                   // Full stream name: /a/b/c
    x2::StreamId       stream_id;              //
    lib_x2::FStream*   p_x2stream;             // reference to parent row
    u64                next_pos;               //   0
    x2gw::FFetch*      zd_stream_fetch_head;   // zero-terminated doubly linked list
    i32                zd_stream_fetch_n;      // zero-terminated doubly linked list
    x2gw::FFetch*      zd_stream_fetch_tail;   // pointer to last element
    // reftype Llist of x2gw.FStream.zd_stream_fetch prohibits copy
    // func:x2gw.FStream..AssignOp
    inline x2gw::FStream& operator =(const x2gw::FStream &rhs) = delete;
    // reftype Llist of x2gw.FStream.zd_stream_fetch prohibits copy
    // func:x2gw.FStream..CopyCtor
    inline               FStream(const x2gw::FStream &rhs) = delete;
private:
    // func:x2gw.FStream..Ctor
    inline               FStream() __attribute__((nothrow));
    // func:x2gw.FStream..Dtor
    inline               ~FStream() __attribute__((nothrow));
    friend x2gw::FStream&       stream_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FStream*       stream_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 stream_Delete(x2gw::FStream &row) __attribute__((nothrow));
};


// --- x2gw.FTopic
// create: x2gw.FDb.topic (Tpool)
// global access: ind_topic (Thash, hash field name)
// global access: ind_topic_id (Thash, hash field id)
// global access: zd_topic (Llist)
struct FTopic { // x2gw.FTopic
    x2gw::FTopic*       topic_next;           // Pointer to next free element int tpool
    x2gw::FTopic*       ind_topic_next;       // hash next
    x2gw::FTopic*       ind_topic_id_next;    // hash next
    x2gw::FTopic*       zd_topic_next;        // zslist link; -1 means not-in-list
    x2gw::FTopic*       zd_topic_prev;        // previous element
    algo::Uuid          id;                   //
    algo::Smallstr249   name;                 //
    algo::cstring       stream;               //
    i16                 replication_factor;   //   0
    i32                 num_partitions;       //   0
    // func:x2gw.FTopic..AssignOp
    inline x2gw::FTopic& operator =(const x2gw::FTopic &rhs) = delete;
    // func:x2gw.FTopic..CopyCtor
    inline               FTopic(const x2gw::FTopic &rhs) = delete;
private:
    // func:x2gw.FTopic..Ctor
    inline               FTopic() __attribute__((nothrow));
    // func:x2gw.FTopic..Dtor
    inline               ~FTopic() __attribute__((nothrow));
    friend x2gw::FTopic&        topic_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FTopic*        topic_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 topic_Delete(x2gw::FTopic &row) __attribute__((nothrow));
};


// --- x2gw.FUser
// create: x2gw.FDb.user (Tpool)
// global access: ind_user (Thash, hash field user)
// global access: c_user_sorted (Ptrary)
// global access: c_user_anon (Ptr)
// global access: c_user_root (Ptr)
// access: x2gw.FConn.p_user (Upptr)
struct FUser { // x2gw.FUser
    x2gw::FUser*       user_next;                  // Pointer to next free element int tpool
    x2gw::FUser*       ind_user_next;              // hash next
    algo::Smallstr50   user;                       //
    algo::cstring      password;                   //
    x2gw::FConn*       zd_user_conn_head;          // zero-terminated doubly linked list
    i32                zd_user_conn_n;             // zero-terminated doubly linked list
    x2gw::FConn*       zd_user_conn_tail;          // pointer to last element
    x2::PasswordKind   password_kind;              //
    bool               _db_c_user_sorted_in_ary;   //   false  membership flag
    // reftype Llist of x2gw.FUser.zd_user_conn prohibits copy
    // func:x2gw.FUser..AssignOp
    inline x2gw::FUser&  operator =(const x2gw::FUser &rhs) = delete;
    // reftype Llist of x2gw.FUser.zd_user_conn prohibits copy
    // func:x2gw.FUser..CopyCtor
    inline               FUser(const x2gw::FUser &rhs) = delete;
private:
    // func:x2gw.FUser..Ctor
    inline               FUser() __attribute__((nothrow));
    // func:x2gw.FUser..Dtor
    inline               ~FUser() __attribute__((nothrow));
    friend x2gw::FUser&         user_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend x2gw::FUser*         user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 user_Delete(x2gw::FUser &row) __attribute__((nothrow));
};


// --- x2gw.Fetch
// access: x2gw.FFetch.base (Base)
struct Fetch { // x2gw.Fetch
    x2::RequestId       request_id;            //
    x2::RequestId       origin_request_id;     //
    algo::SeqType       beg_seq;               //
    algo::SeqType       end_seq;               //
    i32                 rsp_topic_index;       //   -1
    i32                 rsp_partition_index;   //   -1  Kafka API version
    algo::cstring       sid;                   //
    algo::cstring       subject;               //
    algo::cstring       channel;               //
    mqtt::Qos           qos;                   //
    x2gw::RespFetchOp   op;                    //
    i32                 n_suspend;             //   0  Counter of # of suspensions
    i32                 n_send;                //   0  Counter of # of Sends
    i32                 n_resume;              //   0  Counter of # of resumes
    // func:x2gw.Fetch..Ctor
    inline               Fetch() __attribute__((nothrow));
};


// --- x2gw.KafkaAclResourceKey
struct KafkaAclResourceKey { // x2gw.KafkaAclResourceKey
    kafka::ResourceType   resource_type;           //
    algo::cstring         resource_name;           //
    kafka::PatternType    resource_pattern_type;   //
    // func:x2gw.KafkaAclResourceKey..EqOp
    inline bool          operator ==(const x2gw::KafkaAclResourceKey &rhs) const __attribute__((nothrow));
    // func:x2gw.KafkaAclResourceKey..NeOp
    inline bool          operator !=(const x2gw::KafkaAclResourceKey &rhs) const __attribute__((nothrow));
    // func:x2gw.KafkaAclResourceKey..Ctor
    inline               KafkaAclResourceKey() __attribute__((nothrow));
};


// --- x2gw.MemberProtocol
// create: x2gw.FMember.protocol (Tary)
struct MemberProtocol { // x2gw.MemberProtocol
    algo::cstring   name;       //
    algo::ByteAry   metadata;   //
    // func:x2gw.MemberProtocol..Ctor
    inline               MemberProtocol() __attribute__((nothrow));
};


// --- x2gw_RespFetchOpEnum

enum x2gw_RespFetchOpEnum {            // x2gw.RespFetchOp.value
     x2gw_RespFetchOp_subscribe   = 0
    ,x2gw_RespFetchOp_get         = 1
};

enum { x2gw_RespFetchOpEnum_N = 2 };


// --- x2gw.RespFetchOp
struct RespFetchOp { // x2gw.RespFetchOp
    u8   value;   //   0
    // func:x2gw.RespFetchOp..Ctor
    inline               RespFetchOp() __attribute__((nothrow));
    // func:x2gw.RespFetchOp..EnumCtor
    inline               RespFetchOp(x2gw_RespFetchOpEnum arg) __attribute__((nothrow));
};


// --- x2gw_RespProduceOpEnum

enum x2gw_RespProduceOpEnum {          // x2gw.RespProduceOp.value
     x2gw_RespProduceOp_publish   = 0
    ,x2gw_RespProduceOp_set       = 1
    ,x2gw_RespProduceOp_del       = 2
};

enum { x2gw_RespProduceOpEnum_N = 3 };


// --- x2gw.RespProduceOp
struct RespProduceOp { // x2gw.RespProduceOp
    u8   value;   //   0
    // func:x2gw.RespProduceOp..Ctor
    inline               RespProduceOp() __attribute__((nothrow));
    // func:x2gw.RespProduceOp..EnumCtor
    inline               RespProduceOp(x2gw_RespProduceOpEnum arg) __attribute__((nothrow));
};


// --- x2gw.Session
// access: x2gw.FSession.base (Base)
struct Session { // x2gw.Session
    u64             id;                  //   0
    u16             receive_maximum;     //   0
    algo::cstring   client_identifier;   //
    u32             expiry_interval;     //   0
    // func:x2gw.Session..Ctor
    inline               Session() __attribute__((nothrow));
};


// --- x2gw_InCaseEnum

enum x2gw_InCaseEnum {                        // x2gw.InCase.value
     x2gw_InCase_x2_AckMsg             = 620
    ,x2gw_InCase_x2_CmdDoneMsg         = 643
    ,x2gw_InCase_x2_CmdOutputMsg       = 645
    ,x2gw_InCase_x2_CreateAclMsg       = 661
    ,x2gw_InCase_x2_CreateStreamMsg    = 602
    ,x2gw_InCase_x2_CreateTopicMsg     = 663
    ,x2gw_InCase_x2_CreateUserMsg      = 609
    ,x2gw_InCase_x2_DataMsg            = 616
    ,x2gw_InCase_x2_DefDiskMsg         = 651
    ,x2gw_InCase_x2_DefIntfMsg         = 652
    ,x2gw_InCase_x2_DefMetricMsg       = 648
    ,x2gw_InCase_x2_DiskStateMsg       = 653
    ,x2gw_InCase_x2_EnableMetricsMsg   = 660
    ,x2gw_InCase_x2_IntfStateMsg       = 654
    ,x2gw_InCase_x2_KafkaAclMsg        = 662
    ,x2gw_InCase_x2_PubMetricMsg       = 649
    ,x2gw_InCase_x2_SetUserPassMsg     = 659
    ,x2gw_InCase_x2_StreamHbMsg        = 601
    ,x2gw_InCase_x2_X2nodeStateMsg     = 646
};

enum { x2gw_InCaseEnum_N = 19 };


// --- x2gw.InCase
#pragma pack(push,1)
struct InCase { // x2gw.InCase: Enum for dispatch x2gw.In
    u32   value;   //   0
    // func:x2gw.InCase.value.Cast
    inline               operator x2gw_InCaseEnum() const __attribute__((nothrow));
    // func:x2gw.InCase..Ctor
    inline               InCase() __attribute__((nothrow));
    // func:x2gw.InCase..FieldwiseCtor
    explicit inline               InCase(u32 in_value) __attribute__((nothrow));
    // func:x2gw.InCase..EnumCtor
    inline               InCase(x2gw_InCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)


// --- x2gw_KafkaInCaseEnum

enum x2gw_KafkaInCaseEnum {                                  // x2gw.KafkaInCase.value
     x2gw_KafkaInCase_kafka2_ApiVersionsRequest        = 18
    ,x2gw_KafkaInCase_kafka2_CreateAclsRequest         = 30
    ,x2gw_KafkaInCase_kafka2_CreateTopicsRequest       = 19
    ,x2gw_KafkaInCase_kafka2_DeleteAclsRequest         = 31
    ,x2gw_KafkaInCase_kafka2_DeleteTopicsRequest       = 20
    ,x2gw_KafkaInCase_kafka2_DescribeAclsRequest       = 29
    ,x2gw_KafkaInCase_kafka2_DescribeClusterRequest    = 60
    ,x2gw_KafkaInCase_kafka2_DescribeConfigsRequest    = 32
    ,x2gw_KafkaInCase_kafka2_DescribeGroupsRequest     = 15
    ,x2gw_KafkaInCase_kafka2_DescribeLogDirsRequest    = 35
    ,x2gw_KafkaInCase_kafka2_FetchRequest              = 1
    ,x2gw_KafkaInCase_kafka2_FindCoordinatorRequest    = 10
    ,x2gw_KafkaInCase_kafka2_HeartbeatRequest          = 12
    ,x2gw_KafkaInCase_kafka2_InitProducerIdRequest     = 22
    ,x2gw_KafkaInCase_kafka2_JoinGroupRequest          = 11
    ,x2gw_KafkaInCase_kafka2_LeaveGroupRequest         = 13
    ,x2gw_KafkaInCase_kafka2_ListGroupsRequest         = 16
    ,x2gw_KafkaInCase_kafka2_ListOffsetsRequest        = 2
    ,x2gw_KafkaInCase_kafka2_MetadataRequest           = 3
    ,x2gw_KafkaInCase_kafka2_OffsetCommitRequest       = 8
    ,x2gw_KafkaInCase_kafka2_OffsetFetchRequest        = 9
    ,x2gw_KafkaInCase_kafka2_ProduceRequest            = 0
    ,x2gw_KafkaInCase_kafka2_SaslAuthenticateRequest   = 36
    ,x2gw_KafkaInCase_kafka2_SaslHandshakeRequest      = 17
    ,x2gw_KafkaInCase_kafka2_SyncGroupRequest          = 14
};

enum { x2gw_KafkaInCaseEnum_N = 25 };


// --- x2gw.KafkaInCase
#pragma pack(push,1)
struct KafkaInCase { // x2gw.KafkaInCase: Enum for dispatch x2gw.KafkaIn
    u32   value;   //   0
    // func:x2gw.KafkaInCase.value.Cast
    inline               operator x2gw_KafkaInCaseEnum() const __attribute__((nothrow));
    // func:x2gw.KafkaInCase..Ctor
    inline               KafkaInCase() __attribute__((nothrow));
    // func:x2gw.KafkaInCase..FieldwiseCtor
    explicit inline               KafkaInCase(u32 in_value) __attribute__((nothrow));
    // func:x2gw.KafkaInCase..EnumCtor
    inline               KafkaInCase(x2gw_KafkaInCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)


// --- x2gw.RespInCase
#pragma pack(push,1)
struct RespInCase { // x2gw.RespInCase: Enum for dispatch x2gw.RespIn
    u32   value;   //   0
    // func:x2gw.RespInCase.value.Cast
    inline               operator u32() const __attribute__((nothrow));
    // func:x2gw.RespInCase..Ctor
    inline               RespInCase() __attribute__((nothrow));
    // func:x2gw.RespInCase..FieldwiseCtor
    explicit inline               RespInCase(u32 in_value) __attribute__((nothrow));
};
#pragma pack(pop)


// --- x2gw_UserInCaseEnum

enum x2gw_UserInCaseEnum {                          // x2gw.UserInCase.value
     x2gw_UserInCase_ams_InputLineMsg        = 22
    ,x2gw_UserInCase_x2_AuthMsg              = 658
    ,x2gw_UserInCase_x2_CmdMsg               = 644
    ,x2gw_UserInCase_x2_CreditMetricMsg      = 655
    ,x2gw_UserInCase_x2_FetchMsg             = 617
    ,x2gw_UserInCase_x2_OpenStreamMsg        = 636
    ,x2gw_UserInCase_x2_PubMsg               = 618
    ,x2gw_UserInCase_x2_SubscribeMetricMsg   = 647
};

enum { x2gw_UserInCaseEnum_N = 8 };


// --- x2gw.UserInCase
#pragma pack(push,1)
struct UserInCase { // x2gw.UserInCase: Enum for dispatch x2gw.UserIn
    u32   value;   //   0
    // func:x2gw.UserInCase.value.Cast
    inline               operator x2gw_UserInCaseEnum() const __attribute__((nothrow));
    // func:x2gw.UserInCase..Ctor
    inline               UserInCase() __attribute__((nothrow));
    // func:x2gw.UserInCase..FieldwiseCtor
    explicit inline               UserInCase(u32 in_value) __attribute__((nothrow));
    // func:x2gw.UserInCase..EnumCtor
    inline               UserInCase(x2gw_UserInCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)


// --- x2gw.trace
#pragma pack(push,1)
struct trace { // x2gw.trace
    u64   conn_out_n_eagain;       //   0
    u64   conn_out_n_write_byte;   //   0
    u64   conn_out_n_write_msg;    //   0
    u64   conn_in_n_read_byte;     //   0
    u64   conn_in_n_read_msg;      //   0
    // func:x2gw.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)


// --- x2gw_TableIdEnum

enum x2gw_TableIdEnum {                // x2gw.TableId.value
     x2gw_TableId_x2db_Gwport    = 0   // x2db.Gwport -> x2gw.FGwport
    ,x2gw_TableId_x2db_gwport    = 0   // x2db.gwport -> x2gw.FGwport
    ,x2gw_TableId_x2db_Gwproto   = 1   // x2db.Gwproto -> x2gw.FGwproto
    ,x2gw_TableId_x2db_gwproto   = 1   // x2db.gwproto -> x2gw.FGwproto
    ,x2gw_TableId_x2db_Proc      = 2   // x2db.Proc -> x2gw.FProc
    ,x2gw_TableId_x2db_proc      = 2   // x2db.proc -> x2gw.FProc
};

enum { x2gw_TableIdEnum_N = 6 };


// --- x2gw.TableId
struct TableId { // x2gw.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    // func:x2gw.TableId.value.Cast
    inline               operator x2gw_TableIdEnum() const __attribute__((nothrow));
    // func:x2gw.TableId..Ctor
    inline               TableId() __attribute__((nothrow));
    // func:x2gw.TableId..FieldwiseCtor
    explicit inline               TableId(i32 in_value) __attribute__((nothrow));
    // func:x2gw.TableId..EnumCtor
    inline               TableId(x2gw_TableIdEnum arg) __attribute__((nothrow));
};


// --- x2gw_FieldIdEnum

enum x2gw_FieldIdEnum {                        // x2gw.FieldId.value
     x2gw_FieldId_base                    = 0
    ,x2gw_FieldId_intf                    = 1
    ,x2gw_FieldId_device                  = 2
    ,x2gw_FieldId_model                   = 3
    ,x2gw_FieldId_speed                   = 4
    ,x2gw_FieldId_state                   = 5
    ,x2gw_FieldId_resource_type           = 6
    ,x2gw_FieldId_resource_name           = 7
    ,x2gw_FieldId_resource_pattern_type   = 8
    ,x2gw_FieldId_value                   = 9
};

enum { x2gw_FieldIdEnum_N = 10 };


// --- x2gw.FieldId
#pragma pack(push,1)
struct FieldId { // x2gw.FieldId: Field read helper
    i32   value;   //   -1
    // func:x2gw.FieldId.value.Cast
    inline               operator x2gw_FieldIdEnum() const __attribute__((nothrow));
    // func:x2gw.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:x2gw.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:x2gw.FieldId..EnumCtor
    inline               FieldId(x2gw_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Print back to string
// func:x2gw.FAcl.user.Print
void                 user_Print(x2gw::FAcl& acl, algo::cstring &out) __attribute__((nothrow));
// Print back to string
// func:x2gw.FAcl.stream.Print
void                 stream_Print(x2gw::FAcl& acl, algo::cstring &out) __attribute__((nothrow));
// Print back to string
// func:x2gw.FAcl.key.Print
void                 key_Print(x2gw::FAcl& acl, algo::cstring &out) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FApiendpoint.base.CopyOut
void                 apiendpoint_CopyOut(x2gw::FApiendpoint &row, x2db::Apiendpoint &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FApiendpoint.base.CopyIn
void                 apiendpoint_CopyIn(x2gw::FApiendpoint &row, x2db::Apiendpoint &in) __attribute__((nothrow));
// func:x2gw.FApiendpoint.apiversion.Get
algo::Smallstr50     apiversion_Get(x2gw::FApiendpoint& apiendpoint) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FApiendpoint.httpmethod.Get
algo::Smallstr50     httpmethod_Get(x2gw::FApiendpoint& apiendpoint) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FApiendpoint.apiresource.Get
algo::Smallstr50     apiresource_Get(x2gw::FApiendpoint& apiendpoint) __attribute__((__warn_unused_result__, nothrow));
// Set all fields to initial values.
// func:x2gw.FApiendpoint..Init
inline void          FApiendpoint_Init(x2gw::FApiendpoint& apiendpoint);
// Invoke function by pointer
// func:x2gw.FApiendpoint.step.Call
inline void          step_Call(x2gw::FApiendpoint& apiendpoint, http::Request& arg) __attribute__((nothrow));
// Delete all elements pointed to by the index.
// func:x2gw.FCmdreq.c_proc_output.Cascdel
void                 c_proc_output_Cascdel(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FCmdreq.c_proc_output.EmptyQ
inline bool          c_proc_output_EmptyQ(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FCmdreq.c_proc_output.Find
inline x2gw::FProcOutput* c_proc_output_Find(x2gw::FCmdreq& cmdreq, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:x2gw.FCmdreq.c_proc_output.Getary
inline algo::aryptr<x2gw::FProcOutput*> c_proc_output_Getary(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:x2gw.FCmdreq.c_proc_output.Insert
void                 c_proc_output_Insert(x2gw::FCmdreq& cmdreq, x2gw::FProcOutput& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:x2gw.FCmdreq.c_proc_output.InsertMaybe
bool                 c_proc_output_InsertMaybe(x2gw::FCmdreq& cmdreq, x2gw::FProcOutput& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:x2gw.FCmdreq.c_proc_output.N
inline i32           c_proc_output_N(const x2gw::FCmdreq& cmdreq) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:x2gw.FCmdreq.c_proc_output.Remove
void                 c_proc_output_Remove(x2gw::FCmdreq& cmdreq, x2gw::FProcOutput& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FCmdreq.c_proc_output.RemoveAll
inline void          c_proc_output_RemoveAll(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:x2gw.FCmdreq.c_proc_output.Reserve
void                 c_proc_output_Reserve(x2gw::FCmdreq& cmdreq, u32 n) __attribute__((nothrow));
// func:x2gw.FCmdreq.c_proc_output_curs.Reset
inline void          cmdreq_c_proc_output_curs_Reset(cmdreq_c_proc_output_curs &curs, x2gw::FCmdreq &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FCmdreq.c_proc_output_curs.ValidQ
inline bool          cmdreq_c_proc_output_curs_ValidQ(cmdreq_c_proc_output_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FCmdreq.c_proc_output_curs.Next
inline void          cmdreq_c_proc_output_curs_Next(cmdreq_c_proc_output_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FCmdreq.c_proc_output_curs.Access
inline x2gw::FProcOutput& cmdreq_c_proc_output_curs_Access(cmdreq_c_proc_output_curs &curs) __attribute__((nothrow));
// Return reference without bounds checking
// func:x2gw.FCmdreq.c_proc_output.qFind
inline x2gw::FProcOutput& c_proc_output_qFind(x2gw::FCmdreq& cmdreq, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:x2gw.FCmdreq.c_proc_output.InAryQ
inline bool          cmdreq_c_proc_output_InAryQ(x2gw::FProcOutput& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:x2gw.FCmdreq.c_proc_output.qLast
inline x2gw::FProcOutput& c_proc_output_qLast(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Swap values elem_a and elem_b
// func:x2gw.FCmdreq.c_proc_output.Swap
inline static void   c_proc_output_Swap(x2gw::FProcOutput* &elem_a, x2gw::FProcOutput* &elem_b) __attribute__((nothrow));
// Left circular shift of three-tuple
// func:x2gw.FCmdreq.c_proc_output.Rotleft
inline static void   c_proc_output_Rotleft(x2gw::FProcOutput* &elem_a, x2gw::FProcOutput* &elem_b, x2gw::FProcOutput* &elem_c) __attribute__((nothrow));
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
// func:x2gw.FCmdreq.c_proc_output.Lt
static bool          c_proc_output_Lt(x2gw::FProcOutput &elem_a, x2gw::FProcOutput &elem_b) __attribute__((nothrow));
// Verify whether array is sorted
// func:x2gw.FCmdreq.c_proc_output.SortedQ
bool                 c_proc_output_SortedQ(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Internal insertion sort
// func:x2gw.FCmdreq.c_proc_output.IntInsertionSort
static void          c_proc_output_IntInsertionSort(x2gw::FProcOutput* *elems, int n) __attribute__((nothrow));
// Internal heap sort
// func:x2gw.FCmdreq.c_proc_output.IntHeapSort
static void          c_proc_output_IntHeapSort(x2gw::FProcOutput* *elems, int n) __attribute__((nothrow));
// Quick sort engine
// func:x2gw.FCmdreq.c_proc_output.IntQuickSort
static void          c_proc_output_IntQuickSort(x2gw::FProcOutput* *elems, int n, int depth) __attribute__((nothrow));
// Insertion sort
// func:x2gw.FCmdreq.c_proc_output.InsertionSort
void                 c_proc_output_InsertionSort(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Heap sort
// func:x2gw.FCmdreq.c_proc_output.HeapSort
void                 c_proc_output_HeapSort(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Quick sort
// func:x2gw.FCmdreq.c_proc_output.QuickSort
void                 c_proc_output_QuickSort(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// Send zero-byte write
// func:x2gw.FConn.out.EndWrite
void                 out_EndWrite(x2gw::FConn& conn) __attribute__((nothrow));
// Attach fbuf to Iohook for writing
// Attach file descriptor and begin outflowing buffer reading using edge-triggered epoll.
// Whenever buffer is non-empty and fd is writable, insert conn into cd_conn_outflow.
// User should implement a step function that calls out_Outflow.
// func:x2gw.FConn.out.BeginWrite
void                 out_BeginWrite(x2gw::FConn& conn, algo::Fildes fd, bool nodelete) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:x2gw.FConn.out.Max
inline i32           out_Max(x2gw::FConn& conn) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:x2gw.FConn.out.N
inline i32           out_N(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Transfer bytes from buffer to fd using write()
// Once all bytes are written or when fd buffer is full, buffer is automatically removed from cd_conn_outflow list.
// Edge-triggered epoll will re-insert out into cd_conn_outflow.
// func:x2gw.FConn.out.Outflow
bool                 out_Outflow(x2gw::FConn& conn) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:x2gw.FConn.out.RemoveAll
void                 out_RemoveAll(x2gw::FConn& conn) __attribute__((nothrow));
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
// func:x2gw.FConn.out.Shift
static void          out_Shift(x2gw::FConn& conn) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:x2gw.FConn.out.SkipBytes
void                 out_SkipBytes(x2gw::FConn& conn, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:x2gw.FConn.out.SkipMsg
void                 out_SkipMsg(x2gw::FConn& conn) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:x2gw.FConn.out.WriteAll
bool                 out_WriteAll(x2gw::FConn& conn, u8 *in, i32 in_n) __attribute__((nothrow));
// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by x2gw::FConn.in via FIohook field.
// Whenever the file descriptor becomes readable, insert conn into cd_conn_read.
// func:x2gw.FConn.in.BeginRead
void                 in_BeginRead(x2gw::FConn& conn, algo::Fildes fd) __attribute__((nothrow));
// Set EOF flag
// func:x2gw.FConn.in.EndRead
void                 in_EndRead(x2gw::FConn& conn) __attribute__((nothrow));
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message boundary is determined by a custom ScanMsg function implemented by user
//
// func:x2gw.FConn.in.GetMsg
algo::aryptr<char>   in_GetMsg(x2gw::FConn& conn) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:x2gw.FConn.in.Max
inline i32           in_Max(x2gw::FConn& conn) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:x2gw.FConn.in.N
inline i32           in_N(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
// func:x2gw.FConn.in.Refill
bool                 in_Refill(x2gw::FConn& conn) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:x2gw.FConn.in.RemoveAll
void                 in_RemoveAll(x2gw::FConn& conn) __attribute__((nothrow));
// Internal function to scan for a message
//
// func:x2gw.FConn.in.ScanMsg
// this function is 'extrn' and implemented by user
void                 in_ScanMsg(x2gw::FConn& conn) __attribute__((nothrow));
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
// func:x2gw.FConn.in.Shift
static void          in_Shift(x2gw::FConn& conn) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:x2gw.FConn.in.SkipBytes
void                 in_SkipBytes(x2gw::FConn& conn, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:x2gw.FConn.in.SkipMsg
void                 in_SkipMsg(x2gw::FConn& conn) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:x2gw.FConn.in.WriteAll
bool                 in_WriteAll(x2gw::FConn& conn, u8 *in, i32 in_n) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field p_gwport of x2gw::FConn
// func:x2gw.FConn.p_gwport.Cleanup
// this function is 'extrn' and implemented by user
void                 p_gwport_Cleanup(x2gw::FConn& conn) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field ssl of x2gw::FConn
// func:x2gw.FConn.ssl.Cleanup
// this function is 'extrn' and implemented by user
void                 ssl_Cleanup(x2gw::FConn& conn) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field c_session_conn of x2gw::FConn
// func:x2gw.FConn.c_session_conn.Cleanup
// this function is 'extrn' and implemented by user
void                 c_session_conn_Cleanup(x2gw::FConn& conn) __attribute__((nothrow));
// Delete referred-to items.
// Deleted pointed-to item.
// func:x2gw.FConn.c_session_conn.Cascdel
void                 c_session_conn_Cascdel(x2gw::FConn& conn) __attribute__((nothrow));
// Insert row into pointer index. Return final membership status.
// func:x2gw.FConn.c_session_conn.InsertMaybe
inline bool          c_session_conn_InsertMaybe(x2gw::FConn& conn, x2gw::FSessionConn& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FConn.c_session_conn.Remove
inline void          c_session_conn_Remove(x2gw::FConn& conn, x2gw::FSessionConn& row) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FConn.zd_cmdreq.Cascdel
void                 zd_cmdreq_Cascdel(x2gw::FConn& conn) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FCmdreq..Init
inline void          FCmdreq_Init(x2gw::FCmdreq& cmdreq);
// Return true if index is empty
// func:x2gw.FConn.zd_cmdreq.EmptyQ
inline bool          zd_cmdreq_EmptyQ(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FConn.zd_cmdreq.First
inline x2gw::FCmdreq* zd_cmdreq_First(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FConn.zd_cmdreq.InLlistQ
inline bool          zd_cmdreq_InLlistQ(x2gw::FCmdreq& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FConn.zd_cmdreq.Insert
void                 zd_cmdreq_Insert(x2gw::FConn& conn, x2gw::FCmdreq& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FConn.zd_cmdreq.Last
inline x2gw::FCmdreq* zd_cmdreq_Last(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FConn.zd_cmdreq.N
inline i32           zd_cmdreq_N(const x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FConn.zd_cmdreq.Next
inline x2gw::FCmdreq* zd_cmdreq_Next(x2gw::FCmdreq &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FConn.zd_cmdreq.Prev
inline x2gw::FCmdreq* zd_cmdreq_Prev(x2gw::FCmdreq &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FConn.zd_cmdreq.Remove
void                 zd_cmdreq_Remove(x2gw::FConn& conn, x2gw::FCmdreq& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FConn.zd_cmdreq.RemoveAll
void                 zd_cmdreq_RemoveAll(x2gw::FConn& conn) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FConn.zd_cmdreq.RemoveFirst
x2gw::FCmdreq*       zd_cmdreq_RemoveFirst(x2gw::FConn& conn) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FConn.zd_cmdreq.qLast
inline x2gw::FCmdreq& zd_cmdreq_qLast(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FConn.zd_cmdreq_curs.Reset
inline void          conn_zd_cmdreq_curs_Reset(conn_zd_cmdreq_curs &curs, x2gw::FConn &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FConn.zd_cmdreq_curs.ValidQ
inline bool          conn_zd_cmdreq_curs_ValidQ(conn_zd_cmdreq_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FConn.zd_cmdreq_curs.Next
inline void          conn_zd_cmdreq_curs_Next(conn_zd_cmdreq_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FConn.zd_cmdreq_curs.Access
inline x2gw::FCmdreq& conn_zd_cmdreq_curs_Access(conn_zd_cmdreq_curs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FConn.zd_conn_moentry.Cascdel
void                 zd_conn_moentry_Cascdel(x2gw::FConn& conn) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FMoentry..Init
inline void          FMoentry_Init(x2gw::FMoentry& moentry);
// Return true if index is empty
// func:x2gw.FConn.zd_conn_moentry.EmptyQ
inline bool          zd_conn_moentry_EmptyQ(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FConn.zd_conn_moentry.First
inline x2gw::FMoentry* zd_conn_moentry_First(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FConn.zd_conn_moentry.InLlistQ
inline bool          zd_conn_moentry_InLlistQ(x2gw::FMoentry& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FConn.zd_conn_moentry.Insert
void                 zd_conn_moentry_Insert(x2gw::FConn& conn, x2gw::FMoentry& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FConn.zd_conn_moentry.Last
inline x2gw::FMoentry* zd_conn_moentry_Last(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FConn.zd_conn_moentry.N
inline i32           zd_conn_moentry_N(const x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FConn.zd_conn_moentry.Next
inline x2gw::FMoentry* zd_conn_moentry_Next(x2gw::FMoentry &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FConn.zd_conn_moentry.Prev
inline x2gw::FMoentry* zd_conn_moentry_Prev(x2gw::FMoentry &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FConn.zd_conn_moentry.Remove
void                 zd_conn_moentry_Remove(x2gw::FConn& conn, x2gw::FMoentry& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FConn.zd_conn_moentry.RemoveAll
void                 zd_conn_moentry_RemoveAll(x2gw::FConn& conn) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FConn.zd_conn_moentry.RemoveFirst
x2gw::FMoentry*      zd_conn_moentry_RemoveFirst(x2gw::FConn& conn) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FConn.zd_conn_moentry.qLast
inline x2gw::FMoentry& zd_conn_moentry_qLast(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FConn.zd_conn_moentry_curs.Reset
inline void          conn_zd_conn_moentry_curs_Reset(conn_zd_conn_moentry_curs &curs, x2gw::FConn &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FConn.zd_conn_moentry_curs.ValidQ
inline bool          conn_zd_conn_moentry_curs_ValidQ(conn_zd_conn_moentry_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FConn.zd_conn_moentry_curs.Next
inline void          conn_zd_conn_moentry_curs_Next(conn_zd_conn_moentry_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FConn.zd_conn_moentry_curs.Access
inline x2gw::FMoentry& conn_zd_conn_moentry_curs_Access(conn_zd_conn_moentry_curs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FConn.zd_conn_moentry_pending.Cascdel
void                 zd_conn_moentry_pending_Cascdel(x2gw::FConn& conn) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FConn.zd_conn_moentry_pending.EmptyQ
inline bool          zd_conn_moentry_pending_EmptyQ(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FConn.zd_conn_moentry_pending.First
inline x2gw::FMoentry* zd_conn_moentry_pending_First(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FConn.zd_conn_moentry_pending.InLlistQ
inline bool          zd_conn_moentry_pending_InLlistQ(x2gw::FMoentry& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FConn.zd_conn_moentry_pending.Insert
void                 zd_conn_moentry_pending_Insert(x2gw::FConn& conn, x2gw::FMoentry& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FConn.zd_conn_moentry_pending.Last
inline x2gw::FMoentry* zd_conn_moentry_pending_Last(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FConn.zd_conn_moentry_pending.N
inline i32           zd_conn_moentry_pending_N(const x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FConn.zd_conn_moentry_pending.Next
inline x2gw::FMoentry* zd_conn_moentry_pending_Next(x2gw::FMoentry &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FConn.zd_conn_moentry_pending.Prev
inline x2gw::FMoentry* zd_conn_moentry_pending_Prev(x2gw::FMoentry &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FConn.zd_conn_moentry_pending.Remove
void                 zd_conn_moentry_pending_Remove(x2gw::FConn& conn, x2gw::FMoentry& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FConn.zd_conn_moentry_pending.RemoveAll
void                 zd_conn_moentry_pending_RemoveAll(x2gw::FConn& conn) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FConn.zd_conn_moentry_pending.RemoveFirst
x2gw::FMoentry*      zd_conn_moentry_pending_RemoveFirst(x2gw::FConn& conn) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FConn.zd_conn_moentry_pending.qLast
inline x2gw::FMoentry& zd_conn_moentry_pending_qLast(x2gw::FConn& conn) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FConn.zd_conn_moentry_pending_curs.Reset
inline void          conn_zd_conn_moentry_pending_curs_Reset(conn_zd_conn_moentry_pending_curs &curs, x2gw::FConn &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FConn.zd_conn_moentry_pending_curs.ValidQ
inline bool          conn_zd_conn_moentry_pending_curs_ValidQ(conn_zd_conn_moentry_pending_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FConn.zd_conn_moentry_pending_curs.Next
inline void          conn_zd_conn_moentry_pending_curs_Next(conn_zd_conn_moentry_pending_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FConn.zd_conn_moentry_pending_curs.Access
inline x2gw::FMoentry& conn_zd_conn_moentry_pending_curs_Access(conn_zd_conn_moentry_pending_curs &curs) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FNetproto.base.CopyOut
void                 netproto_CopyOut(x2gw::FNetproto &row, dev::Netproto &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FNetproto.base.CopyIn
void                 netproto_CopyIn(x2gw::FNetproto &row, dev::Netproto &in) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FFraming.base.CopyOut
void                 framing_CopyOut(x2gw::FFraming &row, x2db::Framing &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FFraming.base.CopyIn
void                 framing_CopyIn(x2gw::FFraming &row, x2db::Framing &in) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FFraming..Init
inline void          FFraming_Init(x2gw::FFraming& framing);
// Invoke function by pointer
// func:x2gw.FFraming.read.Call
inline void          read_Call(x2gw::FFraming& framing) __attribute__((nothrow));
// Invoke function by pointer
// func:x2gw.FFraming.scan.Call
inline void          scan_Call(x2gw::FFraming& framing, x2gw::FConn& arg) __attribute__((nothrow));
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     x2gw.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:x2gw.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// func:x2gw...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:x2gw...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// Main loop.
// func:x2gw.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:x2gw.FDb._db.Step
void                 Step();
// Main function
// func:x2gw.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Load statically available data into tables, register tables and database.
// func:x2gw.FDb._db.InitReflection
static void          InitReflection();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:x2gw.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:x2gw.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:x2gw.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:x2gw.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load specified ssimfile.
// func:x2gw.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:x2gw.FDb._db.Steps
void                 Steps();
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.stream.Alloc
x2gw::FStream&       stream_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.stream.AllocMaybe
x2gw::FStream*       stream_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.stream.Delete
void                 stream_Delete(x2gw::FStream &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FStream..Init
inline void          FStream_Init(x2gw::FStream& stream);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.stream.AllocMem
void*                stream_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.stream.FreeMem
void                 stream_FreeMem(x2gw::FStream &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.stream.Reserve
u64                  stream_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.stream.ReserveMem
u64                  stream_ReserveMem(u64 size) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.fetch.Alloc
x2gw::FFetch&        fetch_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.fetch.AllocMaybe
x2gw::FFetch*        fetch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.fetch.InsertMaybe
x2gw::FFetch*        fetch_InsertMaybe(const x2gw::Fetch &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.fetch.Delete
void                 fetch_Delete(x2gw::FFetch &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FFetch..Init
void                 FFetch_Init(x2gw::FFetch& fetch);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.fetch.AllocMem
void*                fetch_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.fetch.FreeMem
void                 fetch_FreeMem(x2gw::FFetch &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.fetch.Reserve
u64                  fetch_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.fetch.ReserveMem
u64                  fetch_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_stream.EmptyQ
inline bool          ind_stream_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_stream.Find
x2gw::FStream*       ind_stream_Find(x2::StreamId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_stream.FindX
x2gw::FStream&       ind_stream_FindX(x2::StreamId key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_stream.GetOrCreate
x2gw::FStream&       ind_stream_GetOrCreate(x2::StreamId key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_stream.N
inline i32           ind_stream_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_stream.InsertMaybe
bool                 ind_stream_InsertMaybe(x2gw::FStream& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_stream.Remove
void                 ind_stream_Remove(x2gw::FStream& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_stream.Reserve
void                 ind_stream_Reserve(int n) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_stream_name.EmptyQ
inline bool          ind_stream_name_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_stream_name.Find
x2gw::FStream*       ind_stream_name_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_stream_name.FindX
x2gw::FStream&       ind_stream_name_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_stream_name.N
inline i32           ind_stream_name_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_stream_name.InsertMaybe
bool                 ind_stream_name_InsertMaybe(x2gw::FStream& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_stream_name.Remove
void                 ind_stream_name_Remove(x2gw::FStream& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_stream_name.Reserve
void                 ind_stream_name_Reserve(int n) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_fetch.EmptyQ
inline bool          zd_fetch_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_fetch.First
inline x2gw::FFetch* zd_fetch_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_fetch.InLlistQ
inline bool          zd_fetch_InLlistQ(x2gw::FFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_fetch.Insert
void                 zd_fetch_Insert(x2gw::FFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_fetch.Last
inline x2gw::FFetch* zd_fetch_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_fetch.N
inline i32           zd_fetch_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_fetch.Next
inline x2gw::FFetch* zd_fetch_Next(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_fetch.Prev
inline x2gw::FFetch* zd_fetch_Prev(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_fetch.Remove
void                 zd_fetch_Remove(x2gw::FFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_fetch.RemoveAll
void                 zd_fetch_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_fetch.RemoveFirst
x2gw::FFetch*        zd_fetch_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_fetch.qLast
inline x2gw::FFetch& zd_fetch_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_fetch_curs.Reset
inline void          _db_zd_fetch_curs_Reset(_db_zd_fetch_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_fetch_curs.ValidQ
inline bool          _db_zd_fetch_curs_ValidQ(_db_zd_fetch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_fetch_curs.Next
inline void          _db_zd_fetch_curs_Next(_db_zd_fetch_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_fetch_curs.Access
inline x2gw::FFetch& _db_zd_fetch_curs_Access(_db_zd_fetch_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.session.Alloc
x2gw::FSession&      session_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.session.AllocMaybe
x2gw::FSession*      session_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.session.InsertMaybe
x2gw::FSession*      session_InsertMaybe(const x2gw::Session &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.session.Delete
void                 session_Delete(x2gw::FSession &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FSession..Init
void                 FSession_Init(x2gw::FSession& session);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.session.AllocMem
void*                session_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.session.FreeMem
void                 session_FreeMem(x2gw::FSession &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.session.Reserve
u64                  session_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.session.ReserveMem
u64                  session_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_session.EmptyQ
inline bool          zd_session_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_session.First
inline x2gw::FSession* zd_session_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_session.InLlistQ
inline bool          zd_session_InLlistQ(x2gw::FSession& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_session.Insert
void                 zd_session_Insert(x2gw::FSession& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_session.Last
inline x2gw::FSession* zd_session_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_session.N
inline i32           zd_session_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_session.Next
inline x2gw::FSession* zd_session_Next(x2gw::FSession &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_session.Prev
inline x2gw::FSession* zd_session_Prev(x2gw::FSession &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_session.Remove
void                 zd_session_Remove(x2gw::FSession& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_session.RemoveAll
void                 zd_session_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_session.RemoveFirst
x2gw::FSession*      zd_session_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_session.qLast
inline x2gw::FSession& zd_session_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_session_curs.Reset
inline void          _db_zd_session_curs_Reset(_db_zd_session_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_session_curs.ValidQ
inline bool          _db_zd_session_curs_ValidQ(_db_zd_session_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_session_curs.Next
inline void          _db_zd_session_curs_Next(_db_zd_session_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_session_curs.Access
inline x2gw::FSession& _db_zd_session_curs_Access(_db_zd_session_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.producer.Alloc
x2gw::FProducer&     producer_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.producer.AllocMaybe
x2gw::FProducer*     producer_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.producer.Delete
void                 producer_Delete(x2gw::FProducer &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FProducer..Init
void                 FProducer_Init(x2gw::FProducer& producer);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.producer.AllocMem
void*                producer_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.producer.FreeMem
void                 producer_FreeMem(x2gw::FProducer &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.producer.Reserve
u64                  producer_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.producer.ReserveMem
u64                  producer_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_producer.EmptyQ
inline bool          zd_producer_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_producer.First
inline x2gw::FProducer* zd_producer_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_producer.InLlistQ
inline bool          zd_producer_InLlistQ(x2gw::FProducer& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_producer.Insert
void                 zd_producer_Insert(x2gw::FProducer& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_producer.Last
inline x2gw::FProducer* zd_producer_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_producer.N
inline i32           zd_producer_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_producer.Next
inline x2gw::FProducer* zd_producer_Next(x2gw::FProducer &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_producer.Prev
inline x2gw::FProducer* zd_producer_Prev(x2gw::FProducer &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_producer.Remove
void                 zd_producer_Remove(x2gw::FProducer& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_producer.RemoveAll
void                 zd_producer_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_producer.RemoveFirst
x2gw::FProducer*     zd_producer_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_producer.qLast
inline x2gw::FProducer& zd_producer_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_producer_curs.Reset
inline void          _db_zd_producer_curs_Reset(_db_zd_producer_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_producer_curs.ValidQ
inline bool          _db_zd_producer_curs_ValidQ(_db_zd_producer_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_producer_curs.Next
inline void          _db_zd_producer_curs_Next(_db_zd_producer_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_producer_curs.Access
inline x2gw::FProducer& _db_zd_producer_curs_Access(_db_zd_producer_curs &curs) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_producer.EmptyQ
inline bool          ind_producer_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_producer.Find
x2gw::FProducer*     ind_producer_Find(x2::RequestId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_producer.FindX
x2gw::FProducer&     ind_producer_FindX(x2::RequestId key);
// Return number of items in the hash
// func:x2gw.FDb.ind_producer.N
inline i32           ind_producer_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_producer.InsertMaybe
bool                 ind_producer_InsertMaybe(x2gw::FProducer& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_producer.Remove
void                 ind_producer_Remove(x2gw::FProducer& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_producer.Reserve
void                 ind_producer_Reserve(int n) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_stream.EmptyQ
inline bool          zd_stream_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_stream.First
inline x2gw::FStream* zd_stream_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_stream.InLlistQ
inline bool          zd_stream_InLlistQ(x2gw::FStream& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_stream.Insert
void                 zd_stream_Insert(x2gw::FStream& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_stream.Last
inline x2gw::FStream* zd_stream_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_stream.N
inline i32           zd_stream_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_stream.Next
inline x2gw::FStream* zd_stream_Next(x2gw::FStream &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_stream.Prev
inline x2gw::FStream* zd_stream_Prev(x2gw::FStream &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_stream.Remove
void                 zd_stream_Remove(x2gw::FStream& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_stream.RemoveAll
void                 zd_stream_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_stream.RemoveFirst
x2gw::FStream*       zd_stream_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_stream.qLast
inline x2gw::FStream& zd_stream_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_stream_curs.Reset
inline void          _db_zd_stream_curs_Reset(_db_zd_stream_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_stream_curs.ValidQ
inline bool          _db_zd_stream_curs_ValidQ(_db_zd_stream_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_stream_curs.Next
inline void          _db_zd_stream_curs_Next(_db_zd_stream_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_stream_curs.Access
inline x2gw::FStream& _db_zd_stream_curs_Access(_db_zd_stream_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.packet.Alloc
x2gw::FPacket&       packet_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.packet.AllocMaybe
x2gw::FPacket*       packet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.packet.Delete
void                 packet_Delete(x2gw::FPacket &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FPacket..Init
inline void          FPacket_Init(x2gw::FPacket& packet);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.packet.AllocMem
void*                packet_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.packet.FreeMem
void                 packet_FreeMem(x2gw::FPacket &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.packet.Reserve
u64                  packet_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.packet.ReserveMem
u64                  packet_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_session_clientid.EmptyQ
inline bool          ind_session_clientid_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_session_clientid.Find
x2gw::FSession*      ind_session_clientid_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_session_clientid.FindX
x2gw::FSession&      ind_session_clientid_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_session_clientid.GetOrCreate
x2gw::FSession&      ind_session_clientid_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_session_clientid.N
inline i32           ind_session_clientid_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_session_clientid.InsertMaybe
bool                 ind_session_clientid_InsertMaybe(x2gw::FSession& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_session_clientid.Remove
void                 ind_session_clientid_Remove(x2gw::FSession& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_session_clientid.Reserve
void                 ind_session_clientid_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.netproto.Alloc
x2gw::FNetproto&     netproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.netproto.AllocMaybe
x2gw::FNetproto*     netproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.netproto.InsertMaybe
x2gw::FNetproto*     netproto_InsertMaybe(const dev::Netproto &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.netproto.AllocMem
inline void*         netproto_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.netproto.EmptyQ
inline bool          netproto_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.netproto.Find
inline x2gw::FNetproto* netproto_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:x2gw.FDb.netproto.Getary
inline algo::aryptr<x2gw::FNetproto> netproto_Getary() __attribute__((nothrow));
// Return constant 14 -- max. number of items in the pool
// func:x2gw.FDb.netproto.Max
inline i32           netproto_Max() __attribute__((nothrow));
// Return number of items in the array
// func:x2gw.FDb.netproto.N
inline i32           netproto_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:x2gw.FDb.netproto.RemoveAll
void                 netproto_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.netproto.RemoveLast
void                 netproto_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:x2gw.FDb.netproto.qFind
inline x2gw::FNetproto& netproto_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:x2gw.FDb.netproto.rowid_Get
inline u64           netproto_rowid_Get(x2gw::FNetproto &row) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.netproto_curs.Reset
inline void          _db_netproto_curs_Reset(_db_netproto_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.netproto_curs.ValidQ
inline bool          _db_netproto_curs_ValidQ(_db_netproto_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.netproto_curs.Next
inline void          _db_netproto_curs_Next(_db_netproto_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.netproto_curs.Access
inline x2gw::FNetproto& _db_netproto_curs_Access(_db_netproto_curs &curs) __attribute__((nothrow));
// func:x2gw.FDb.netproto.LoadStatic
static void          netproto_LoadStatic() __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FNetproto..Init
inline void          FNetproto_Init(x2gw::FNetproto& netproto);
// Return true if hash is empty
// func:x2gw.FDb.ind_netproto.EmptyQ
inline bool          ind_netproto_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_netproto.Find
x2gw::FNetproto*     ind_netproto_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_netproto.FindX
x2gw::FNetproto&     ind_netproto_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_netproto.GetOrCreate
x2gw::FNetproto&     ind_netproto_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_netproto.N
inline i32           ind_netproto_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_netproto.InsertMaybe
bool                 ind_netproto_InsertMaybe(x2gw::FNetproto& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_netproto.Remove
void                 ind_netproto_Remove(x2gw::FNetproto& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_netproto.Reserve
void                 ind_netproto_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.framing.Alloc
x2gw::FFraming&      framing_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.framing.AllocMaybe
x2gw::FFraming*      framing_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.framing.InsertMaybe
x2gw::FFraming*      framing_InsertMaybe(const x2db::Framing &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.framing.AllocMem
inline void*         framing_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.framing.EmptyQ
inline bool          framing_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.framing.Find
inline x2gw::FFraming* framing_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:x2gw.FDb.framing.Getary
inline algo::aryptr<x2gw::FFraming> framing_Getary() __attribute__((nothrow));
// Return constant 7 -- max. number of items in the pool
// func:x2gw.FDb.framing.Max
inline i32           framing_Max() __attribute__((nothrow));
// Return number of items in the array
// func:x2gw.FDb.framing.N
inline i32           framing_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:x2gw.FDb.framing.RemoveAll
void                 framing_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.framing.RemoveLast
void                 framing_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:x2gw.FDb.framing.qFind
inline x2gw::FFraming& framing_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:x2gw.FDb.framing.rowid_Get
inline u64           framing_rowid_Get(x2gw::FFraming &row) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.framing_curs.Reset
inline void          _db_framing_curs_Reset(_db_framing_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.framing_curs.ValidQ
inline bool          _db_framing_curs_ValidQ(_db_framing_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.framing_curs.Next
inline void          _db_framing_curs_Next(_db_framing_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.framing_curs.Access
inline x2gw::FFraming& _db_framing_curs_Access(_db_framing_curs &curs) __attribute__((nothrow));
// func:x2gw.FDb.framing.LoadStatic
static void          framing_LoadStatic() __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_framing.EmptyQ
inline bool          ind_framing_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_framing.Find
x2gw::FFraming*      ind_framing_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_framing.FindX
x2gw::FFraming&      ind_framing_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_framing.GetOrCreate
x2gw::FFraming&      ind_framing_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_framing.N
inline i32           ind_framing_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_framing.InsertMaybe
bool                 ind_framing_InsertMaybe(x2gw::FFraming& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_framing.Remove
void                 ind_framing_Remove(x2gw::FFraming& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_framing.Reserve
void                 ind_framing_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.gwproto.Alloc
x2gw::FGwproto&      gwproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.gwproto.AllocMaybe
x2gw::FGwproto*      gwproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.gwproto.InsertMaybe
x2gw::FGwproto*      gwproto_InsertMaybe(const x2db::Gwproto &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.gwproto.AllocMem
void*                gwproto_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.gwproto.EmptyQ
inline bool          gwproto_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.gwproto.Find
inline x2gw::FGwproto* gwproto_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.gwproto.Last
inline x2gw::FGwproto* gwproto_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.gwproto.N
inline i32           gwproto_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.gwproto.RemoveAll
void                 gwproto_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.gwproto.RemoveLast
void                 gwproto_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.gwproto.qFind
inline x2gw::FGwproto& gwproto_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.gwproto_curs.Reset
inline void          _db_gwproto_curs_Reset(_db_gwproto_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.gwproto_curs.ValidQ
inline bool          _db_gwproto_curs_ValidQ(_db_gwproto_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.gwproto_curs.Next
inline void          _db_gwproto_curs_Next(_db_gwproto_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.gwproto_curs.Access
inline x2gw::FGwproto& _db_gwproto_curs_Access(_db_gwproto_curs &curs) __attribute__((nothrow));
// func:x2gw.FDb.gwproto.InputMaybe
static bool          gwproto_InputMaybe(x2db::Gwproto &elem) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.conn.Alloc
x2gw::FConn&         conn_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.conn.AllocMaybe
x2gw::FConn*         conn_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.conn.Delete
void                 conn_Delete(x2gw::FConn &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FConn..Init
void                 FConn_Init(x2gw::FConn& conn);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.conn.AllocMem
void*                conn_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.conn.FreeMem
void                 conn_FreeMem(x2gw::FConn &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.conn.Reserve
u64                  conn_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.conn.ReserveMem
u64                  conn_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_conn.EmptyQ
inline bool          zd_conn_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_conn.First
inline x2gw::FConn*  zd_conn_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_conn.InLlistQ
inline bool          zd_conn_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_conn.Insert
void                 zd_conn_Insert(x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_conn.Last
inline x2gw::FConn*  zd_conn_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_conn.N
inline i32           zd_conn_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_conn.Next
inline x2gw::FConn*  zd_conn_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_conn.Prev
inline x2gw::FConn*  zd_conn_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_conn.Remove
void                 zd_conn_Remove(x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_conn.RemoveAll
void                 zd_conn_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_conn.RemoveFirst
x2gw::FConn*         zd_conn_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_conn.qLast
inline x2gw::FConn&  zd_conn_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_conn_curs.Reset
inline void          _db_zd_conn_curs_Reset(_db_zd_conn_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_conn_curs.ValidQ
inline bool          _db_zd_conn_curs_ValidQ(_db_zd_conn_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_conn_curs.Next
inline void          _db_zd_conn_curs_Next(_db_zd_conn_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_conn_curs.Access
inline x2gw::FConn&  _db_zd_conn_curs_Access(_db_zd_conn_curs &curs) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_conn_del.EmptyQ
inline bool          zd_conn_del_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_conn_del.First
inline x2gw::FConn*  zd_conn_del_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_conn_del.InLlistQ
inline bool          zd_conn_del_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_conn_del.Insert
void                 zd_conn_del_Insert(x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_conn_del.Last
inline x2gw::FConn*  zd_conn_del_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_conn_del.N
inline i32           zd_conn_del_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_conn_del.Next
inline x2gw::FConn*  zd_conn_del_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_conn_del.Prev
inline x2gw::FConn*  zd_conn_del_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_conn_del.Remove
void                 zd_conn_del_Remove(x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_conn_del.RemoveAll
void                 zd_conn_del_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:x2gw.FDb.zd_conn_del.RemoveFirst
x2gw::FConn*         zd_conn_del_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_conn_del.qLast
inline x2gw::FConn&  zd_conn_del_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_conn_del_curs.Reset
inline void          _db_zd_conn_del_curs_Reset(_db_zd_conn_del_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_conn_del_curs.ValidQ
inline bool          _db_zd_conn_del_curs_ValidQ(_db_zd_conn_del_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_conn_del_curs.Next
inline void          _db_zd_conn_del_curs_Next(_db_zd_conn_del_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_conn_del_curs.Access
inline x2gw::FConn&  _db_zd_conn_del_curs_Access(_db_zd_conn_del_curs &curs) __attribute__((nothrow));
// First element of index changed.
// func:x2gw.FDb.zd_conn_del.FirstChanged
static void          zd_conn_del_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:x2gw.FDb.zd_conn_del.UpdateCycles
inline static void   zd_conn_del_UpdateCycles() __attribute__((nothrow));
// func:x2gw.FDb.zd_conn_del.Step
// this function is 'extrn' and implemented by user
void                 zd_conn_del_Step() __attribute__((nothrow));
// func:x2gw.FDb.zd_conn_del.Call
inline static void   zd_conn_del_Call() __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FGwport..Init
void                 FGwport_Init(x2gw::FGwport& gwport);
// Return true if index is empty
// func:x2gw.FDb.cd_accept.EmptyQ
inline bool          cd_accept_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.cd_accept.First
inline x2gw::FGwport* cd_accept_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.cd_accept.InLlistQ
inline bool          cd_accept_InLlistQ(x2gw::FGwport& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.cd_accept.Insert
void                 cd_accept_Insert(x2gw::FGwport& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.cd_accept.Last
inline x2gw::FGwport* cd_accept_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.cd_accept.N
inline i32           cd_accept_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.cd_accept.Next
inline x2gw::FGwport* cd_accept_Next(x2gw::FGwport &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.cd_accept.Prev
inline x2gw::FGwport* cd_accept_Prev(x2gw::FGwport &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.cd_accept.Remove
void                 cd_accept_Remove(x2gw::FGwport& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.cd_accept.RemoveAll
void                 cd_accept_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:x2gw.FDb.cd_accept.RemoveFirst
x2gw::FGwport*       cd_accept_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:x2gw.FDb.cd_accept.RotateFirst
x2gw::FGwport*       cd_accept_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.cd_accept.qLast
inline x2gw::FGwport& cd_accept_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_accept_curs.Reset
inline void          _db_cd_accept_curs_Reset(_db_cd_accept_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_accept_curs.ValidQ
inline bool          _db_cd_accept_curs_ValidQ(_db_cd_accept_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.cd_accept_curs.Next
inline void          _db_cd_accept_curs_Next(_db_cd_accept_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.cd_accept_curs.Access
inline x2gw::FGwport& _db_cd_accept_curs_Access(_db_cd_accept_curs &curs) __attribute__((nothrow));
// First element of index changed.
// func:x2gw.FDb.cd_accept.FirstChanged
static void          cd_accept_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:x2gw.FDb.cd_accept.UpdateCycles
inline static void   cd_accept_UpdateCycles() __attribute__((nothrow));
// func:x2gw.FDb.cd_accept.Step
// this function is 'extrn' and implemented by user
void                 cd_accept_Step() __attribute__((nothrow));
// func:x2gw.FDb.cd_accept.Call
inline static void   cd_accept_Call() __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.cd_conn_read.EmptyQ
inline bool          cd_conn_read_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.cd_conn_read.First
inline x2gw::FConn*  cd_conn_read_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.cd_conn_read.InLlistQ
inline bool          cd_conn_read_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.cd_conn_read.Insert
void                 cd_conn_read_Insert(x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.cd_conn_read.Last
inline x2gw::FConn*  cd_conn_read_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.cd_conn_read.N
inline i32           cd_conn_read_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.cd_conn_read.Next
inline x2gw::FConn*  cd_conn_read_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.cd_conn_read.Prev
inline x2gw::FConn*  cd_conn_read_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.cd_conn_read.Remove
void                 cd_conn_read_Remove(x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.cd_conn_read.RemoveAll
void                 cd_conn_read_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:x2gw.FDb.cd_conn_read.RemoveFirst
x2gw::FConn*         cd_conn_read_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:x2gw.FDb.cd_conn_read.RotateFirst
x2gw::FConn*         cd_conn_read_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.cd_conn_read.qLast
inline x2gw::FConn&  cd_conn_read_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_conn_read_curs.Reset
inline void          _db_cd_conn_read_curs_Reset(_db_cd_conn_read_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_conn_read_curs.ValidQ
inline bool          _db_cd_conn_read_curs_ValidQ(_db_cd_conn_read_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.cd_conn_read_curs.Next
inline void          _db_cd_conn_read_curs_Next(_db_cd_conn_read_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.cd_conn_read_curs.Access
inline x2gw::FConn&  _db_cd_conn_read_curs_Access(_db_cd_conn_read_curs &curs) __attribute__((nothrow));
// First element of index changed.
// func:x2gw.FDb.cd_conn_read.FirstChanged
static void          cd_conn_read_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:x2gw.FDb.cd_conn_read.UpdateCycles
inline static void   cd_conn_read_UpdateCycles() __attribute__((nothrow));
// func:x2gw.FDb.cd_conn_read.Step
// this function is 'extrn' and implemented by user
void                 cd_conn_read_Step() __attribute__((nothrow));
// func:x2gw.FDb.cd_conn_read.Call
inline static void   cd_conn_read_Call() __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.cd_conn_eof.EmptyQ
inline bool          cd_conn_eof_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.cd_conn_eof.First
inline x2gw::FConn*  cd_conn_eof_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.cd_conn_eof.InLlistQ
inline bool          cd_conn_eof_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.cd_conn_eof.Insert
void                 cd_conn_eof_Insert(x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.cd_conn_eof.Last
inline x2gw::FConn*  cd_conn_eof_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.cd_conn_eof.N
inline i32           cd_conn_eof_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.cd_conn_eof.Next
inline x2gw::FConn*  cd_conn_eof_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.cd_conn_eof.Prev
inline x2gw::FConn*  cd_conn_eof_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.cd_conn_eof.Remove
void                 cd_conn_eof_Remove(x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.cd_conn_eof.RemoveAll
void                 cd_conn_eof_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:x2gw.FDb.cd_conn_eof.RemoveFirst
x2gw::FConn*         cd_conn_eof_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:x2gw.FDb.cd_conn_eof.RotateFirst
x2gw::FConn*         cd_conn_eof_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.cd_conn_eof.qLast
inline x2gw::FConn&  cd_conn_eof_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_conn_eof_curs.Reset
inline void          _db_cd_conn_eof_curs_Reset(_db_cd_conn_eof_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_conn_eof_curs.ValidQ
inline bool          _db_cd_conn_eof_curs_ValidQ(_db_cd_conn_eof_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.cd_conn_eof_curs.Next
inline void          _db_cd_conn_eof_curs_Next(_db_cd_conn_eof_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.cd_conn_eof_curs.Access
inline x2gw::FConn&  _db_cd_conn_eof_curs_Access(_db_cd_conn_eof_curs &curs) __attribute__((nothrow));
// First element of index changed.
// func:x2gw.FDb.cd_conn_eof.FirstChanged
static void          cd_conn_eof_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:x2gw.FDb.cd_conn_eof.UpdateCycles
inline static void   cd_conn_eof_UpdateCycles() __attribute__((nothrow));
// func:x2gw.FDb.cd_conn_eof.Step
// this function is 'extrn' and implemented by user
void                 cd_conn_eof_Step() __attribute__((nothrow));
// func:x2gw.FDb.cd_conn_eof.Call
inline static void   cd_conn_eof_Call() __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.cd_conn_outflow.EmptyQ
inline bool          cd_conn_outflow_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.cd_conn_outflow.First
inline x2gw::FConn*  cd_conn_outflow_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.cd_conn_outflow.InLlistQ
inline bool          cd_conn_outflow_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.cd_conn_outflow.Insert
void                 cd_conn_outflow_Insert(x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.cd_conn_outflow.Last
inline x2gw::FConn*  cd_conn_outflow_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.cd_conn_outflow.N
inline i32           cd_conn_outflow_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.cd_conn_outflow.Next
inline x2gw::FConn*  cd_conn_outflow_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.cd_conn_outflow.Prev
inline x2gw::FConn*  cd_conn_outflow_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.cd_conn_outflow.Remove
void                 cd_conn_outflow_Remove(x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.cd_conn_outflow.RemoveAll
void                 cd_conn_outflow_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:x2gw.FDb.cd_conn_outflow.RemoveFirst
x2gw::FConn*         cd_conn_outflow_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:x2gw.FDb.cd_conn_outflow.RotateFirst
x2gw::FConn*         cd_conn_outflow_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.cd_conn_outflow.qLast
inline x2gw::FConn&  cd_conn_outflow_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_conn_outflow_curs.Reset
inline void          _db_cd_conn_outflow_curs_Reset(_db_cd_conn_outflow_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.cd_conn_outflow_curs.ValidQ
inline bool          _db_cd_conn_outflow_curs_ValidQ(_db_cd_conn_outflow_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.cd_conn_outflow_curs.Next
inline void          _db_cd_conn_outflow_curs_Next(_db_cd_conn_outflow_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.cd_conn_outflow_curs.Access
inline x2gw::FConn&  _db_cd_conn_outflow_curs_Access(_db_cd_conn_outflow_curs &curs) __attribute__((nothrow));
// First element of index changed.
// func:x2gw.FDb.cd_conn_outflow.FirstChanged
static void          cd_conn_outflow_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:x2gw.FDb.cd_conn_outflow.UpdateCycles
inline static void   cd_conn_outflow_UpdateCycles() __attribute__((nothrow));
// func:x2gw.FDb.cd_conn_outflow.Step
// this function is 'extrn' and implemented by user
void                 cd_conn_outflow_Step() __attribute__((nothrow));
// func:x2gw.FDb.cd_conn_outflow.Call
inline static void   cd_conn_outflow_Call() __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.session_conn.Alloc
x2gw::FSessionConn&  session_conn_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.session_conn.AllocMaybe
x2gw::FSessionConn*  session_conn_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.session_conn.Delete
void                 session_conn_Delete(x2gw::FSessionConn &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FSessionConn..Init
inline void          FSessionConn_Init(x2gw::FSessionConn& session_conn);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.session_conn.AllocMem
void*                session_conn_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.session_conn.FreeMem
void                 session_conn_FreeMem(x2gw::FSessionConn &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.session_conn.Reserve
u64                  session_conn_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.session_conn.ReserveMem
u64                  session_conn_ReserveMem(u64 size) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.open_stream.Alloc
x2gw::FOpenStream&   open_stream_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.open_stream.AllocMaybe
x2gw::FOpenStream*   open_stream_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.open_stream.Delete
void                 open_stream_Delete(x2gw::FOpenStream &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FOpenStream..Init
inline void          FOpenStream_Init(x2gw::FOpenStream& open_stream);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.open_stream.AllocMem
void*                open_stream_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.open_stream.FreeMem
void                 open_stream_FreeMem(x2gw::FOpenStream &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.open_stream.Reserve
u64                  open_stream_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.open_stream.ReserveMem
u64                  open_stream_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_fetch.EmptyQ
inline bool          ind_fetch_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_fetch.Find
x2gw::FFetch*        ind_fetch_Find(x2::RequestId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_fetch.FindX
x2gw::FFetch&        ind_fetch_FindX(x2::RequestId key);
// Return number of items in the hash
// func:x2gw.FDb.ind_fetch.N
inline i32           ind_fetch_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_fetch.InsertMaybe
bool                 ind_fetch_InsertMaybe(x2gw::FFetch& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_fetch.Remove
void                 ind_fetch_Remove(x2gw::FFetch& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_fetch.Reserve
void                 ind_fetch_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.user.Alloc
x2gw::FUser&         user_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.user.AllocMaybe
x2gw::FUser*         user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.user.Delete
void                 user_Delete(x2gw::FUser &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FUser..Init
inline void          FUser_Init(x2gw::FUser& user);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.user.AllocMem
void*                user_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.user.FreeMem
void                 user_FreeMem(x2gw::FUser &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.user.Reserve
u64                  user_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.user.ReserveMem
u64                  user_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_user.EmptyQ
inline bool          ind_user_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_user.Find
x2gw::FUser*         ind_user_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_user.FindX
x2gw::FUser&         ind_user_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_user.N
inline i32           ind_user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_user.InsertMaybe
bool                 ind_user_InsertMaybe(x2gw::FUser& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_user.Remove
void                 ind_user_Remove(x2gw::FUser& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_user.Reserve
void                 ind_user_Reserve(int n) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.c_user_sorted.EmptyQ
inline bool          c_user_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.c_user_sorted.Find
inline x2gw::FUser*  c_user_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:x2gw.FDb.c_user_sorted.Getary
inline algo::aryptr<x2gw::FUser*> c_user_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:x2gw.FDb.c_user_sorted.Insert
void                 c_user_sorted_Insert(x2gw::FUser& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:x2gw.FDb.c_user_sorted.InsertMaybe
bool                 c_user_sorted_InsertMaybe(x2gw::FUser& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:x2gw.FDb.c_user_sorted.N
inline i32           c_user_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:x2gw.FDb.c_user_sorted.Remove
void                 c_user_sorted_Remove(x2gw::FUser& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.c_user_sorted.RemoveAll
inline void          c_user_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:x2gw.FDb.c_user_sorted.Reserve
void                 c_user_sorted_Reserve(u32 n) __attribute__((nothrow));
// func:x2gw.FDb.c_user_sorted_curs.Reset
inline void          _db_c_user_sorted_curs_Reset(_db_c_user_sorted_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.c_user_sorted_curs.ValidQ
inline bool          _db_c_user_sorted_curs_ValidQ(_db_c_user_sorted_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.c_user_sorted_curs.Next
inline void          _db_c_user_sorted_curs_Next(_db_c_user_sorted_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.c_user_sorted_curs.Access
inline x2gw::FUser&  _db_c_user_sorted_curs_Access(_db_c_user_sorted_curs &curs) __attribute__((nothrow));
// Return reference without bounds checking
// func:x2gw.FDb.c_user_sorted.qFind
inline x2gw::FUser&  c_user_sorted_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:x2gw.FDb.c_user_sorted.InAryQ
inline bool          c_user_sorted_InAryQ(x2gw::FUser& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:x2gw.FDb.c_user_sorted.qLast
inline x2gw::FUser&  c_user_sorted_qLast() __attribute__((nothrow));
// Swap values elem_a and elem_b
// func:x2gw.FDb.c_user_sorted.Swap
inline static void   c_user_sorted_Swap(x2gw::FUser* &elem_a, x2gw::FUser* &elem_b) __attribute__((nothrow));
// Left circular shift of three-tuple
// func:x2gw.FDb.c_user_sorted.Rotleft
inline static void   c_user_sorted_Rotleft(x2gw::FUser* &elem_a, x2gw::FUser* &elem_b, x2gw::FUser* &elem_c) __attribute__((nothrow));
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
// func:x2gw.FDb.c_user_sorted.Lt
static bool          c_user_sorted_Lt(x2gw::FUser &elem_a, x2gw::FUser &elem_b) __attribute__((nothrow));
// Verify whether array is sorted
// func:x2gw.FDb.c_user_sorted.SortedQ
bool                 c_user_sorted_SortedQ() __attribute__((nothrow));
// Internal insertion sort
// func:x2gw.FDb.c_user_sorted.IntInsertionSort
static void          c_user_sorted_IntInsertionSort(x2gw::FUser* *elems, int n) __attribute__((nothrow));
// Internal heap sort
// func:x2gw.FDb.c_user_sorted.IntHeapSort
static void          c_user_sorted_IntHeapSort(x2gw::FUser* *elems, int n) __attribute__((nothrow));
// Quick sort engine
// func:x2gw.FDb.c_user_sorted.IntQuickSort
static void          c_user_sorted_IntQuickSort(x2gw::FUser* *elems, int n, int depth) __attribute__((nothrow));
// Insertion sort
// func:x2gw.FDb.c_user_sorted.InsertionSort
void                 c_user_sorted_InsertionSort() __attribute__((nothrow));
// Heap sort
// func:x2gw.FDb.c_user_sorted.HeapSort
void                 c_user_sorted_HeapSort() __attribute__((nothrow));
// Quick sort
// func:x2gw.FDb.c_user_sorted.QuickSort
void                 c_user_sorted_QuickSort() __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.apiendpoint.Alloc
x2gw::FApiendpoint&  apiendpoint_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.apiendpoint.AllocMaybe
x2gw::FApiendpoint*  apiendpoint_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.apiendpoint.InsertMaybe
x2gw::FApiendpoint*  apiendpoint_InsertMaybe(const x2db::Apiendpoint &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.apiendpoint.AllocMem
void*                apiendpoint_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.apiendpoint.EmptyQ
inline bool          apiendpoint_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.apiendpoint.Find
inline x2gw::FApiendpoint* apiendpoint_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.apiendpoint.Last
inline x2gw::FApiendpoint* apiendpoint_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.apiendpoint.N
inline i32           apiendpoint_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.apiendpoint.RemoveAll
void                 apiendpoint_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.apiendpoint.RemoveLast
void                 apiendpoint_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.apiendpoint.qFind
inline x2gw::FApiendpoint& apiendpoint_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.apiendpoint_curs.Reset
inline void          _db_apiendpoint_curs_Reset(_db_apiendpoint_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.apiendpoint_curs.ValidQ
inline bool          _db_apiendpoint_curs_ValidQ(_db_apiendpoint_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.apiendpoint_curs.Next
inline void          _db_apiendpoint_curs_Next(_db_apiendpoint_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.apiendpoint_curs.Access
inline x2gw::FApiendpoint& _db_apiendpoint_curs_Access(_db_apiendpoint_curs &curs) __attribute__((nothrow));
// func:x2gw.FDb.apiendpoint.LoadStatic
static void          apiendpoint_LoadStatic() __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_apiendpoint.EmptyQ
inline bool          ind_apiendpoint_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_apiendpoint.Find
x2gw::FApiendpoint*  ind_apiendpoint_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_apiendpoint.FindX
x2gw::FApiendpoint&  ind_apiendpoint_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_apiendpoint.GetOrCreate
x2gw::FApiendpoint&  ind_apiendpoint_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_apiendpoint.N
inline i32           ind_apiendpoint_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_apiendpoint.InsertMaybe
bool                 ind_apiendpoint_InsertMaybe(x2gw::FApiendpoint& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_apiendpoint.Remove
void                 ind_apiendpoint_Remove(x2gw::FApiendpoint& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_apiendpoint.Reserve
void                 ind_apiendpoint_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.cmdreq.Alloc
x2gw::FCmdreq&       cmdreq_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.cmdreq.AllocMaybe
x2gw::FCmdreq*       cmdreq_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.cmdreq.Delete
void                 cmdreq_Delete(x2gw::FCmdreq &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.cmdreq.AllocMem
void*                cmdreq_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.cmdreq.FreeMem
void                 cmdreq_FreeMem(x2gw::FCmdreq &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.cmdreq.Reserve
u64                  cmdreq_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.cmdreq.ReserveMem
u64                  cmdreq_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_cmdreq.EmptyQ
inline bool          ind_cmdreq_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_cmdreq.Find
x2gw::FCmdreq*       ind_cmdreq_Find(x2::RequestId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_cmdreq.FindX
x2gw::FCmdreq&       ind_cmdreq_FindX(x2::RequestId key);
// Return number of items in the hash
// func:x2gw.FDb.ind_cmdreq.N
inline i32           ind_cmdreq_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_cmdreq.InsertMaybe
bool                 ind_cmdreq_InsertMaybe(x2gw::FCmdreq& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_cmdreq.Remove
void                 ind_cmdreq_Remove(x2gw::FCmdreq& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_cmdreq.Reserve
void                 ind_cmdreq_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.proc_output.Alloc
x2gw::FProcOutput&   proc_output_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.proc_output.AllocMaybe
x2gw::FProcOutput*   proc_output_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.proc_output.Delete
void                 proc_output_Delete(x2gw::FProcOutput &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FProcOutput..Init
inline void          FProcOutput_Init(x2gw::FProcOutput& proc_output);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.proc_output.AllocMem
void*                proc_output_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.proc_output.FreeMem
void                 proc_output_FreeMem(x2gw::FProcOutput &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.proc_output.Reserve
u64                  proc_output_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.proc_output.ReserveMem
u64                  proc_output_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_proc_output.EmptyQ
inline bool          ind_proc_output_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_proc_output.Find
x2gw::FProcOutput*   ind_proc_output_Find(x2::RequestProcId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_proc_output.FindX
x2gw::FProcOutput&   ind_proc_output_FindX(x2::RequestProcId key);
// Return number of items in the hash
// func:x2gw.FDb.ind_proc_output.N
inline i32           ind_proc_output_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_proc_output.InsertMaybe
bool                 ind_proc_output_InsertMaybe(x2gw::FProcOutput& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_proc_output.Remove
void                 ind_proc_output_Remove(x2gw::FProcOutput& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_proc_output.Reserve
void                 ind_proc_output_Reserve(int n) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_conn_metric_sub.EmptyQ
inline bool          zd_conn_metric_sub_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_conn_metric_sub.First
inline x2gw::FConn*  zd_conn_metric_sub_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_conn_metric_sub.InLlistQ
inline bool          zd_conn_metric_sub_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_conn_metric_sub.Insert
void                 zd_conn_metric_sub_Insert(x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_conn_metric_sub.Last
inline x2gw::FConn*  zd_conn_metric_sub_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_conn_metric_sub.N
inline i32           zd_conn_metric_sub_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_conn_metric_sub.Next
inline x2gw::FConn*  zd_conn_metric_sub_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_conn_metric_sub.Prev
inline x2gw::FConn*  zd_conn_metric_sub_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_conn_metric_sub.Remove
void                 zd_conn_metric_sub_Remove(x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_conn_metric_sub.RemoveAll
void                 zd_conn_metric_sub_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_conn_metric_sub.RemoveFirst
x2gw::FConn*         zd_conn_metric_sub_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_conn_metric_sub.qLast
inline x2gw::FConn&  zd_conn_metric_sub_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_conn_metric_sub_curs.Reset
inline void          _db_zd_conn_metric_sub_curs_Reset(_db_zd_conn_metric_sub_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_conn_metric_sub_curs.ValidQ
inline bool          _db_zd_conn_metric_sub_curs_ValidQ(_db_zd_conn_metric_sub_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_conn_metric_sub_curs.Next
inline void          _db_zd_conn_metric_sub_curs_Next(_db_zd_conn_metric_sub_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_conn_metric_sub_curs.Access
inline x2gw::FConn&  _db_zd_conn_metric_sub_curs_Access(_db_zd_conn_metric_sub_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.metric.Alloc
x2gw::FMetric&       metric_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.metric.AllocMaybe
x2gw::FMetric*       metric_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.metric.AllocMem
void*                metric_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.metric.EmptyQ
inline bool          metric_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.metric.Find
inline x2gw::FMetric* metric_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.metric.Last
inline x2gw::FMetric* metric_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.metric.N
inline i32           metric_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.metric.RemoveAll
void                 metric_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.metric.RemoveLast
void                 metric_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.metric.qFind
inline x2gw::FMetric& metric_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.metric_curs.Reset
inline void          _db_metric_curs_Reset(_db_metric_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.metric_curs.ValidQ
inline bool          _db_metric_curs_ValidQ(_db_metric_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.metric_curs.Next
inline void          _db_metric_curs_Next(_db_metric_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.metric_curs.Access
inline x2gw::FMetric& _db_metric_curs_Access(_db_metric_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FMetric..Init
inline void          FMetric_Init(x2gw::FMetric& metric);
// Return true if hash is empty
// func:x2gw.FDb.ind_metric.EmptyQ
inline bool          ind_metric_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_metric.Find
x2gw::FMetric*       ind_metric_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_metric.FindX
x2gw::FMetric&       ind_metric_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_metric.N
inline i32           ind_metric_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_metric.InsertMaybe
bool                 ind_metric_InsertMaybe(x2gw::FMetric& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_metric.Remove
void                 ind_metric_Remove(x2gw::FMetric& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_metric.Reserve
void                 ind_metric_Reserve(int n) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_metric_id.EmptyQ
inline bool          ind_metric_id_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_metric_id.Find
x2gw::FMetric*       ind_metric_id_Find(x2::MetricId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_metric_id.FindX
x2gw::FMetric&       ind_metric_id_FindX(x2::MetricId key);
// Return number of items in the hash
// func:x2gw.FDb.ind_metric_id.N
inline i32           ind_metric_id_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_metric_id.InsertMaybe
bool                 ind_metric_id_InsertMaybe(x2gw::FMetric& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_metric_id.Remove
void                 ind_metric_id_Remove(x2gw::FMetric& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_metric_id.Reserve
void                 ind_metric_id_Reserve(int n) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FDb..Init
void                 FDb_Init();
// Invoke function by pointer
// func:x2gw.FDb.h_pub_metric.Call
inline void          h_pub_metric_Call(x2gw::FMetric& arg) __attribute__((nothrow));
// Assign 0-argument hook with no context pointer
// func:x2gw.FDb.h_pub_metric.Set0
inline void          h_pub_metric_Set0(void (*fcn)() ) __attribute__((nothrow));
// Assign 1-argument hook with context pointer
// func:x2gw.FDb.h_pub_metric.Set1
template<class T> inline void h_pub_metric_Set1(T& ctx, void (*fcn)(T&) ) __attribute__((nothrow));
// Assign 2-argument hook with context pointer
// func:x2gw.FDb.h_pub_metric.Set2
template<class T> inline void h_pub_metric_Set2(T& ctx, void (*fcn)(T&, x2gw::FMetric& arg) ) __attribute__((nothrow));
// Invoke function by pointer
// func:x2gw.FDb.h_def_metric.Call
inline void          h_def_metric_Call(x2gw::FMetric& arg) __attribute__((nothrow));
// Assign 0-argument hook with no context pointer
// func:x2gw.FDb.h_def_metric.Set0
inline void          h_def_metric_Set0(void (*fcn)() ) __attribute__((nothrow));
// Assign 1-argument hook with context pointer
// func:x2gw.FDb.h_def_metric.Set1
template<class T> inline void h_def_metric_Set1(T& ctx, void (*fcn)(T&) ) __attribute__((nothrow));
// Assign 2-argument hook with context pointer
// func:x2gw.FDb.h_def_metric.Set2
template<class T> inline void h_def_metric_Set2(T& ctx, void (*fcn)(T&, x2gw::FMetric& arg) ) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.connstat.Alloc
x2gw::FConnstat&     connstat_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.connstat.AllocMaybe
x2gw::FConnstat*     connstat_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.connstat.AllocMem
void*                connstat_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.connstat.EmptyQ
inline bool          connstat_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.connstat.Find
inline x2gw::FConnstat* connstat_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.connstat.Last
inline x2gw::FConnstat* connstat_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.connstat.N
inline i32           connstat_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.connstat.RemoveAll
void                 connstat_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.connstat.RemoveLast
void                 connstat_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.connstat.qFind
inline x2gw::FConnstat& connstat_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.connstat_curs.Reset
inline void          _db_connstat_curs_Reset(_db_connstat_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.connstat_curs.ValidQ
inline bool          _db_connstat_curs_ValidQ(_db_connstat_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.connstat_curs.Next
inline void          _db_connstat_curs_Next(_db_connstat_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.connstat_curs.Access
inline x2gw::FConnstat& _db_connstat_curs_Access(_db_connstat_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.moentry.Alloc
x2gw::FMoentry&      moentry_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.moentry.AllocMaybe
x2gw::FMoentry*      moentry_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.moentry.Delete
void                 moentry_Delete(x2gw::FMoentry &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.moentry.AllocMem
void*                moentry_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.moentry.FreeMem
void                 moentry_FreeMem(x2gw::FMoentry &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.moentry.Reserve
u64                  moentry_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.moentry.ReserveMem
u64                  moentry_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_moentry.EmptyQ
inline bool          ind_moentry_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_moentry.Find
x2gw::FMoentry*      ind_moentry_Find(x2gw::FMoentryKey key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_moentry.FindX
x2gw::FMoentry&      ind_moentry_FindX(x2gw::FMoentryKey key);
// Return number of items in the hash
// func:x2gw.FDb.ind_moentry.N
inline i32           ind_moentry_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_moentry.InsertMaybe
bool                 ind_moentry_InsertMaybe(x2gw::FMoentry& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_moentry.Remove
void                 ind_moentry_Remove(x2gw::FMoentry& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_moentry.Reserve
void                 ind_moentry_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.disk.Alloc
x2gw::FDisk&         disk_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.disk.AllocMaybe
x2gw::FDisk*         disk_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.disk.InsertMaybe
x2gw::FDisk*         disk_InsertMaybe(const x2::Disk &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.disk.AllocMem
void*                disk_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.disk.EmptyQ
inline bool          disk_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.disk.Find
inline x2gw::FDisk*  disk_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.disk.Last
inline x2gw::FDisk*  disk_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.disk.N
inline i32           disk_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.disk.RemoveAll
void                 disk_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.disk.RemoveLast
void                 disk_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.disk.qFind
inline x2gw::FDisk&  disk_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.disk_curs.Reset
inline void          _db_disk_curs_Reset(_db_disk_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.disk_curs.ValidQ
inline bool          _db_disk_curs_ValidQ(_db_disk_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.disk_curs.Next
inline void          _db_disk_curs_Next(_db_disk_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.disk_curs.Access
inline x2gw::FDisk&  _db_disk_curs_Access(_db_disk_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FDisk..Init
inline void          FDisk_Init(x2gw::FDisk& disk);
// Return true if hash is empty
// func:x2gw.FDb.ind_disk.EmptyQ
inline bool          ind_disk_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_disk.Find
x2gw::FDisk*         ind_disk_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_disk.FindX
x2gw::FDisk&         ind_disk_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_disk.GetOrCreate
x2gw::FDisk&         ind_disk_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_disk.N
inline i32           ind_disk_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_disk.InsertMaybe
bool                 ind_disk_InsertMaybe(x2gw::FDisk& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_disk.Remove
void                 ind_disk_Remove(x2gw::FDisk& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_disk.Reserve
void                 ind_disk_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.intf.Alloc
x2gw::FIntf&         intf_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.intf.AllocMaybe
x2gw::FIntf*         intf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.intf.InsertMaybe
x2gw::FIntf*         intf_InsertMaybe(const x2::Intf &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.intf.AllocMem
void*                intf_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.intf.EmptyQ
inline bool          intf_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.intf.Find
inline x2gw::FIntf*  intf_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.intf.Last
inline x2gw::FIntf*  intf_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.intf.N
inline i32           intf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.intf.RemoveAll
void                 intf_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.intf.RemoveLast
void                 intf_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.intf.qFind
inline x2gw::FIntf&  intf_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.intf_curs.Reset
inline void          _db_intf_curs_Reset(_db_intf_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.intf_curs.ValidQ
inline bool          _db_intf_curs_ValidQ(_db_intf_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.intf_curs.Next
inline void          _db_intf_curs_Next(_db_intf_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.intf_curs.Access
inline x2gw::FIntf&  _db_intf_curs_Access(_db_intf_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FIntf..Init
inline void          FIntf_Init(x2gw::FIntf& intf);
// Return true if hash is empty
// func:x2gw.FDb.ind_intf.EmptyQ
inline bool          ind_intf_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_intf.Find
x2gw::FIntf*         ind_intf_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_intf.FindX
x2gw::FIntf&         ind_intf_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_intf.GetOrCreate
x2gw::FIntf&         ind_intf_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_intf.N
inline i32           ind_intf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_intf.InsertMaybe
bool                 ind_intf_InsertMaybe(x2gw::FIntf& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_intf.Remove
void                 ind_intf_Remove(x2gw::FIntf& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_intf.Reserve
void                 ind_intf_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.acl.Alloc
x2gw::FAcl&          acl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.acl.AllocMaybe
x2gw::FAcl*          acl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.acl.AllocMem
void*                acl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.acl.EmptyQ
inline bool          acl_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.acl.Find
inline x2gw::FAcl*   acl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.acl.Last
inline x2gw::FAcl*   acl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.acl.N
inline i32           acl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.acl.RemoveAll
void                 acl_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.acl.RemoveLast
void                 acl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.acl.qFind
inline x2gw::FAcl&   acl_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.acl_curs.Reset
inline void          _db_acl_curs_Reset(_db_acl_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.acl_curs.ValidQ
inline bool          _db_acl_curs_ValidQ(_db_acl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.acl_curs.Next
inline void          _db_acl_curs_Next(_db_acl_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.acl_curs.Access
inline x2gw::FAcl&   _db_acl_curs_Access(_db_acl_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.kafka_acl_resource.Alloc
x2gw::FKafkaAclResource& kafka_acl_resource_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.kafka_acl_resource.AllocMaybe
x2gw::FKafkaAclResource* kafka_acl_resource_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.kafka_acl_resource.Delete
void                 kafka_acl_resource_Delete(x2gw::FKafkaAclResource &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FKafkaAclResource..Init
inline void          FKafkaAclResource_Init(x2gw::FKafkaAclResource& kafka_acl_resource);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.kafka_acl_resource.AllocMem
void*                kafka_acl_resource_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.kafka_acl_resource.FreeMem
void                 kafka_acl_resource_FreeMem(x2gw::FKafkaAclResource &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.kafka_acl_resource.Reserve
u64                  kafka_acl_resource_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.kafka_acl_resource.ReserveMem
u64                  kafka_acl_resource_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_kafka_acl_resource.EmptyQ
inline bool          zd_kafka_acl_resource_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_kafka_acl_resource.First
inline x2gw::FKafkaAclResource* zd_kafka_acl_resource_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_kafka_acl_resource.InLlistQ
inline bool          zd_kafka_acl_resource_InLlistQ(x2gw::FKafkaAclResource& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_kafka_acl_resource.Insert
void                 zd_kafka_acl_resource_Insert(x2gw::FKafkaAclResource& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_kafka_acl_resource.Last
inline x2gw::FKafkaAclResource* zd_kafka_acl_resource_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_kafka_acl_resource.N
inline i32           zd_kafka_acl_resource_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_kafka_acl_resource.Next
inline x2gw::FKafkaAclResource* zd_kafka_acl_resource_Next(x2gw::FKafkaAclResource &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_kafka_acl_resource.Prev
inline x2gw::FKafkaAclResource* zd_kafka_acl_resource_Prev(x2gw::FKafkaAclResource &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_kafka_acl_resource.Remove
void                 zd_kafka_acl_resource_Remove(x2gw::FKafkaAclResource& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_kafka_acl_resource.RemoveAll
void                 zd_kafka_acl_resource_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_kafka_acl_resource.RemoveFirst
x2gw::FKafkaAclResource* zd_kafka_acl_resource_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_kafka_acl_resource.qLast
inline x2gw::FKafkaAclResource& zd_kafka_acl_resource_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_kafka_acl_resource_curs.Reset
inline void          _db_zd_kafka_acl_resource_curs_Reset(_db_zd_kafka_acl_resource_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_kafka_acl_resource_curs.ValidQ
inline bool          _db_zd_kafka_acl_resource_curs_ValidQ(_db_zd_kafka_acl_resource_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_kafka_acl_resource_curs.Next
inline void          _db_zd_kafka_acl_resource_curs_Next(_db_zd_kafka_acl_resource_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_kafka_acl_resource_curs.Access
inline x2gw::FKafkaAclResource& _db_zd_kafka_acl_resource_curs_Access(_db_zd_kafka_acl_resource_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_kafka_acl_resource_delcurs.Reset
inline void          _db_zd_kafka_acl_resource_delcurs_Reset(_db_zd_kafka_acl_resource_delcurs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_kafka_acl_resource_delcurs.ValidQ
inline bool          _db_zd_kafka_acl_resource_delcurs_ValidQ(_db_zd_kafka_acl_resource_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_kafka_acl_resource_delcurs.Next
inline void          _db_zd_kafka_acl_resource_delcurs_Next(_db_zd_kafka_acl_resource_delcurs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_kafka_acl_resource_delcurs.Access
inline x2gw::FKafkaAclResource& _db_zd_kafka_acl_resource_delcurs_Access(_db_zd_kafka_acl_resource_delcurs &curs) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_kafka_acl_resource.EmptyQ
inline bool          ind_kafka_acl_resource_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_kafka_acl_resource.Find
x2gw::FKafkaAclResource* ind_kafka_acl_resource_Find(const x2gw::KafkaAclResourceKey& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_kafka_acl_resource.FindX
x2gw::FKafkaAclResource& ind_kafka_acl_resource_FindX(const x2gw::KafkaAclResourceKey& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_kafka_acl_resource.GetOrCreate
x2gw::FKafkaAclResource& ind_kafka_acl_resource_GetOrCreate(const x2gw::KafkaAclResourceKey& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_kafka_acl_resource.N
inline i32           ind_kafka_acl_resource_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_kafka_acl_resource.InsertMaybe
bool                 ind_kafka_acl_resource_InsertMaybe(x2gw::FKafkaAclResource& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_kafka_acl_resource.Remove
void                 ind_kafka_acl_resource_Remove(x2gw::FKafkaAclResource& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_kafka_acl_resource.Reserve
void                 ind_kafka_acl_resource_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.kafka_acl.Alloc
x2gw::FKafkaAcl&     kafka_acl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.kafka_acl.AllocMaybe
x2gw::FKafkaAcl*     kafka_acl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.kafka_acl.Delete
void                 kafka_acl_Delete(x2gw::FKafkaAcl &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FKafkaAcl..Init
inline void          FKafkaAcl_Init(x2gw::FKafkaAcl& kafka_acl);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.kafka_acl.AllocMem
void*                kafka_acl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.kafka_acl.FreeMem
void                 kafka_acl_FreeMem(x2gw::FKafkaAcl &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.kafka_acl.Reserve
u64                  kafka_acl_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.kafka_acl.ReserveMem
u64                  kafka_acl_ReserveMem(u64 size) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.topic.Alloc
x2gw::FTopic&        topic_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.topic.AllocMaybe
x2gw::FTopic*        topic_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.topic.Delete
void                 topic_Delete(x2gw::FTopic &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FTopic..Init
inline void          FTopic_Init(x2gw::FTopic& topic);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.topic.AllocMem
void*                topic_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.topic.FreeMem
void                 topic_FreeMem(x2gw::FTopic &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.topic.Reserve
u64                  topic_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.topic.ReserveMem
u64                  topic_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_topic.EmptyQ
inline bool          ind_topic_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_topic.Find
x2gw::FTopic*        ind_topic_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_topic.FindX
x2gw::FTopic&        ind_topic_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_topic.N
inline i32           ind_topic_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_topic.InsertMaybe
bool                 ind_topic_InsertMaybe(x2gw::FTopic& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_topic.Remove
void                 ind_topic_Remove(x2gw::FTopic& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_topic.Reserve
void                 ind_topic_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.kafka_fetch.Alloc
x2gw::FKafkaFetch&   kafka_fetch_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.kafka_fetch.AllocMaybe
x2gw::FKafkaFetch*   kafka_fetch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.kafka_fetch.Delete
void                 kafka_fetch_Delete(x2gw::FKafkaFetch &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FKafkaFetch..Init
inline void          FKafkaFetch_Init(x2gw::FKafkaFetch& kafka_fetch);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.kafka_fetch.AllocMem
void*                kafka_fetch_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.kafka_fetch.FreeMem
void                 kafka_fetch_FreeMem(x2gw::FKafkaFetch &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.kafka_fetch.Reserve
u64                  kafka_fetch_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.kafka_fetch.ReserveMem
u64                  kafka_fetch_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_topic_id.EmptyQ
inline bool          ind_topic_id_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_topic_id.Find
x2gw::FTopic*        ind_topic_id_Find(const algo::Uuid& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_topic_id.FindX
x2gw::FTopic&        ind_topic_id_FindX(const algo::Uuid& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_topic_id.N
inline i32           ind_topic_id_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_topic_id.InsertMaybe
bool                 ind_topic_id_InsertMaybe(x2gw::FTopic& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_topic_id.Remove
void                 ind_topic_id_Remove(x2gw::FTopic& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_topic_id.Reserve
void                 ind_topic_id_Reserve(int n) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_topic.EmptyQ
inline bool          zd_topic_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_topic.First
inline x2gw::FTopic* zd_topic_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_topic.InLlistQ
inline bool          zd_topic_InLlistQ(x2gw::FTopic& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_topic.Insert
void                 zd_topic_Insert(x2gw::FTopic& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_topic.Last
inline x2gw::FTopic* zd_topic_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_topic.N
inline i32           zd_topic_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_topic.Next
inline x2gw::FTopic* zd_topic_Next(x2gw::FTopic &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_topic.Prev
inline x2gw::FTopic* zd_topic_Prev(x2gw::FTopic &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_topic.Remove
void                 zd_topic_Remove(x2gw::FTopic& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_topic.RemoveAll
void                 zd_topic_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_topic.RemoveFirst
x2gw::FTopic*        zd_topic_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_topic.qLast
inline x2gw::FTopic& zd_topic_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_topic_curs.Reset
inline void          _db_zd_topic_curs_Reset(_db_zd_topic_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_topic_curs.ValidQ
inline bool          _db_zd_topic_curs_ValidQ(_db_zd_topic_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_topic_curs.Next
inline void          _db_zd_topic_curs_Next(_db_zd_topic_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_topic_curs.Access
inline x2gw::FTopic& _db_zd_topic_curs_Access(_db_zd_topic_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.group.Alloc
x2gw::FGroup&        group_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.group.AllocMaybe
x2gw::FGroup*        group_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.group.Delete
void                 group_Delete(x2gw::FGroup &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FGroup..Init
inline void          FGroup_Init(x2gw::FGroup& group);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.group.AllocMem
void*                group_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.group.FreeMem
void                 group_FreeMem(x2gw::FGroup &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.group.Reserve
u64                  group_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.group.ReserveMem
u64                  group_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FDb.ind_group.EmptyQ
inline bool          ind_group_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_group.Find
x2gw::FGroup*        ind_group_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_group.FindX
x2gw::FGroup&        ind_group_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:x2gw.FDb.ind_group.GetOrCreate
x2gw::FGroup&        ind_group_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:x2gw.FDb.ind_group.N
inline i32           ind_group_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_group.InsertMaybe
bool                 ind_group_InsertMaybe(x2gw::FGroup& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_group.Remove
void                 ind_group_Remove(x2gw::FGroup& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_group.Reserve
void                 ind_group_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.member.Alloc
x2gw::FMember&       member_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.member.AllocMaybe
x2gw::FMember*       member_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:x2gw.FDb.member.Delete
void                 member_Delete(x2gw::FMember &row) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FMember..Init
void                 FMember_Init(x2gw::FMember& member);
// Allocate space for one element
// If no memory available, return NULL.
// func:x2gw.FDb.member.AllocMem
void*                member_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:x2gw.FDb.member.FreeMem
void                 member_FreeMem(x2gw::FMember &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:x2gw.FDb.member.Reserve
u64                  member_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:x2gw.FDb.member.ReserveMem
u64                  member_ReserveMem(u64 size) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FDb.zd_group.EmptyQ
inline bool          zd_group_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FDb.zd_group.First
inline x2gw::FGroup* zd_group_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FDb.zd_group.InLlistQ
inline bool          zd_group_InLlistQ(x2gw::FGroup& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FDb.zd_group.Insert
void                 zd_group_Insert(x2gw::FGroup& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FDb.zd_group.Last
inline x2gw::FGroup* zd_group_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FDb.zd_group.N
inline i32           zd_group_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FDb.zd_group.Next
inline x2gw::FGroup* zd_group_Next(x2gw::FGroup &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FDb.zd_group.Prev
inline x2gw::FGroup* zd_group_Prev(x2gw::FGroup &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FDb.zd_group.Remove
void                 zd_group_Remove(x2gw::FGroup& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FDb.zd_group.RemoveAll
void                 zd_group_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FDb.zd_group.RemoveFirst
x2gw::FGroup*        zd_group_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FDb.zd_group.qLast
inline x2gw::FGroup& zd_group_qLast() __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_group_curs.Reset
inline void          _db_zd_group_curs_Reset(_db_zd_group_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.zd_group_curs.ValidQ
inline bool          _db_zd_group_curs_ValidQ(_db_zd_group_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.zd_group_curs.Next
inline void          _db_zd_group_curs_Next(_db_zd_group_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.zd_group_curs.Access
inline x2gw::FGroup& _db_zd_group_curs_Access(_db_zd_group_curs &curs) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.gwport.Alloc
x2gw::FGwport&       gwport_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.gwport.AllocMaybe
x2gw::FGwport*       gwport_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.gwport.InsertMaybe
x2gw::FGwport*       gwport_InsertMaybe(const x2db::Gwport &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.gwport.AllocMem
void*                gwport_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.gwport.EmptyQ
inline bool          gwport_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.gwport.Find
inline x2gw::FGwport* gwport_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.gwport.Last
inline x2gw::FGwport* gwport_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.gwport.N
inline i32           gwport_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.gwport.RemoveAll
void                 gwport_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.gwport.RemoveLast
void                 gwport_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.gwport.qFind
inline x2gw::FGwport& gwport_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.gwport_curs.Reset
inline void          _db_gwport_curs_Reset(_db_gwport_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.gwport_curs.ValidQ
inline bool          _db_gwport_curs_ValidQ(_db_gwport_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.gwport_curs.Next
inline void          _db_gwport_curs_Next(_db_gwport_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.gwport_curs.Access
inline x2gw::FGwport& _db_gwport_curs_Access(_db_gwport_curs &curs) __attribute__((nothrow));
// func:x2gw.FDb.gwport.InputMaybe
static bool          gwport_InputMaybe(x2db::Gwport &elem) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FGwproto..Init
inline void          FGwproto_Init(x2gw::FGwproto& gwproto);
// Return true if hash is empty
// func:x2gw.FDb.ind_gwproto.EmptyQ
inline bool          ind_gwproto_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_gwproto.Find
x2gw::FGwproto*      ind_gwproto_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_gwproto.FindX
x2gw::FGwproto&      ind_gwproto_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_gwproto.N
inline i32           ind_gwproto_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_gwproto.InsertMaybe
bool                 ind_gwproto_InsertMaybe(x2gw::FGwproto& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_gwproto.Remove
void                 ind_gwproto_Remove(x2gw::FGwproto& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_gwproto.Reserve
void                 ind_gwproto_Reserve(int n) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:x2gw.FDb.proc.Alloc
x2gw::FProc&         proc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:x2gw.FDb.proc.AllocMaybe
x2gw::FProc*         proc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:x2gw.FDb.proc.InsertMaybe
x2gw::FProc*         proc_InsertMaybe(const x2db::Proc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:x2gw.FDb.proc.AllocMem
void*                proc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FDb.proc.EmptyQ
inline bool          proc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FDb.proc.Find
inline x2gw::FProc*  proc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FDb.proc.Last
inline x2gw::FProc*  proc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:x2gw.FDb.proc.N
inline i32           proc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:x2gw.FDb.proc.RemoveAll
void                 proc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FDb.proc.RemoveLast
void                 proc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FDb.proc.qFind
inline x2gw::FProc&  proc_qFind(u64 t) __attribute__((nothrow, pure));
// cursor points to valid item
// func:x2gw.FDb.proc_curs.Reset
inline void          _db_proc_curs_Reset(_db_proc_curs &curs, x2gw::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FDb.proc_curs.ValidQ
inline bool          _db_proc_curs_ValidQ(_db_proc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FDb.proc_curs.Next
inline void          _db_proc_curs_Next(_db_proc_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FDb.proc_curs.Access
inline x2gw::FProc&  _db_proc_curs_Access(_db_proc_curs &curs) __attribute__((nothrow));
// func:x2gw.FDb.proc.InputMaybe
static bool          proc_InputMaybe(x2db::Proc &elem) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FProc..Init
void                 FProc_Init(x2gw::FProc& proc);
// Return true if hash is empty
// func:x2gw.FDb.ind_proc.EmptyQ
inline bool          ind_proc_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FDb.ind_proc.Find
x2gw::FProc*         ind_proc_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FDb.ind_proc.FindX
x2gw::FProc&         ind_proc_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:x2gw.FDb.ind_proc.N
inline i32           ind_proc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FDb.ind_proc.InsertMaybe
bool                 ind_proc_InsertMaybe(x2gw::FProc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FDb.ind_proc.Remove
void                 ind_proc_Remove(x2gw::FProc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FDb.ind_proc.Reserve
void                 ind_proc_Reserve(int n) __attribute__((nothrow));
// find trace by row id (used to implement reflection)
// func:x2gw.FDb.trace.RowidFind
static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
// Function return 1
// func:x2gw.FDb.trace.N
inline static i32    trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Copy fields out of row
// func:x2gw.FDisk.base.CopyOut
void                 disk_CopyOut(x2gw::FDisk &row, x2::Disk &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FDisk.base.CopyIn
void                 disk_CopyIn(x2gw::FDisk &row, x2::Disk &in) __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.RespFetchOp.value.GetEnum
inline x2gw_RespFetchOpEnum value_GetEnum(const x2gw::RespFetchOp& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.RespFetchOp.value.SetEnum
inline void          value_SetEnum(x2gw::RespFetchOp& parent, x2gw_RespFetchOpEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.RespFetchOp.value.ToCstr
const char*          value_ToCstr(const x2gw::RespFetchOp& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.RespFetchOp.value.Print
void                 value_Print(const x2gw::RespFetchOp& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.RespFetchOp.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::RespFetchOp& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.RespFetchOp.value.SetStrptr
void                 value_SetStrptr(x2gw::RespFetchOp& parent, algo::strptr rhs, x2gw_RespFetchOpEnum dflt) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FFetch.base.CopyOut
void                 fetch_CopyOut(x2gw::FFetch &row, x2gw::Fetch &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FFetch.base.CopyIn
void                 fetch_CopyIn(x2gw::FFetch &row, x2gw::Fetch &in) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FFetch.zd_packet_queue.Cascdel
void                 zd_packet_queue_Cascdel(x2gw::FFetch& fetch) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FFetch.zd_packet_queue.EmptyQ
inline bool          zd_packet_queue_EmptyQ(x2gw::FFetch& fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FFetch.zd_packet_queue.First
inline x2gw::FPacket* zd_packet_queue_First(x2gw::FFetch& fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FFetch.zd_packet_queue.InLlistQ
inline bool          zd_packet_queue_InLlistQ(x2gw::FPacket& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FFetch.zd_packet_queue.Insert
void                 zd_packet_queue_Insert(x2gw::FFetch& fetch, x2gw::FPacket& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FFetch.zd_packet_queue.Last
inline x2gw::FPacket* zd_packet_queue_Last(x2gw::FFetch& fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FFetch.zd_packet_queue.N
inline i32           zd_packet_queue_N(const x2gw::FFetch& fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FFetch.zd_packet_queue.Next
inline x2gw::FPacket* zd_packet_queue_Next(x2gw::FPacket &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FFetch.zd_packet_queue.Prev
inline x2gw::FPacket* zd_packet_queue_Prev(x2gw::FPacket &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FFetch.zd_packet_queue.Remove
void                 zd_packet_queue_Remove(x2gw::FFetch& fetch, x2gw::FPacket& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FFetch.zd_packet_queue.RemoveAll
void                 zd_packet_queue_RemoveAll(x2gw::FFetch& fetch) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FFetch.zd_packet_queue.RemoveFirst
x2gw::FPacket*       zd_packet_queue_RemoveFirst(x2gw::FFetch& fetch) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FFetch.zd_packet_queue.qLast
inline x2gw::FPacket& zd_packet_queue_qLast(x2gw::FFetch& fetch) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FFetch.zd_packet_queue_curs.Reset
inline void          fetch_zd_packet_queue_curs_Reset(fetch_zd_packet_queue_curs &curs, x2gw::FFetch &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FFetch.zd_packet_queue_curs.ValidQ
inline bool          fetch_zd_packet_queue_curs_ValidQ(fetch_zd_packet_queue_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FFetch.zd_packet_queue_curs.Next
inline void          fetch_zd_packet_queue_curs_Next(fetch_zd_packet_queue_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FFetch.zd_packet_queue_curs.Access
inline x2gw::FPacket& fetch_zd_packet_queue_curs_Access(fetch_zd_packet_queue_curs &curs) __attribute__((nothrow));
// Invoke function by pointer
// func:x2gw.FFetch.h_msg.Call
inline void          h_msg_Call(x2gw::FFetch& fetch, x2::DataMsg& arg) __attribute__((nothrow));
// Assign 0-argument hook with no context pointer
// func:x2gw.FFetch.h_msg.Set0
inline void          h_msg_Set0(x2gw::FFetch& fetch, void (*fcn)() ) __attribute__((nothrow));
// Assign 1-argument hook with context pointer
// func:x2gw.FFetch.h_msg.Set1
template<class T> inline void h_msg_Set1(x2gw::FFetch& fetch, T& ctx, void (*fcn)(T&) ) __attribute__((nothrow));
// Assign 2-argument hook with context pointer
// func:x2gw.FFetch.h_msg.Set2
template<class T> inline void h_msg_Set2(x2gw::FFetch& fetch, T& ctx, void (*fcn)(T&, x2::DataMsg& arg) ) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FGroup.zd_group_member.Cascdel
void                 zd_group_member_Cascdel(x2gw::FGroup& group) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FGroup.zd_group_member.EmptyQ
inline bool          zd_group_member_EmptyQ(x2gw::FGroup& group) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FGroup.zd_group_member.First
inline x2gw::FMember* zd_group_member_First(x2gw::FGroup& group) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FGroup.zd_group_member.InLlistQ
inline bool          zd_group_member_InLlistQ(x2gw::FMember& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FGroup.zd_group_member.Insert
void                 zd_group_member_Insert(x2gw::FGroup& group, x2gw::FMember& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FGroup.zd_group_member.Last
inline x2gw::FMember* zd_group_member_Last(x2gw::FGroup& group) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FGroup.zd_group_member.N
inline i32           zd_group_member_N(const x2gw::FGroup& group) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FGroup.zd_group_member.Next
inline x2gw::FMember* zd_group_member_Next(x2gw::FMember &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FGroup.zd_group_member.Prev
inline x2gw::FMember* zd_group_member_Prev(x2gw::FMember &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FGroup.zd_group_member.Remove
void                 zd_group_member_Remove(x2gw::FGroup& group, x2gw::FMember& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FGroup.zd_group_member.RemoveAll
void                 zd_group_member_RemoveAll(x2gw::FGroup& group) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FGroup.zd_group_member.RemoveFirst
x2gw::FMember*       zd_group_member_RemoveFirst(x2gw::FGroup& group) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FGroup.zd_group_member.qLast
inline x2gw::FMember& zd_group_member_qLast(x2gw::FGroup& group) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FGroup.zd_group_member_curs.Reset
inline void          group_zd_group_member_curs_Reset(group_zd_group_member_curs &curs, x2gw::FGroup &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FGroup.zd_group_member_curs.ValidQ
inline bool          group_zd_group_member_curs_ValidQ(group_zd_group_member_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FGroup.zd_group_member_curs.Next
inline void          group_zd_group_member_curs_Next(group_zd_group_member_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FGroup.zd_group_member_curs.Access
inline x2gw::FMember& group_zd_group_member_curs_Access(group_zd_group_member_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FGroup.zd_group_member_delcurs.Reset
inline void          group_zd_group_member_delcurs_Reset(group_zd_group_member_delcurs &curs, x2gw::FGroup &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FGroup.zd_group_member_delcurs.ValidQ
inline bool          group_zd_group_member_delcurs_ValidQ(group_zd_group_member_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FGroup.zd_group_member_delcurs.Next
inline void          group_zd_group_member_delcurs_Next(group_zd_group_member_delcurs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FGroup.zd_group_member_delcurs.Access
inline x2gw::FMember& group_zd_group_member_delcurs_Access(group_zd_group_member_delcurs &curs) __attribute__((nothrow));
// Delete referred-to items.
// Deleted pointed-to item.
// func:x2gw.FGroup.c_leader.Cascdel
void                 c_leader_Cascdel(x2gw::FGroup& group) __attribute__((nothrow));
// Insert row into pointer index. Return final membership status.
// func:x2gw.FGroup.c_leader.InsertMaybe
inline bool          c_leader_InsertMaybe(x2gw::FGroup& group, x2gw::FMember& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FGroup.c_leader.Remove
inline void          c_leader_Remove(x2gw::FGroup& group, x2gw::FMember& row) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FGwport.base.CopyOut
void                 gwport_CopyOut(x2gw::FGwport &row, x2db::Gwport &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FGwport.base.CopyIn
void                 gwport_CopyIn(x2gw::FGwport &row, x2db::Gwport &in) __attribute__((nothrow));
// func:x2gw.FGwport.proc.Get
algo::Smallstr50     proc_Get(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FGwport.topo.Get
algo::Smallstr50     topo_Get(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FGwport.nodeno.Get
i32                  nodeno_Get(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FGwport.gwproto.Get
algo::Smallstr50     gwproto_Get(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FGwport.suffix.Get
algo::Smallstr50     suffix_Get(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow));
// Delete all elements in the linked list.
// func:x2gw.FGwport.zd_gwport_conn.Cascdel
void                 zd_gwport_conn_Cascdel(x2gw::FGwport& gwport) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FGwport.zd_gwport_conn.EmptyQ
inline bool          zd_gwport_conn_EmptyQ(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FGwport.zd_gwport_conn.First
inline x2gw::FConn*  zd_gwport_conn_First(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FGwport.zd_gwport_conn.InLlistQ
inline bool          zd_gwport_conn_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FGwport.zd_gwport_conn.Insert
void                 zd_gwport_conn_Insert(x2gw::FGwport& gwport, x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FGwport.zd_gwport_conn.Last
inline x2gw::FConn*  zd_gwport_conn_Last(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FGwport.zd_gwport_conn.N
inline i32           zd_gwport_conn_N(const x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FGwport.zd_gwport_conn.Next
inline x2gw::FConn*  zd_gwport_conn_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FGwport.zd_gwport_conn.Prev
inline x2gw::FConn*  zd_gwport_conn_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FGwport.zd_gwport_conn.Remove
void                 zd_gwport_conn_Remove(x2gw::FGwport& gwport, x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FGwport.zd_gwport_conn.RemoveAll
void                 zd_gwport_conn_RemoveAll(x2gw::FGwport& gwport) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FGwport.zd_gwport_conn.RemoveFirst
x2gw::FConn*         zd_gwport_conn_RemoveFirst(x2gw::FGwport& gwport) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FGwport.zd_gwport_conn.qLast
inline x2gw::FConn&  zd_gwport_conn_qLast(x2gw::FGwport& gwport) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FGwport.zd_gwport_conn_curs.Reset
inline void          gwport_zd_gwport_conn_curs_Reset(gwport_zd_gwport_conn_curs &curs, x2gw::FGwport &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FGwport.zd_gwport_conn_curs.ValidQ
inline bool          gwport_zd_gwport_conn_curs_ValidQ(gwport_zd_gwport_conn_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FGwport.zd_gwport_conn_curs.Next
inline void          gwport_zd_gwport_conn_curs_Next(gwport_zd_gwport_conn_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FGwport.zd_gwport_conn_curs.Access
inline x2gw::FConn&  gwport_zd_gwport_conn_curs_Access(gwport_zd_gwport_conn_curs &curs) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field ssl_ctx of x2gw::FGwport
// func:x2gw.FGwport.ssl_ctx.Cleanup
// this function is 'extrn' and implemented by user
void                 ssl_ctx_Cleanup(x2gw::FGwport& gwport) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FGwproto.base.CopyOut
void                 gwproto_CopyOut(x2gw::FGwproto &row, x2db::Gwproto &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FGwproto.base.CopyIn
void                 gwproto_CopyIn(x2gw::FGwproto &row, x2db::Gwproto &in) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FIntf.base.CopyOut
void                 intf_CopyOut(x2gw::FIntf &row, x2::Intf &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FIntf.base.CopyIn
void                 intf_CopyIn(x2gw::FIntf &row, x2::Intf &in) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FKafkaAclResource.zd_acl.Cascdel
void                 zd_acl_Cascdel(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FKafkaAclResource.zd_acl.EmptyQ
inline bool          zd_acl_EmptyQ(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FKafkaAclResource.zd_acl.First
inline x2gw::FKafkaAcl* zd_acl_First(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FKafkaAclResource.zd_acl.InLlistQ
inline bool          zd_acl_InLlistQ(x2gw::FKafkaAcl& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FKafkaAclResource.zd_acl.Insert
void                 zd_acl_Insert(x2gw::FKafkaAclResource& kafka_acl_resource, x2gw::FKafkaAcl& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FKafkaAclResource.zd_acl.Last
inline x2gw::FKafkaAcl* zd_acl_Last(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FKafkaAclResource.zd_acl.N
inline i32           zd_acl_N(const x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FKafkaAclResource.zd_acl.Next
inline x2gw::FKafkaAcl* zd_acl_Next(x2gw::FKafkaAcl &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FKafkaAclResource.zd_acl.Prev
inline x2gw::FKafkaAcl* zd_acl_Prev(x2gw::FKafkaAcl &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FKafkaAclResource.zd_acl.Remove
void                 zd_acl_Remove(x2gw::FKafkaAclResource& kafka_acl_resource, x2gw::FKafkaAcl& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FKafkaAclResource.zd_acl.RemoveAll
void                 zd_acl_RemoveAll(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FKafkaAclResource.zd_acl.RemoveFirst
x2gw::FKafkaAcl*     zd_acl_RemoveFirst(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FKafkaAclResource.zd_acl.qLast
inline x2gw::FKafkaAcl& zd_acl_qLast(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FKafkaAclResource.zd_acl_curs.Reset
inline void          kafka_acl_resource_zd_acl_curs_Reset(kafka_acl_resource_zd_acl_curs &curs, x2gw::FKafkaAclResource &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FKafkaAclResource.zd_acl_curs.ValidQ
inline bool          kafka_acl_resource_zd_acl_curs_ValidQ(kafka_acl_resource_zd_acl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FKafkaAclResource.zd_acl_curs.Next
inline void          kafka_acl_resource_zd_acl_curs_Next(kafka_acl_resource_zd_acl_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FKafkaAclResource.zd_acl_curs.Access
inline x2gw::FKafkaAcl& kafka_acl_resource_zd_acl_curs_Access(kafka_acl_resource_zd_acl_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FKafkaAclResource.zd_acl_delcurs.Reset
inline void          kafka_acl_resource_zd_acl_delcurs_Reset(kafka_acl_resource_zd_acl_delcurs &curs, x2gw::FKafkaAclResource &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FKafkaAclResource.zd_acl_delcurs.ValidQ
inline bool          kafka_acl_resource_zd_acl_delcurs_ValidQ(kafka_acl_resource_zd_acl_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FKafkaAclResource.zd_acl_delcurs.Next
inline void          kafka_acl_resource_zd_acl_delcurs_Next(kafka_acl_resource_zd_acl_delcurs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FKafkaAclResource.zd_acl_delcurs.Access
inline x2gw::FKafkaAcl& kafka_acl_resource_zd_acl_delcurs_Access(kafka_acl_resource_zd_acl_delcurs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.Cascdel
void                 zd_kafka_fetch_fetch_Cascdel(x2gw::FKafkaFetch& kafka_fetch) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.EmptyQ
inline bool          zd_kafka_fetch_fetch_EmptyQ(x2gw::FKafkaFetch& kafka_fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.First
inline x2gw::FFetch* zd_kafka_fetch_fetch_First(x2gw::FKafkaFetch& kafka_fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.InLlistQ
inline bool          zd_kafka_fetch_fetch_InLlistQ(x2gw::FFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.Insert
void                 zd_kafka_fetch_fetch_Insert(x2gw::FKafkaFetch& kafka_fetch, x2gw::FFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.Last
inline x2gw::FFetch* zd_kafka_fetch_fetch_Last(x2gw::FKafkaFetch& kafka_fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.N
inline i32           zd_kafka_fetch_fetch_N(const x2gw::FKafkaFetch& kafka_fetch) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.Next
inline x2gw::FFetch* zd_kafka_fetch_fetch_Next(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.Prev
inline x2gw::FFetch* zd_kafka_fetch_fetch_Prev(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.Remove
void                 zd_kafka_fetch_fetch_Remove(x2gw::FKafkaFetch& kafka_fetch, x2gw::FFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.RemoveAll
void                 zd_kafka_fetch_fetch_RemoveAll(x2gw::FKafkaFetch& kafka_fetch) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.RemoveFirst
x2gw::FFetch*        zd_kafka_fetch_fetch_RemoveFirst(x2gw::FKafkaFetch& kafka_fetch) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch.qLast
inline x2gw::FFetch& zd_kafka_fetch_fetch_qLast(x2gw::FKafkaFetch& kafka_fetch) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch_curs.Reset
inline void          kafka_fetch_zd_kafka_fetch_fetch_curs_Reset(kafka_fetch_zd_kafka_fetch_fetch_curs &curs, x2gw::FKafkaFetch &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch_curs.ValidQ
inline bool          kafka_fetch_zd_kafka_fetch_fetch_curs_ValidQ(kafka_fetch_zd_kafka_fetch_fetch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch_curs.Next
inline void          kafka_fetch_zd_kafka_fetch_fetch_curs_Next(kafka_fetch_zd_kafka_fetch_fetch_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FKafkaFetch.zd_kafka_fetch_fetch_curs.Access
inline x2gw::FFetch& kafka_fetch_zd_kafka_fetch_fetch_curs_Access(kafka_fetch_zd_kafka_fetch_fetch_curs &curs) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field p_group of x2gw::FMember
// func:x2gw.FMember.p_group.Cleanup
// this function is 'extrn' and implemented by user
void                 p_group_Cleanup(x2gw::FMember& member) __attribute__((nothrow));
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:x2gw.FMember.protocol.Addary
algo::aryptr<x2gw::MemberProtocol> protocol_Addary(x2gw::FMember& member, algo::aryptr<x2gw::MemberProtocol> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:x2gw.FMember.protocol.Alloc
x2gw::MemberProtocol& protocol_Alloc(x2gw::FMember& member) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:x2gw.FMember.protocol.AllocAt
x2gw::MemberProtocol& protocol_AllocAt(x2gw::FMember& member, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:x2gw.FMember.protocol.AllocN
algo::aryptr<x2gw::MemberProtocol> protocol_AllocN(x2gw::FMember& member, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the given position of the array, return pointer to inserted elements
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:x2gw.FMember.protocol.AllocNAt
algo::aryptr<x2gw::MemberProtocol> protocol_AllocNAt(x2gw::FMember& member, int n_elems, int at) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FMember.protocol.EmptyQ
inline bool          protocol_EmptyQ(x2gw::FMember& member) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:x2gw.FMember.protocol.Find
inline x2gw::MemberProtocol* protocol_Find(x2gw::FMember& member, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:x2gw.FMember.protocol.Getary
inline algo::aryptr<x2gw::MemberProtocol> protocol_Getary(const x2gw::FMember& member) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:x2gw.FMember.protocol.Last
inline x2gw::MemberProtocol* protocol_Last(x2gw::FMember& member) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:x2gw.FMember.protocol.Max
inline i32           protocol_Max(x2gw::FMember& member) __attribute__((nothrow));
// Return number of items in the array
// func:x2gw.FMember.protocol.N
inline i32           protocol_N(const x2gw::FMember& member) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:x2gw.FMember.protocol.Remove
void                 protocol_Remove(x2gw::FMember& member, u32 i) __attribute__((nothrow));
// func:x2gw.FMember.protocol.RemoveAll
void                 protocol_RemoveAll(x2gw::FMember& member) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:x2gw.FMember.protocol.RemoveLast
void                 protocol_RemoveLast(x2gw::FMember& member) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:x2gw.FMember.protocol.Reserve
inline void          protocol_Reserve(x2gw::FMember& member, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:x2gw.FMember.protocol.AbsReserve
void                 protocol_AbsReserve(x2gw::FMember& member, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:x2gw.FMember.protocol.Setary
void                 protocol_Setary(x2gw::FMember& member, x2gw::FMember &rhs) __attribute__((nothrow));
// Copy specified array into protocol, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:x2gw.FMember.protocol.Setary2
void                 protocol_Setary(x2gw::FMember& member, const algo::aryptr<x2gw::MemberProtocol> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:x2gw.FMember.protocol.qFind
inline x2gw::MemberProtocol& protocol_qFind(x2gw::FMember& member, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:x2gw.FMember.protocol.qLast
inline x2gw::MemberProtocol& protocol_qLast(x2gw::FMember& member) __attribute__((nothrow));
// Return row id of specified element
// func:x2gw.FMember.protocol.rowid_Get
inline u64           protocol_rowid_Get(x2gw::FMember& member, x2gw::MemberProtocol &elem) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FMember.protocol_curs.Next
inline void          member_protocol_curs_Next(member_protocol_curs &curs) __attribute__((nothrow));
// func:x2gw.FMember.protocol_curs.Reset
inline void          member_protocol_curs_Reset(member_protocol_curs &curs, x2gw::FMember &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FMember.protocol_curs.ValidQ
inline bool          member_protocol_curs_ValidQ(member_protocol_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FMember.protocol_curs.Access
inline x2gw::MemberProtocol& member_protocol_curs_Access(member_protocol_curs &curs) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:x2gw.FMember.protocol.AllocNVal
algo::aryptr<x2gw::MemberProtocol> protocol_AllocNVal(x2gw::FMember& member, int n_elems, const x2gw::MemberProtocol& val) __attribute__((nothrow));
// Insert array at specific position
// Insert N elements at specified index. Index must be in range or a fatal error occurs.Reserve space, and move existing elements to end.If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:x2gw.FMember.protocol.Insary
void                 protocol_Insary(x2gw::FMember& member, algo::aryptr<x2gw::MemberProtocol> rhs, int at) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FMetric.zd_metric_moentry.EmptyQ
inline bool          zd_metric_moentry_EmptyQ(x2gw::FMetric& metric) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FMetric.zd_metric_moentry.First
inline x2gw::FMoentry* zd_metric_moentry_First(x2gw::FMetric& metric) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FMetric.zd_metric_moentry.InLlistQ
inline bool          zd_metric_moentry_InLlistQ(x2gw::FMoentry& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FMetric.zd_metric_moentry.Insert
void                 zd_metric_moentry_Insert(x2gw::FMetric& metric, x2gw::FMoentry& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FMetric.zd_metric_moentry.Last
inline x2gw::FMoentry* zd_metric_moentry_Last(x2gw::FMetric& metric) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FMetric.zd_metric_moentry.N
inline i32           zd_metric_moentry_N(const x2gw::FMetric& metric) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FMetric.zd_metric_moentry.Next
inline x2gw::FMoentry* zd_metric_moentry_Next(x2gw::FMoentry &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FMetric.zd_metric_moentry.Prev
inline x2gw::FMoentry* zd_metric_moentry_Prev(x2gw::FMoentry &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FMetric.zd_metric_moentry.Remove
void                 zd_metric_moentry_Remove(x2gw::FMetric& metric, x2gw::FMoentry& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FMetric.zd_metric_moentry.RemoveAll
void                 zd_metric_moentry_RemoveAll(x2gw::FMetric& metric) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FMetric.zd_metric_moentry.RemoveFirst
x2gw::FMoentry*      zd_metric_moentry_RemoveFirst(x2gw::FMetric& metric) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FMetric.zd_metric_moentry.qLast
inline x2gw::FMoentry& zd_metric_moentry_qLast(x2gw::FMetric& metric) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FMetric.zd_metric_moentry_curs.Reset
inline void          metric_zd_metric_moentry_curs_Reset(metric_zd_metric_moentry_curs &curs, x2gw::FMetric &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FMetric.zd_metric_moentry_curs.ValidQ
inline bool          metric_zd_metric_moentry_curs_ValidQ(metric_zd_metric_moentry_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FMetric.zd_metric_moentry_curs.Next
inline void          metric_zd_metric_moentry_curs_Next(metric_zd_metric_moentry_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FMetric.zd_metric_moentry_curs.Access
inline x2gw::FMoentry& metric_zd_metric_moentry_curs_Access(metric_zd_metric_moentry_curs &curs) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FProc.base.CopyOut
void                 proc_CopyOut(x2gw::FProc &row, x2db::Proc &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FProc.base.CopyIn
void                 proc_CopyIn(x2gw::FProc &row, x2db::Proc &in) __attribute__((nothrow));
// func:x2gw.FProc.topo.Get
algo::Smallstr50     topo_Get(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FProc.proctype.Get
algo::Smallstr16     proctype_Get(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FProc.node.Get
u16                  node_Get(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FProc.procidx.Get
u8                   procidx_Get(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow));
// func:x2gw.FProc.x2node.Get
algo::Smallstr50     x2node_Get(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:x2gw.FProc.zd_gwport.EmptyQ
inline bool          zd_gwport_EmptyQ(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FProc.zd_gwport.First
inline x2gw::FGwport* zd_gwport_First(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FProc.zd_gwport.InLlistQ
inline bool          zd_gwport_InLlistQ(x2gw::FGwport& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FProc.zd_gwport.Insert
void                 zd_gwport_Insert(x2gw::FProc& proc, x2gw::FGwport& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FProc.zd_gwport.Last
inline x2gw::FGwport* zd_gwport_Last(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FProc.zd_gwport.N
inline i32           zd_gwport_N(const x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FProc.zd_gwport.Next
inline x2gw::FGwport* zd_gwport_Next(x2gw::FGwport &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FProc.zd_gwport.Prev
inline x2gw::FGwport* zd_gwport_Prev(x2gw::FGwport &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FProc.zd_gwport.Remove
void                 zd_gwport_Remove(x2gw::FProc& proc, x2gw::FGwport& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FProc.zd_gwport.RemoveAll
void                 zd_gwport_RemoveAll(x2gw::FProc& proc) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FProc.zd_gwport.RemoveFirst
x2gw::FGwport*       zd_gwport_RemoveFirst(x2gw::FProc& proc) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FProc.zd_gwport.qLast
inline x2gw::FGwport& zd_gwport_qLast(x2gw::FProc& proc) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FProc.zd_gwport_curs.Reset
inline void          proc_zd_gwport_curs_Reset(proc_zd_gwport_curs &curs, x2gw::FProc &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FProc.zd_gwport_curs.ValidQ
inline bool          proc_zd_gwport_curs_ValidQ(proc_zd_gwport_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FProc.zd_gwport_curs.Next
inline void          proc_zd_gwport_curs_Next(proc_zd_gwport_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FProc.zd_gwport_curs.Access
inline x2gw::FGwport& proc_zd_gwport_curs_Access(proc_zd_gwport_curs &curs) __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.RespProduceOp.value.GetEnum
inline x2gw_RespProduceOpEnum value_GetEnum(const x2gw::RespProduceOp& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.RespProduceOp.value.SetEnum
inline void          value_SetEnum(x2gw::RespProduceOp& parent, x2gw_RespProduceOpEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.RespProduceOp.value.ToCstr
const char*          value_ToCstr(const x2gw::RespProduceOp& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.RespProduceOp.value.Print
void                 value_Print(const x2gw::RespProduceOp& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.RespProduceOp.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::RespProduceOp& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.RespProduceOp.value.SetStrptr
void                 value_SetStrptr(x2gw::RespProduceOp& parent, algo::strptr rhs, x2gw_RespProduceOpEnum dflt) __attribute__((nothrow));
// Invoke function by pointer
// func:x2gw.FProducer.h_ack.Call
inline void          h_ack_Call(x2gw::FProducer& producer, x2::AckMsg& arg) __attribute__((nothrow));
// Assign 0-argument hook with no context pointer
// func:x2gw.FProducer.h_ack.Set0
inline void          h_ack_Set0(x2gw::FProducer& producer, void (*fcn)() ) __attribute__((nothrow));
// Assign 1-argument hook with context pointer
// func:x2gw.FProducer.h_ack.Set1
template<class T> inline void h_ack_Set1(x2gw::FProducer& producer, T& ctx, void (*fcn)(T&) ) __attribute__((nothrow));
// Assign 2-argument hook with context pointer
// func:x2gw.FProducer.h_ack.Set2
template<class T> inline void h_ack_Set2(x2gw::FProducer& producer, T& ctx, void (*fcn)(T&, x2::AckMsg& arg) ) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field rsp of x2gw::FProducer
// func:x2gw.FProducer.rsp.Cleanup
// this function is 'extrn' and implemented by user
void                 rsp_Cleanup(x2gw::FProducer& producer) __attribute__((nothrow));
// Copy fields out of row
// func:x2gw.FSession.base.CopyOut
void                 session_CopyOut(x2gw::FSession &row, x2gw::Session &out) __attribute__((nothrow));
// Copy fields in to row
// func:x2gw.FSession.base.CopyIn
void                 session_CopyIn(x2gw::FSession &row, x2gw::Session &in) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.zd_session_fetch.Cascdel
void                 zd_session_fetch_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.zd_session_fetch.EmptyQ
inline bool          zd_session_fetch_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.zd_session_fetch.First
inline x2gw::FFetch* zd_session_fetch_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.zd_session_fetch.InLlistQ
inline bool          zd_session_fetch_InLlistQ(x2gw::FFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.zd_session_fetch.Insert
void                 zd_session_fetch_Insert(x2gw::FSession& session, x2gw::FFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.zd_session_fetch.Last
inline x2gw::FFetch* zd_session_fetch_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.zd_session_fetch.N
inline i32           zd_session_fetch_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.zd_session_fetch.Next
inline x2gw::FFetch* zd_session_fetch_Next(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.zd_session_fetch.Prev
inline x2gw::FFetch* zd_session_fetch_Prev(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.zd_session_fetch.Remove
void                 zd_session_fetch_Remove(x2gw::FSession& session, x2gw::FFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.zd_session_fetch.RemoveAll
void                 zd_session_fetch_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.zd_session_fetch.RemoveFirst
x2gw::FFetch*        zd_session_fetch_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.zd_session_fetch.qLast
inline x2gw::FFetch& zd_session_fetch_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_fetch_curs.Reset
inline void          session_zd_session_fetch_curs_Reset(session_zd_session_fetch_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_fetch_curs.ValidQ
inline bool          session_zd_session_fetch_curs_ValidQ(session_zd_session_fetch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_fetch_curs.Next
inline void          session_zd_session_fetch_curs_Next(session_zd_session_fetch_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_fetch_curs.Access
inline x2gw::FFetch& session_zd_session_fetch_curs_Access(session_zd_session_fetch_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_fetch_delcurs.Reset
inline void          session_zd_session_fetch_delcurs_Reset(session_zd_session_fetch_delcurs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_fetch_delcurs.ValidQ
inline bool          session_zd_session_fetch_delcurs_ValidQ(session_zd_session_fetch_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_fetch_delcurs.Next
inline void          session_zd_session_fetch_delcurs_Next(session_zd_session_fetch_delcurs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_fetch_delcurs.Access
inline x2gw::FFetch& session_zd_session_fetch_delcurs_Access(session_zd_session_fetch_delcurs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.zd_session_producer.Cascdel
void                 zd_session_producer_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.zd_session_producer.EmptyQ
inline bool          zd_session_producer_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.zd_session_producer.First
inline x2gw::FProducer* zd_session_producer_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.zd_session_producer.InLlistQ
inline bool          zd_session_producer_InLlistQ(x2gw::FProducer& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.zd_session_producer.Insert
void                 zd_session_producer_Insert(x2gw::FSession& session, x2gw::FProducer& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.zd_session_producer.Last
inline x2gw::FProducer* zd_session_producer_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.zd_session_producer.N
inline i32           zd_session_producer_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.zd_session_producer.Next
inline x2gw::FProducer* zd_session_producer_Next(x2gw::FProducer &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.zd_session_producer.Prev
inline x2gw::FProducer* zd_session_producer_Prev(x2gw::FProducer &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.zd_session_producer.Remove
void                 zd_session_producer_Remove(x2gw::FSession& session, x2gw::FProducer& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.zd_session_producer.RemoveAll
void                 zd_session_producer_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.zd_session_producer.RemoveFirst
x2gw::FProducer*     zd_session_producer_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.zd_session_producer.qLast
inline x2gw::FProducer& zd_session_producer_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_producer_curs.Reset
inline void          session_zd_session_producer_curs_Reset(session_zd_session_producer_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_producer_curs.ValidQ
inline bool          session_zd_session_producer_curs_ValidQ(session_zd_session_producer_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_producer_curs.Next
inline void          session_zd_session_producer_curs_Next(session_zd_session_producer_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_producer_curs.Access
inline x2gw::FProducer& session_zd_session_producer_curs_Access(session_zd_session_producer_curs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.zd_session_fetch_queue.Cascdel
void                 zd_session_fetch_queue_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.zd_session_fetch_queue.EmptyQ
inline bool          zd_session_fetch_queue_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.zd_session_fetch_queue.First
inline x2gw::FFetch* zd_session_fetch_queue_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.zd_session_fetch_queue.InLlistQ
inline bool          zd_session_fetch_queue_InLlistQ(x2gw::FFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.zd_session_fetch_queue.Insert
void                 zd_session_fetch_queue_Insert(x2gw::FSession& session, x2gw::FFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.zd_session_fetch_queue.Last
inline x2gw::FFetch* zd_session_fetch_queue_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.zd_session_fetch_queue.N
inline i32           zd_session_fetch_queue_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.zd_session_fetch_queue.Next
inline x2gw::FFetch* zd_session_fetch_queue_Next(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.zd_session_fetch_queue.Prev
inline x2gw::FFetch* zd_session_fetch_queue_Prev(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.zd_session_fetch_queue.Remove
void                 zd_session_fetch_queue_Remove(x2gw::FSession& session, x2gw::FFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.zd_session_fetch_queue.RemoveAll
void                 zd_session_fetch_queue_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.zd_session_fetch_queue.RemoveFirst
x2gw::FFetch*        zd_session_fetch_queue_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.zd_session_fetch_queue.qLast
inline x2gw::FFetch& zd_session_fetch_queue_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_fetch_queue_curs.Reset
inline void          session_zd_session_fetch_queue_curs_Reset(session_zd_session_fetch_queue_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_fetch_queue_curs.ValidQ
inline bool          session_zd_session_fetch_queue_curs_ValidQ(session_zd_session_fetch_queue_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_fetch_queue_curs.Next
inline void          session_zd_session_fetch_queue_curs_Next(session_zd_session_fetch_queue_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_fetch_queue_curs.Access
inline x2gw::FFetch& session_zd_session_fetch_queue_curs_Access(session_zd_session_fetch_queue_curs &curs) __attribute__((nothrow));
// Delete all rows reachable through the hash index
// func:x2gw.FSession.ind_produce_pi.Cascdel
void                 ind_produce_pi_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FSession.ind_produce_pi.EmptyQ
inline bool          ind_produce_pi_EmptyQ(x2gw::FSession& session) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FSession.ind_produce_pi.Find
x2gw::FProducer*     ind_produce_pi_Find(x2gw::FSession& session, mqtt::PacketIdentifier key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FSession.ind_produce_pi.FindX
x2gw::FProducer&     ind_produce_pi_FindX(x2gw::FSession& session, mqtt::PacketIdentifier key);
// Return number of items in the hash
// func:x2gw.FSession.ind_produce_pi.N
inline i32           ind_produce_pi_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FSession.ind_produce_pi.InsertMaybe
bool                 ind_produce_pi_InsertMaybe(x2gw::FSession& session, x2gw::FProducer& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FSession.ind_produce_pi.Remove
void                 ind_produce_pi_Remove(x2gw::FSession& session, x2gw::FProducer& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FSession.ind_produce_pi.Reserve
void                 ind_produce_pi_Reserve(x2gw::FSession& session, int n) __attribute__((nothrow));
// Delete all rows reachable through the hash index
// func:x2gw.FSession.ind_unacked.Cascdel
void                 ind_unacked_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FSession.ind_unacked.EmptyQ
inline bool          ind_unacked_EmptyQ(x2gw::FSession& session) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FSession.ind_unacked.Find
x2gw::FPacket*       ind_unacked_Find(x2gw::FSession& session, mqtt::PacketIdentifier key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FSession.ind_unacked.FindX
x2gw::FPacket&       ind_unacked_FindX(x2gw::FSession& session, mqtt::PacketIdentifier key);
// Return number of items in the hash
// func:x2gw.FSession.ind_unacked.N
inline i32           ind_unacked_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FSession.ind_unacked.InsertMaybe
bool                 ind_unacked_InsertMaybe(x2gw::FSession& session, x2gw::FPacket& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FSession.ind_unacked.Remove
void                 ind_unacked_Remove(x2gw::FSession& session, x2gw::FPacket& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FSession.ind_unacked.Reserve
void                 ind_unacked_Reserve(x2gw::FSession& session, int n) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.zd_session_packet.Cascdel
void                 zd_session_packet_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.zd_session_packet.EmptyQ
inline bool          zd_session_packet_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.zd_session_packet.First
inline x2gw::FPacket* zd_session_packet_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.zd_session_packet.InLlistQ
inline bool          zd_session_packet_InLlistQ(x2gw::FPacket& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.zd_session_packet.Insert
void                 zd_session_packet_Insert(x2gw::FSession& session, x2gw::FPacket& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.zd_session_packet.Last
inline x2gw::FPacket* zd_session_packet_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.zd_session_packet.N
inline i32           zd_session_packet_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.zd_session_packet.Next
inline x2gw::FPacket* zd_session_packet_Next(x2gw::FPacket &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.zd_session_packet.Prev
inline x2gw::FPacket* zd_session_packet_Prev(x2gw::FPacket &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.zd_session_packet.Remove
void                 zd_session_packet_Remove(x2gw::FSession& session, x2gw::FPacket& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.zd_session_packet.RemoveAll
void                 zd_session_packet_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.zd_session_packet.RemoveFirst
x2gw::FPacket*       zd_session_packet_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.zd_session_packet.qLast
inline x2gw::FPacket& zd_session_packet_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_packet_curs.Reset
inline void          session_zd_session_packet_curs_Reset(session_zd_session_packet_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_packet_curs.ValidQ
inline bool          session_zd_session_packet_curs_ValidQ(session_zd_session_packet_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_packet_curs.Next
inline void          session_zd_session_packet_curs_Next(session_zd_session_packet_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_packet_curs.Access
inline x2gw::FPacket& session_zd_session_packet_curs_Access(session_zd_session_packet_curs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.cd_session_fetch_queue.Cascdel
void                 cd_session_fetch_queue_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.cd_session_fetch_queue.EmptyQ
inline bool          cd_session_fetch_queue_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.cd_session_fetch_queue.First
inline x2gw::FFetch* cd_session_fetch_queue_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.cd_session_fetch_queue.InLlistQ
inline bool          cd_session_fetch_queue_InLlistQ(x2gw::FFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.cd_session_fetch_queue.Insert
void                 cd_session_fetch_queue_Insert(x2gw::FSession& session, x2gw::FFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.cd_session_fetch_queue.Last
inline x2gw::FFetch* cd_session_fetch_queue_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.cd_session_fetch_queue.N
inline i32           cd_session_fetch_queue_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.cd_session_fetch_queue.Next
inline x2gw::FFetch* cd_session_fetch_queue_Next(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.cd_session_fetch_queue.Prev
inline x2gw::FFetch* cd_session_fetch_queue_Prev(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.cd_session_fetch_queue.Remove
void                 cd_session_fetch_queue_Remove(x2gw::FSession& session, x2gw::FFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.cd_session_fetch_queue.RemoveAll
void                 cd_session_fetch_queue_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.cd_session_fetch_queue.RemoveFirst
x2gw::FFetch*        cd_session_fetch_queue_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:x2gw.FSession.cd_session_fetch_queue.RotateFirst
x2gw::FFetch*        cd_session_fetch_queue_RotateFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.cd_session_fetch_queue.qLast
inline x2gw::FFetch& cd_session_fetch_queue_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.cd_session_fetch_queue_curs.Reset
inline void          session_cd_session_fetch_queue_curs_Reset(session_cd_session_fetch_queue_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.cd_session_fetch_queue_curs.ValidQ
inline bool          session_cd_session_fetch_queue_curs_ValidQ(session_cd_session_fetch_queue_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.cd_session_fetch_queue_curs.Next
inline void          session_cd_session_fetch_queue_curs_Next(session_cd_session_fetch_queue_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.cd_session_fetch_queue_curs.Access
inline x2gw::FFetch& session_cd_session_fetch_queue_curs_Access(session_cd_session_fetch_queue_curs &curs) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field c_session_conn of x2gw::FSession
// func:x2gw.FSession.c_session_conn.Cleanup
// this function is 'extrn' and implemented by user
void                 c_session_conn_Cleanup(x2gw::FSession& session) __attribute__((nothrow));
// Delete referred-to items.
// Deleted pointed-to item.
// func:x2gw.FSession.c_session_conn.Cascdel
void                 c_session_conn_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Insert row into pointer index. Return final membership status.
// func:x2gw.FSession.c_session_conn.InsertMaybe
inline bool          c_session_conn_InsertMaybe(x2gw::FSession& session, x2gw::FSessionConn& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.c_session_conn.Remove
inline void          c_session_conn_Remove(x2gw::FSession& session, x2gw::FSessionConn& row) __attribute__((nothrow));
// Delete all rows reachable through the hash index
// func:x2gw.FSession.ind_stream_user_id.Cascdel
void                 ind_stream_user_id_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if hash is empty
// func:x2gw.FSession.ind_stream_user_id.EmptyQ
inline bool          ind_stream_user_id_EmptyQ(x2gw::FSession& session) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:x2gw.FSession.ind_stream_user_id.Find
x2gw::FOpenStream*   ind_stream_user_id_Find(x2gw::FSession& session, x2::StreamId key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:x2gw.FSession.ind_stream_user_id.FindX
x2gw::FOpenStream&   ind_stream_user_id_FindX(x2gw::FSession& session, x2::StreamId key);
// Return number of items in the hash
// func:x2gw.FSession.ind_stream_user_id.N
inline i32           ind_stream_user_id_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:x2gw.FSession.ind_stream_user_id.InsertMaybe
bool                 ind_stream_user_id_InsertMaybe(x2gw::FSession& session, x2gw::FOpenStream& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:x2gw.FSession.ind_stream_user_id.Remove
void                 ind_stream_user_id_Remove(x2gw::FSession& session, x2gw::FOpenStream& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:x2gw.FSession.ind_stream_user_id.Reserve
void                 ind_stream_user_id_Reserve(x2gw::FSession& session, int n) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.zd_session_kafka_fetch.Cascdel
void                 zd_session_kafka_fetch_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.zd_session_kafka_fetch.EmptyQ
inline bool          zd_session_kafka_fetch_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.zd_session_kafka_fetch.First
inline x2gw::FKafkaFetch* zd_session_kafka_fetch_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.zd_session_kafka_fetch.InLlistQ
inline bool          zd_session_kafka_fetch_InLlistQ(x2gw::FKafkaFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.zd_session_kafka_fetch.Insert
void                 zd_session_kafka_fetch_Insert(x2gw::FSession& session, x2gw::FKafkaFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.zd_session_kafka_fetch.Last
inline x2gw::FKafkaFetch* zd_session_kafka_fetch_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.zd_session_kafka_fetch.N
inline i32           zd_session_kafka_fetch_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.zd_session_kafka_fetch.Next
inline x2gw::FKafkaFetch* zd_session_kafka_fetch_Next(x2gw::FKafkaFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.zd_session_kafka_fetch.Prev
inline x2gw::FKafkaFetch* zd_session_kafka_fetch_Prev(x2gw::FKafkaFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.zd_session_kafka_fetch.Remove
void                 zd_session_kafka_fetch_Remove(x2gw::FSession& session, x2gw::FKafkaFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.zd_session_kafka_fetch.RemoveAll
void                 zd_session_kafka_fetch_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.zd_session_kafka_fetch.RemoveFirst
x2gw::FKafkaFetch*   zd_session_kafka_fetch_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.zd_session_kafka_fetch.qLast
inline x2gw::FKafkaFetch& zd_session_kafka_fetch_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_kafka_fetch_curs.Reset
inline void          session_zd_session_kafka_fetch_curs_Reset(session_zd_session_kafka_fetch_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_kafka_fetch_curs.ValidQ
inline bool          session_zd_session_kafka_fetch_curs_ValidQ(session_zd_session_kafka_fetch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_kafka_fetch_curs.Next
inline void          session_zd_session_kafka_fetch_curs_Next(session_zd_session_kafka_fetch_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_kafka_fetch_curs.Access
inline x2gw::FKafkaFetch& session_zd_session_kafka_fetch_curs_Access(session_zd_session_kafka_fetch_curs &curs) __attribute__((nothrow));
// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field zd_session_member of x2gw::FSession
// func:x2gw.FSession.zd_session_member.Cleanup
// this function is 'extrn' and implemented by user
void                 zd_session_member_Cleanup(x2gw::FSession& session) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FSession.zd_session_member.Cascdel
void                 zd_session_member_Cascdel(x2gw::FSession& session) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FSession.zd_session_member.EmptyQ
inline bool          zd_session_member_EmptyQ(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FSession.zd_session_member.First
inline x2gw::FMember* zd_session_member_First(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FSession.zd_session_member.InLlistQ
inline bool          zd_session_member_InLlistQ(x2gw::FMember& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FSession.zd_session_member.Insert
void                 zd_session_member_Insert(x2gw::FSession& session, x2gw::FMember& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FSession.zd_session_member.Last
inline x2gw::FMember* zd_session_member_Last(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FSession.zd_session_member.N
inline i32           zd_session_member_N(const x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FSession.zd_session_member.Next
inline x2gw::FMember* zd_session_member_Next(x2gw::FMember &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FSession.zd_session_member.Prev
inline x2gw::FMember* zd_session_member_Prev(x2gw::FMember &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FSession.zd_session_member.Remove
void                 zd_session_member_Remove(x2gw::FSession& session, x2gw::FMember& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FSession.zd_session_member.RemoveAll
void                 zd_session_member_RemoveAll(x2gw::FSession& session) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FSession.zd_session_member.RemoveFirst
x2gw::FMember*       zd_session_member_RemoveFirst(x2gw::FSession& session) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FSession.zd_session_member.qLast
inline x2gw::FMember& zd_session_member_qLast(x2gw::FSession& session) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_member_curs.Reset
inline void          session_zd_session_member_curs_Reset(session_zd_session_member_curs &curs, x2gw::FSession &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FSession.zd_session_member_curs.ValidQ
inline bool          session_zd_session_member_curs_ValidQ(session_zd_session_member_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FSession.zd_session_member_curs.Next
inline void          session_zd_session_member_curs_Next(session_zd_session_member_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FSession.zd_session_member_curs.Access
inline x2gw::FMember& session_zd_session_member_curs_Access(session_zd_session_member_curs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FStream.zd_stream_fetch.Cascdel
void                 zd_stream_fetch_Cascdel(x2gw::FStream& stream) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FStream.zd_stream_fetch.EmptyQ
inline bool          zd_stream_fetch_EmptyQ(x2gw::FStream& stream) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FStream.zd_stream_fetch.First
inline x2gw::FFetch* zd_stream_fetch_First(x2gw::FStream& stream) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FStream.zd_stream_fetch.InLlistQ
inline bool          zd_stream_fetch_InLlistQ(x2gw::FFetch& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FStream.zd_stream_fetch.Insert
void                 zd_stream_fetch_Insert(x2gw::FStream& stream, x2gw::FFetch& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FStream.zd_stream_fetch.Last
inline x2gw::FFetch* zd_stream_fetch_Last(x2gw::FStream& stream) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FStream.zd_stream_fetch.N
inline i32           zd_stream_fetch_N(const x2gw::FStream& stream) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FStream.zd_stream_fetch.Next
inline x2gw::FFetch* zd_stream_fetch_Next(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FStream.zd_stream_fetch.Prev
inline x2gw::FFetch* zd_stream_fetch_Prev(x2gw::FFetch &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FStream.zd_stream_fetch.Remove
void                 zd_stream_fetch_Remove(x2gw::FStream& stream, x2gw::FFetch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FStream.zd_stream_fetch.RemoveAll
void                 zd_stream_fetch_RemoveAll(x2gw::FStream& stream) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FStream.zd_stream_fetch.RemoveFirst
x2gw::FFetch*        zd_stream_fetch_RemoveFirst(x2gw::FStream& stream) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FStream.zd_stream_fetch.qLast
inline x2gw::FFetch& zd_stream_fetch_qLast(x2gw::FStream& stream) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FStream.zd_stream_fetch_curs.Reset
inline void          stream_zd_stream_fetch_curs_Reset(stream_zd_stream_fetch_curs &curs, x2gw::FStream &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FStream.zd_stream_fetch_curs.ValidQ
inline bool          stream_zd_stream_fetch_curs_ValidQ(stream_zd_stream_fetch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FStream.zd_stream_fetch_curs.Next
inline void          stream_zd_stream_fetch_curs_Next(stream_zd_stream_fetch_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FStream.zd_stream_fetch_curs.Access
inline x2gw::FFetch& stream_zd_stream_fetch_curs_Access(stream_zd_stream_fetch_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FStream.zd_stream_fetch_delcurs.Reset
inline void          stream_zd_stream_fetch_delcurs_Reset(stream_zd_stream_fetch_delcurs &curs, x2gw::FStream &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FStream.zd_stream_fetch_delcurs.ValidQ
inline bool          stream_zd_stream_fetch_delcurs_ValidQ(stream_zd_stream_fetch_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FStream.zd_stream_fetch_delcurs.Next
inline void          stream_zd_stream_fetch_delcurs_Next(stream_zd_stream_fetch_delcurs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FStream.zd_stream_fetch_delcurs.Access
inline x2gw::FFetch& stream_zd_stream_fetch_delcurs_Access(stream_zd_stream_fetch_delcurs &curs) __attribute__((nothrow));
// Delete all elements in the linked list.
// func:x2gw.FUser.zd_user_conn.Cascdel
void                 zd_user_conn_Cascdel(x2gw::FUser& user) __attribute__((nothrow));
// Return true if index is empty
// func:x2gw.FUser.zd_user_conn.EmptyQ
inline bool          zd_user_conn_EmptyQ(x2gw::FUser& user) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:x2gw.FUser.zd_user_conn.First
inline x2gw::FConn*  zd_user_conn_First(x2gw::FUser& user) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:x2gw.FUser.zd_user_conn.InLlistQ
inline bool          zd_user_conn_InLlistQ(x2gw::FConn& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:x2gw.FUser.zd_user_conn.Insert
void                 zd_user_conn_Insert(x2gw::FUser& user, x2gw::FConn& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:x2gw.FUser.zd_user_conn.Last
inline x2gw::FConn*  zd_user_conn_Last(x2gw::FUser& user) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:x2gw.FUser.zd_user_conn.N
inline i32           zd_user_conn_N(const x2gw::FUser& user) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:x2gw.FUser.zd_user_conn.Next
inline x2gw::FConn*  zd_user_conn_Next(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:x2gw.FUser.zd_user_conn.Prev
inline x2gw::FConn*  zd_user_conn_Prev(x2gw::FConn &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:x2gw.FUser.zd_user_conn.Remove
void                 zd_user_conn_Remove(x2gw::FUser& user, x2gw::FConn& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:x2gw.FUser.zd_user_conn.RemoveAll
void                 zd_user_conn_RemoveAll(x2gw::FUser& user) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:x2gw.FUser.zd_user_conn.RemoveFirst
x2gw::FConn*         zd_user_conn_RemoveFirst(x2gw::FUser& user) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:x2gw.FUser.zd_user_conn.qLast
inline x2gw::FConn&  zd_user_conn_qLast(x2gw::FUser& user) __attribute__((__warn_unused_result__, nothrow));
// cursor points to valid item
// func:x2gw.FUser.zd_user_conn_curs.Reset
inline void          user_zd_user_conn_curs_Reset(user_zd_user_conn_curs &curs, x2gw::FUser &parent) __attribute__((nothrow));
// cursor points to valid item
// func:x2gw.FUser.zd_user_conn_curs.ValidQ
inline bool          user_zd_user_conn_curs_ValidQ(user_zd_user_conn_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:x2gw.FUser.zd_user_conn_curs.Next
inline void          user_zd_user_conn_curs_Next(user_zd_user_conn_curs &curs) __attribute__((nothrow));
// item access
// func:x2gw.FUser.zd_user_conn_curs.Access
inline x2gw::FConn&  user_zd_user_conn_curs_Access(user_zd_user_conn_curs &curs) __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.FieldId.value.GetEnum
inline x2gw_FieldIdEnum value_GetEnum(const x2gw::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.FieldId.value.SetEnum
inline void          value_SetEnum(x2gw::FieldId& parent, x2gw_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.FieldId.value.ToCstr
const char*          value_ToCstr(const x2gw::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.FieldId.value.Print
void                 value_Print(const x2gw::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.FieldId.value.SetStrptr
void                 value_SetStrptr(x2gw::FieldId& parent, algo::strptr rhs, x2gw_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:x2gw.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(x2gw::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// func:x2gw.FieldId.value.Cast
inline               x2gw::FieldId::operator x2gw_FieldIdEnum() const __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.InCase.value.GetEnum
inline x2gw_InCaseEnum value_GetEnum(const x2gw::InCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.InCase.value.SetEnum
inline void          value_SetEnum(x2gw::InCase& parent, x2gw_InCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.InCase.value.ToCstr
const char*          value_ToCstr(const x2gw::InCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.InCase.value.Print
void                 value_Print(const x2gw::InCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.InCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::InCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.InCase.value.SetStrptr
void                 value_SetStrptr(x2gw::InCase& parent, algo::strptr rhs, x2gw_InCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:x2gw.InCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(x2gw::InCase& parent, algo::strptr rhs) __attribute__((nothrow));
// func:x2gw.InCase.value.Cast
inline               x2gw::InCase::operator x2gw_InCaseEnum() const __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.KafkaInCase.value.GetEnum
inline x2gw_KafkaInCaseEnum value_GetEnum(const x2gw::KafkaInCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.KafkaInCase.value.SetEnum
inline void          value_SetEnum(x2gw::KafkaInCase& parent, x2gw_KafkaInCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.KafkaInCase.value.ToCstr
const char*          value_ToCstr(const x2gw::KafkaInCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.KafkaInCase.value.Print
void                 value_Print(const x2gw::KafkaInCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.KafkaInCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::KafkaInCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.KafkaInCase.value.SetStrptr
void                 value_SetStrptr(x2gw::KafkaInCase& parent, algo::strptr rhs, x2gw_KafkaInCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:x2gw.KafkaInCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(x2gw::KafkaInCase& parent, algo::strptr rhs) __attribute__((nothrow));
// func:x2gw.KafkaInCase.value.Cast
inline               x2gw::KafkaInCase::operator x2gw_KafkaInCaseEnum() const __attribute__((nothrow));
// func:x2gw.RespInCase.value.Cast
inline               x2gw::RespInCase::operator u32() const __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.TableId.value.GetEnum
inline x2gw_TableIdEnum value_GetEnum(const x2gw::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.TableId.value.SetEnum
inline void          value_SetEnum(x2gw::TableId& parent, x2gw_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.TableId.value.ToCstr
const char*          value_ToCstr(const x2gw::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.TableId.value.Print
void                 value_Print(const x2gw::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.TableId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.TableId.value.SetStrptr
void                 value_SetStrptr(x2gw::TableId& parent, algo::strptr rhs, x2gw_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:x2gw.TableId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(x2gw::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// func:x2gw.TableId.value.Cast
inline               x2gw::TableId::operator x2gw_TableIdEnum() const __attribute__((nothrow));
// Get value of field as enum type
// func:x2gw.UserInCase.value.GetEnum
inline x2gw_UserInCaseEnum value_GetEnum(const x2gw::UserInCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:x2gw.UserInCase.value.SetEnum
inline void          value_SetEnum(x2gw::UserInCase& parent, x2gw_UserInCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:x2gw.UserInCase.value.ToCstr
const char*          value_ToCstr(const x2gw::UserInCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:x2gw.UserInCase.value.Print
void                 value_Print(const x2gw::UserInCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:x2gw.UserInCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(x2gw::UserInCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:x2gw.UserInCase.value.SetStrptr
void                 value_SetStrptr(x2gw::UserInCase& parent, algo::strptr rhs, x2gw_UserInCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:x2gw.UserInCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(x2gw::UserInCase& parent, algo::strptr rhs) __attribute__((nothrow));
// func:x2gw.UserInCase.value.Cast
inline               x2gw::UserInCase::operator x2gw_UserInCaseEnum() const __attribute__((nothrow));
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_ams_read
// this function is 'extrn' and implemented by user
void                 framing_ams_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_http_read
// this function is 'extrn' and implemented by user
void                 framing_http_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_kafka_read
// this function is 'extrn' and implemented by user
void                 framing_kafka_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_mqtt_read
// this function is 'extrn' and implemented by user
void                 framing_mqtt_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_nats_read
// this function is 'extrn' and implemented by user
void                 framing_nats_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_resp_read
// this function is 'extrn' and implemented by user
void                 framing_resp_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_ws_read
// this function is 'extrn' and implemented by user
void                 framing_ws_read();
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_ams_scan
// this function is 'extrn' and implemented by user
void                 framing_ams_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_http_scan
// this function is 'extrn' and implemented by user
void                 framing_http_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_kafka_scan
// this function is 'extrn' and implemented by user
void                 framing_kafka_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_mqtt_scan
// this function is 'extrn' and implemented by user
void                 framing_mqtt_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_nats_scan
// this function is 'extrn' and implemented by user
void                 framing_nats_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_resp_scan
// this function is 'extrn' and implemented by user
void                 framing_resp_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.framing
// func:x2gw...framing_ws_scan
// this function is 'extrn' and implemented by user
void                 framing_ws_scan(x2gw::FConn&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_cluster
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_cluster(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_cpu
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_cpu(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_disk
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_disk(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_gateway
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_gateway(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_interface
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_interface(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_metric
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_metric(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_node
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_node(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_process
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_process(http::Request&);
// User-implemented function from gstatic:x2gw.FDb.apiendpoint
// func:x2gw...apiendpoint_GET_v1_stream
// this function is 'extrn' and implemented by user
void                 apiendpoint_GET_v1_stream(http::Request&);
// func:x2gw...SizeCheck
inline static void   SizeCheck();
// func:x2gw...StaticCheck
void                 StaticCheck();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.acl.XrefMaybe
bool                 acl_XrefMaybe(x2gw::FAcl &row);
// func:x2gw.FAcl..Ctor
inline               x2gw::FAcl::FAcl() __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.apiendpoint.XrefMaybe
bool                 apiendpoint_XrefMaybe(x2gw::FApiendpoint &row);
// func:x2gw.FApiendpoint..Uninit
void                 FApiendpoint_Uninit(x2gw::FApiendpoint& apiendpoint) __attribute__((nothrow));
// reftype Hook of x2gw.FApiendpoint.step prohibits copy
// func:x2gw.FApiendpoint..AssignOp
inline x2gw::FApiendpoint& x2gw::FApiendpoint::operator =(const x2gw::FApiendpoint &rhs) = delete;
// func:x2gw.FApiendpoint..Ctor
inline               x2gw::FApiendpoint::FApiendpoint() __attribute__((nothrow));
// func:x2gw.FApiendpoint..Dtor
inline               x2gw::FApiendpoint::~FApiendpoint() __attribute__((nothrow));
// reftype Hook of x2gw.FApiendpoint.step prohibits copy
// func:x2gw.FApiendpoint..CopyCtor
inline               x2gw::FApiendpoint::FApiendpoint(const x2gw::FApiendpoint &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.cmdreq.XrefMaybe
bool                 cmdreq_XrefMaybe(x2gw::FCmdreq &row);
// func:x2gw.FCmdreq..Uninit
void                 FCmdreq_Uninit(x2gw::FCmdreq& cmdreq) __attribute__((nothrow));
// reftype Ptrary of x2gw.FCmdreq.c_proc_output prohibits copy
// value field x2gw.FCmdreq.timeout is not copiable
// func:x2gw.FCmdreq..AssignOp
inline x2gw::FCmdreq& x2gw::FCmdreq::operator =(const x2gw::FCmdreq &rhs) = delete;
// func:x2gw.FCmdreq..Ctor
inline               x2gw::FCmdreq::FCmdreq() __attribute__((nothrow));
// func:x2gw.FCmdreq..Dtor
inline               x2gw::FCmdreq::~FCmdreq() __attribute__((nothrow));
// reftype Ptrary of x2gw.FCmdreq.c_proc_output prohibits copy
// value field x2gw.FCmdreq.timeout is not copiable
// func:x2gw.FCmdreq..CopyCtor
inline               x2gw::FCmdreq::FCmdreq(const x2gw::FCmdreq &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.conn.XrefMaybe
bool                 conn_XrefMaybe(x2gw::FConn &row);
// func:x2gw.FConn..Uninit
void                 FConn_Uninit(x2gw::FConn& conn) __attribute__((nothrow));
// field x2gw.FConn.out prevents copy
// field x2gw.FConn.in prevents copy
// user-defined fcleanup on x2gw.FConn.p_gwport prevents copy
// user-defined fcleanup on x2gw.FConn.ssl prevents copy
// x-reference on x2gw.FConn.c_session_conn prevents copy
// reftype Llist of x2gw.FConn.zd_cmdreq prohibits copy
// reftype Llist of x2gw.FConn.zd_conn_moentry prohibits copy
// reftype Llist of x2gw.FConn.zd_conn_moentry_pending prohibits copy
// func:x2gw.FConn..AssignOp
x2gw::FConn&         x2gw::FConn::operator =(const x2gw::FConn &rhs) = delete;
// func:x2gw.FConn..Ctor
inline               x2gw::FConn::FConn() __attribute__((nothrow));
// func:x2gw.FConn..Dtor
inline               x2gw::FConn::~FConn() __attribute__((nothrow));
// field x2gw.FConn.out prevents copy
// field x2gw.FConn.in prevents copy
// user-defined fcleanup on x2gw.FConn.p_gwport prevents copy
// user-defined fcleanup on x2gw.FConn.ssl prevents copy
// x-reference on x2gw.FConn.c_session_conn prevents copy
// reftype Llist of x2gw.FConn.zd_cmdreq prohibits copy
// reftype Llist of x2gw.FConn.zd_conn_moentry prohibits copy
// reftype Llist of x2gw.FConn.zd_conn_moentry_pending prohibits copy
// func:x2gw.FConn..CopyCtor
x2gw::FConn::FConn(const x2gw::FConn &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.connstat.XrefMaybe
bool                 connstat_XrefMaybe(x2gw::FConnstat &row);
// Set all fields to initial values.
// func:x2gw.FConnstat..Init
inline void          FConnstat_Init(x2gw::FConnstat& connstat);
// func:x2gw.FConnstat..Ctor
inline               x2gw::FConnstat::FConnstat() __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.netproto.XrefMaybe
bool                 netproto_XrefMaybe(x2gw::FNetproto &row);
// func:x2gw.FNetproto..Uninit
void                 FNetproto_Uninit(x2gw::FNetproto& netproto) __attribute__((nothrow));
// func:x2gw.FNetproto..AssignOp
inline x2gw::FNetproto& x2gw::FNetproto::operator =(const x2gw::FNetproto &rhs) = delete;
// func:x2gw.FNetproto..Ctor
inline               x2gw::FNetproto::FNetproto() __attribute__((nothrow));
// func:x2gw.FNetproto..Dtor
inline               x2gw::FNetproto::~FNetproto() __attribute__((nothrow));
// func:x2gw.FNetproto..CopyCtor
inline               x2gw::FNetproto::FNetproto(const x2gw::FNetproto &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.framing.XrefMaybe
bool                 framing_XrefMaybe(x2gw::FFraming &row);
// func:x2gw.FFraming..Uninit
void                 FFraming_Uninit(x2gw::FFraming& framing) __attribute__((nothrow));
// reftype Hook of x2gw.FFraming.read prohibits copy
// reftype Hook of x2gw.FFraming.scan prohibits copy
// func:x2gw.FFraming..AssignOp
inline x2gw::FFraming& x2gw::FFraming::operator =(const x2gw::FFraming &rhs) = delete;
// func:x2gw.FFraming..Ctor
inline               x2gw::FFraming::FFraming() __attribute__((nothrow));
// func:x2gw.FFraming..Dtor
inline               x2gw::FFraming::~FFraming() __attribute__((nothrow));
// reftype Hook of x2gw.FFraming.read prohibits copy
// reftype Hook of x2gw.FFraming.scan prohibits copy
// func:x2gw.FFraming..CopyCtor
inline               x2gw::FFraming::FFraming(const x2gw::FFraming &rhs) = delete;
// Set all fields to initial values.
// func:x2gw.trace..Init
inline void          trace_Init(x2gw::trace& parent);
// print string representation of ROW to string STR
// cfmt:x2gw.trace.String  printfmt:Tuple
// func:x2gw.trace..Print
void                 trace_Print(x2gw::trace& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.trace..Ctor
inline               x2gw::trace::trace() __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();
// func:x2gw.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));
// func:x2gw.FDb..AssignOp
x2gw::FDb&           x2gw::FDb::operator =(const x2gw::FDb &rhs) = delete;
// func:x2gw.FDb..CopyCtor
x2gw::FDb::FDb(const x2gw::FDb &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.disk.XrefMaybe
bool                 disk_XrefMaybe(x2gw::FDisk &row);
// func:x2gw.FDisk..Uninit
void                 FDisk_Uninit(x2gw::FDisk& disk) __attribute__((nothrow));
// func:x2gw.FDisk..AssignOp
inline x2gw::FDisk&  x2gw::FDisk::operator =(const x2gw::FDisk &rhs) = delete;
// func:x2gw.FDisk..Ctor
inline               x2gw::FDisk::FDisk() __attribute__((nothrow));
// func:x2gw.FDisk..Dtor
inline               x2gw::FDisk::~FDisk() __attribute__((nothrow));
// func:x2gw.FDisk..CopyCtor
inline               x2gw::FDisk::FDisk(const x2gw::FDisk &rhs) = delete;
// Set all fields to initial values.
// func:x2gw.RespFetchOp..Init
inline void          RespFetchOp_Init(x2gw::RespFetchOp& parent);
// print string representation of ROW to string STR
// cfmt:x2gw.RespFetchOp.String  printfmt:Raw
// func:x2gw.RespFetchOp..Print
void                 RespFetchOp_Print(x2gw::RespFetchOp& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.RespFetchOp..Ctor
inline               x2gw::RespFetchOp::RespFetchOp() __attribute__((nothrow));
// func:x2gw.RespFetchOp..EnumCtor
inline               x2gw::RespFetchOp::RespFetchOp(x2gw_RespFetchOpEnum arg) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.fetch.XrefMaybe
bool                 fetch_XrefMaybe(x2gw::FFetch &row);
// func:x2gw.FFetch..Uninit
void                 FFetch_Uninit(x2gw::FFetch& fetch) __attribute__((nothrow));
// value field x2gw.FFetch.timeout is not copiable
// reftype Llist of x2gw.FFetch.zd_packet_queue prohibits copy
// reftype Hook of x2gw.FFetch.h_msg prohibits copy
// value field x2gw.FFetch.linger is not copiable
// func:x2gw.FFetch..AssignOp
x2gw::FFetch&        x2gw::FFetch::operator =(const x2gw::FFetch &rhs) = delete;
// func:x2gw.FFetch..Ctor
inline               x2gw::FFetch::FFetch() __attribute__((nothrow));
// func:x2gw.FFetch..Dtor
inline               x2gw::FFetch::~FFetch() __attribute__((nothrow));
// value field x2gw.FFetch.timeout is not copiable
// reftype Llist of x2gw.FFetch.zd_packet_queue prohibits copy
// reftype Hook of x2gw.FFetch.h_msg prohibits copy
// value field x2gw.FFetch.linger is not copiable
// func:x2gw.FFetch..CopyCtor
x2gw::FFetch::FFetch(const x2gw::FFetch &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.group.XrefMaybe
bool                 group_XrefMaybe(x2gw::FGroup &row);
// func:x2gw.FGroup..Uninit
void                 FGroup_Uninit(x2gw::FGroup& group) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:x2gw.FGroup.String  printfmt:Tuple
// func:x2gw.FGroup..Print
void                 FGroup_Print(x2gw::FGroup& row, algo::cstring& str) __attribute__((nothrow));
// reftype Llist of x2gw.FGroup.zd_group_member prohibits copy
// x-reference on x2gw.FGroup.c_leader prevents copy
// value field x2gw.FGroup.timeout is not copiable
// func:x2gw.FGroup..AssignOp
inline x2gw::FGroup& x2gw::FGroup::operator =(const x2gw::FGroup &rhs) = delete;
// func:x2gw.FGroup..Ctor
inline               x2gw::FGroup::FGroup() __attribute__((nothrow));
// func:x2gw.FGroup..Dtor
inline               x2gw::FGroup::~FGroup() __attribute__((nothrow));
// reftype Llist of x2gw.FGroup.zd_group_member prohibits copy
// x-reference on x2gw.FGroup.c_leader prevents copy
// value field x2gw.FGroup.timeout is not copiable
// func:x2gw.FGroup..CopyCtor
inline               x2gw::FGroup::FGroup(const x2gw::FGroup &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.gwport.XrefMaybe
bool                 gwport_XrefMaybe(x2gw::FGwport &row);
// func:x2gw.FGwport..Uninit
void                 FGwport_Uninit(x2gw::FGwport& gwport) __attribute__((nothrow));
// x-reference on x2gw.FGwport.p_gwproto prevents copy
// reftype Llist of x2gw.FGwport.zd_gwport_conn prohibits copy
// value field x2gw.FGwport.iohook is not copiable
// user-defined fcleanup on x2gw.FGwport.ssl_ctx prevents copy
// func:x2gw.FGwport..AssignOp
x2gw::FGwport&       x2gw::FGwport::operator =(const x2gw::FGwport &rhs) = delete;
// func:x2gw.FGwport..Ctor
inline               x2gw::FGwport::FGwport() __attribute__((nothrow));
// func:x2gw.FGwport..Dtor
inline               x2gw::FGwport::~FGwport() __attribute__((nothrow));
// x-reference on x2gw.FGwport.p_gwproto prevents copy
// reftype Llist of x2gw.FGwport.zd_gwport_conn prohibits copy
// value field x2gw.FGwport.iohook is not copiable
// user-defined fcleanup on x2gw.FGwport.ssl_ctx prevents copy
// func:x2gw.FGwport..CopyCtor
x2gw::FGwport::FGwport(const x2gw::FGwport &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.gwproto.XrefMaybe
bool                 gwproto_XrefMaybe(x2gw::FGwproto &row);
// func:x2gw.FGwproto..Uninit
void                 FGwproto_Uninit(x2gw::FGwproto& gwproto) __attribute__((nothrow));
// x-reference on x2gw.FGwproto.p_netproto prevents copy
// x-reference on x2gw.FGwproto.p_framing prevents copy
// func:x2gw.FGwproto..AssignOp
inline x2gw::FGwproto& x2gw::FGwproto::operator =(const x2gw::FGwproto &rhs) = delete;
// func:x2gw.FGwproto..Ctor
inline               x2gw::FGwproto::FGwproto() __attribute__((nothrow));
// func:x2gw.FGwproto..Dtor
inline               x2gw::FGwproto::~FGwproto() __attribute__((nothrow));
// x-reference on x2gw.FGwproto.p_netproto prevents copy
// x-reference on x2gw.FGwproto.p_framing prevents copy
// func:x2gw.FGwproto..CopyCtor
inline               x2gw::FGwproto::FGwproto(const x2gw::FGwproto &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.intf.XrefMaybe
bool                 intf_XrefMaybe(x2gw::FIntf &row);
// func:x2gw.FIntf..ReadFieldMaybe
bool                 FIntf_ReadFieldMaybe(x2gw::FIntf& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of x2gw::FIntf from an ascii string.
// The format of the string is an ssim Tuple
// func:x2gw.FIntf..ReadStrptrMaybe
bool                 FIntf_ReadStrptrMaybe(x2gw::FIntf &parent, algo::strptr in_str) __attribute__((nothrow));
// func:x2gw.FIntf..Uninit
void                 FIntf_Uninit(x2gw::FIntf& intf) __attribute__((nothrow));
// Create JSON representation of x2gw::FIntf under PARENT node
// cfmt:x2gw.FIntf.Json  printfmt:Auto
// func:x2gw.FIntf..FmtJson
lib_json::FNode *    FIntf_FmtJson(x2gw::FIntf& row, lib_json::FNode *parent) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:x2gw.FIntf.String  printfmt:Tuple
// func:x2gw.FIntf..Print
void                 FIntf_Print(x2gw::FIntf& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.FIntf..AssignOp
inline x2gw::FIntf&  x2gw::FIntf::operator =(const x2gw::FIntf &rhs) = delete;
// func:x2gw.FIntf..Ctor
inline               x2gw::FIntf::FIntf() __attribute__((nothrow));
// func:x2gw.FIntf..Dtor
inline               x2gw::FIntf::~FIntf() __attribute__((nothrow));
// func:x2gw.FIntf..CopyCtor
inline               x2gw::FIntf::FIntf(const x2gw::FIntf &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.kafka_acl.XrefMaybe
bool                 kafka_acl_XrefMaybe(x2gw::FKafkaAcl &row);
// func:x2gw.FKafkaAcl..Uninit
void                 FKafkaAcl_Uninit(x2gw::FKafkaAcl& kafka_acl) __attribute__((nothrow));
// func:x2gw.FKafkaAcl..AssignOp
inline x2gw::FKafkaAcl& x2gw::FKafkaAcl::operator =(const x2gw::FKafkaAcl &rhs) = delete;
// func:x2gw.FKafkaAcl..Ctor
inline               x2gw::FKafkaAcl::FKafkaAcl() __attribute__((nothrow));
// func:x2gw.FKafkaAcl..Dtor
inline               x2gw::FKafkaAcl::~FKafkaAcl() __attribute__((nothrow));
// func:x2gw.FKafkaAcl..CopyCtor
inline               x2gw::FKafkaAcl::FKafkaAcl(const x2gw::FKafkaAcl &rhs) = delete;
// func:x2gw.KafkaAclResourceKey..Hash
inline u32           KafkaAclResourceKey_Hash(u32 prev, const x2gw::KafkaAclResourceKey& rhs) __attribute__((nothrow));
// func:x2gw.KafkaAclResourceKey..ReadFieldMaybe
bool                 KafkaAclResourceKey_ReadFieldMaybe(x2gw::KafkaAclResourceKey& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// func:x2gw.KafkaAclResourceKey..EqOp
inline bool          x2gw::KafkaAclResourceKey::operator ==(const x2gw::KafkaAclResourceKey &rhs) const __attribute__((nothrow));
// func:x2gw.KafkaAclResourceKey..NeOp
inline bool          x2gw::KafkaAclResourceKey::operator !=(const x2gw::KafkaAclResourceKey &rhs) const __attribute__((nothrow));
// Read fields of x2gw::KafkaAclResourceKey from an ascii string.
// The format of the string is an ssim Tuple
// func:x2gw.KafkaAclResourceKey..ReadStrptrMaybe
bool                 KafkaAclResourceKey_ReadStrptrMaybe(x2gw::KafkaAclResourceKey &parent, algo::strptr in_str) __attribute__((nothrow));
// func:x2gw.KafkaAclResourceKey..Cmp
inline i32           KafkaAclResourceKey_Cmp(x2gw::KafkaAclResourceKey& lhs, x2gw::KafkaAclResourceKey& rhs) __attribute__((nothrow));
// func:x2gw.KafkaAclResourceKey..Eq
inline bool          KafkaAclResourceKey_Eq(x2gw::KafkaAclResourceKey& lhs, x2gw::KafkaAclResourceKey& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:x2gw.KafkaAclResourceKey.String  printfmt:Tuple
// func:x2gw.KafkaAclResourceKey..Print
void                 KafkaAclResourceKey_Print(x2gw::KafkaAclResourceKey& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.KafkaAclResourceKey..Ctor
inline               x2gw::KafkaAclResourceKey::KafkaAclResourceKey() __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.kafka_acl_resource.XrefMaybe
bool                 kafka_acl_resource_XrefMaybe(x2gw::FKafkaAclResource &row);
// func:x2gw.FKafkaAclResource..Uninit
void                 FKafkaAclResource_Uninit(x2gw::FKafkaAclResource& kafka_acl_resource) __attribute__((nothrow));
// reftype Llist of x2gw.FKafkaAclResource.zd_acl prohibits copy
// func:x2gw.FKafkaAclResource..AssignOp
inline x2gw::FKafkaAclResource& x2gw::FKafkaAclResource::operator =(const x2gw::FKafkaAclResource &rhs) = delete;
// func:x2gw.FKafkaAclResource..Ctor
inline               x2gw::FKafkaAclResource::FKafkaAclResource() __attribute__((nothrow));
// func:x2gw.FKafkaAclResource..Dtor
inline               x2gw::FKafkaAclResource::~FKafkaAclResource() __attribute__((nothrow));
// reftype Llist of x2gw.FKafkaAclResource.zd_acl prohibits copy
// func:x2gw.FKafkaAclResource..CopyCtor
inline               x2gw::FKafkaAclResource::FKafkaAclResource(const x2gw::FKafkaAclResource &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.kafka_fetch.XrefMaybe
bool                 kafka_fetch_XrefMaybe(x2gw::FKafkaFetch &row);
// func:x2gw.FKafkaFetch..Uninit
void                 FKafkaFetch_Uninit(x2gw::FKafkaFetch& kafka_fetch) __attribute__((nothrow));
// reftype Llist of x2gw.FKafkaFetch.zd_kafka_fetch_fetch prohibits copy
// value field x2gw.FKafkaFetch.timeout is not copiable
// func:x2gw.FKafkaFetch..AssignOp
inline x2gw::FKafkaFetch& x2gw::FKafkaFetch::operator =(const x2gw::FKafkaFetch &rhs) = delete;
// func:x2gw.FKafkaFetch..Ctor
inline               x2gw::FKafkaFetch::FKafkaFetch() __attribute__((nothrow));
// func:x2gw.FKafkaFetch..Dtor
inline               x2gw::FKafkaFetch::~FKafkaFetch() __attribute__((nothrow));
// reftype Llist of x2gw.FKafkaFetch.zd_kafka_fetch_fetch prohibits copy
// value field x2gw.FKafkaFetch.timeout is not copiable
// func:x2gw.FKafkaFetch..CopyCtor
inline               x2gw::FKafkaFetch::FKafkaFetch(const x2gw::FKafkaFetch &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.member.XrefMaybe
bool                 member_XrefMaybe(x2gw::FMember &row);
// func:x2gw.FMember..Uninit
void                 FMember_Uninit(x2gw::FMember& member) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:x2gw.FMember.String  printfmt:Tuple
// func:x2gw.FMember..Print
void                 FMember_Print(x2gw::FMember& row, algo::cstring& str) __attribute__((nothrow));
// user-defined fcleanup on x2gw.FMember.p_group prevents copy
// value field x2gw.FMember.timeout is not copiable
// func:x2gw.FMember..AssignOp
x2gw::FMember&       x2gw::FMember::operator =(const x2gw::FMember &rhs) = delete;
// func:x2gw.FMember..Ctor
inline               x2gw::FMember::FMember() __attribute__((nothrow));
// func:x2gw.FMember..Dtor
inline               x2gw::FMember::~FMember() __attribute__((nothrow));
// user-defined fcleanup on x2gw.FMember.p_group prevents copy
// value field x2gw.FMember.timeout is not copiable
// func:x2gw.FMember..CopyCtor
x2gw::FMember::FMember(const x2gw::FMember &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.metric.XrefMaybe
bool                 metric_XrefMaybe(x2gw::FMetric &row);
// func:x2gw.FMetric..Uninit
void                 FMetric_Uninit(x2gw::FMetric& metric) __attribute__((nothrow));
// reftype Llist of x2gw.FMetric.zd_metric_moentry prohibits copy
// func:x2gw.FMetric..AssignOp
inline x2gw::FMetric& x2gw::FMetric::operator =(const x2gw::FMetric &rhs) = delete;
// func:x2gw.FMetric..Ctor
inline               x2gw::FMetric::FMetric() __attribute__((nothrow));
// func:x2gw.FMetric..Dtor
inline               x2gw::FMetric::~FMetric() __attribute__((nothrow));
// reftype Llist of x2gw.FMetric.zd_metric_moentry prohibits copy
// func:x2gw.FMetric..CopyCtor
inline               x2gw::FMetric::FMetric(const x2gw::FMetric &rhs) = delete;
// func:x2gw.FMoentryKey..Hash
inline u32           FMoentryKey_Hash(u32 prev, x2gw::FMoentryKey rhs) __attribute__((nothrow));
// func:x2gw.FMoentryKey..EqOp
inline bool          x2gw::FMoentryKey::operator ==(const x2gw::FMoentryKey &rhs) const __attribute__((nothrow));
// func:x2gw.FMoentryKey..NeOp
inline bool          x2gw::FMoentryKey::operator !=(const x2gw::FMoentryKey &rhs) const __attribute__((nothrow));
// func:x2gw.FMoentryKey..Cmp
inline i32           FMoentryKey_Cmp(x2gw::FMoentryKey lhs, x2gw::FMoentryKey rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FMoentryKey..Init
inline void          FMoentryKey_Init(x2gw::FMoentryKey& parent);
// func:x2gw.FMoentryKey..Eq
inline bool          FMoentryKey_Eq(x2gw::FMoentryKey lhs, x2gw::FMoentryKey rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:x2gw.FMoentryKey.String  printfmt:Tuple
// func:x2gw.FMoentryKey..Print
void                 FMoentryKey_Print(x2gw::FMoentryKey row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.FMoentryKey..Ctor
inline               x2gw::FMoentryKey::FMoentryKey() __attribute__((nothrow));
// func:x2gw.FMoentryKey..FieldwiseCtor
inline               x2gw::FMoentryKey::FMoentryKey(x2gw::FConn* in_p_conn, x2gw::FMetric* in_p_metric) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.moentry.XrefMaybe
bool                 moentry_XrefMaybe(x2gw::FMoentry &row);
// func:x2gw.FMoentry..Uninit
void                 FMoentry_Uninit(x2gw::FMoentry& moentry) __attribute__((nothrow));
// func:x2gw.FMoentry..AssignOp
inline x2gw::FMoentry& x2gw::FMoentry::operator =(const x2gw::FMoentry &rhs) = delete;
// func:x2gw.FMoentry..Ctor
inline               x2gw::FMoentry::FMoentry() __attribute__((nothrow));
// func:x2gw.FMoentry..Dtor
inline               x2gw::FMoentry::~FMoentry() __attribute__((nothrow));
// func:x2gw.FMoentry..CopyCtor
inline               x2gw::FMoentry::FMoentry(const x2gw::FMoentry &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.open_stream.XrefMaybe
bool                 open_stream_XrefMaybe(x2gw::FOpenStream &row);
// func:x2gw.FOpenStream..Uninit
void                 FOpenStream_Uninit(x2gw::FOpenStream& open_stream) __attribute__((nothrow));
// func:x2gw.FOpenStream..AssignOp
inline x2gw::FOpenStream& x2gw::FOpenStream::operator =(const x2gw::FOpenStream &rhs) = delete;
// func:x2gw.FOpenStream..Ctor
inline               x2gw::FOpenStream::FOpenStream() __attribute__((nothrow));
// func:x2gw.FOpenStream..Dtor
inline               x2gw::FOpenStream::~FOpenStream() __attribute__((nothrow));
// func:x2gw.FOpenStream..CopyCtor
inline               x2gw::FOpenStream::FOpenStream(const x2gw::FOpenStream &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.packet.XrefMaybe
bool                 packet_XrefMaybe(x2gw::FPacket &row);
// func:x2gw.FPacket..Uninit
void                 FPacket_Uninit(x2gw::FPacket& packet) __attribute__((nothrow));
// func:x2gw.FPacket..AssignOp
inline x2gw::FPacket& x2gw::FPacket::operator =(const x2gw::FPacket &rhs) = delete;
// func:x2gw.FPacket..Ctor
inline               x2gw::FPacket::FPacket() __attribute__((nothrow));
// func:x2gw.FPacket..Dtor
inline               x2gw::FPacket::~FPacket() __attribute__((nothrow));
// func:x2gw.FPacket..CopyCtor
inline               x2gw::FPacket::FPacket(const x2gw::FPacket &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.proc.XrefMaybe
bool                 proc_XrefMaybe(x2gw::FProc &row);
// func:x2gw.FProc..Uninit
void                 FProc_Uninit(x2gw::FProc& proc) __attribute__((nothrow));
// reftype Llist of x2gw.FProc.zd_gwport prohibits copy
// x-reference on x2gw.FProc.p_x2node prevents copy
// func:x2gw.FProc..AssignOp
x2gw::FProc&         x2gw::FProc::operator =(const x2gw::FProc &rhs) = delete;
// func:x2gw.FProc..Ctor
inline               x2gw::FProc::FProc() __attribute__((nothrow));
// func:x2gw.FProc..Dtor
inline               x2gw::FProc::~FProc() __attribute__((nothrow));
// reftype Llist of x2gw.FProc.zd_gwport prohibits copy
// x-reference on x2gw.FProc.p_x2node prevents copy
// func:x2gw.FProc..CopyCtor
x2gw::FProc::FProc(const x2gw::FProc &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.proc_output.XrefMaybe
bool                 proc_output_XrefMaybe(x2gw::FProcOutput &row);
// func:x2gw.FProcOutput..Uninit
void                 FProcOutput_Uninit(x2gw::FProcOutput& proc_output) __attribute__((nothrow));
// x-reference on x2gw.FProcOutput.p_cmdreq prevents copy
// func:x2gw.FProcOutput..AssignOp
inline x2gw::FProcOutput& x2gw::FProcOutput::operator =(const x2gw::FProcOutput &rhs) = delete;
// func:x2gw.FProcOutput..Ctor
inline               x2gw::FProcOutput::FProcOutput() __attribute__((nothrow));
// func:x2gw.FProcOutput..Dtor
inline               x2gw::FProcOutput::~FProcOutput() __attribute__((nothrow));
// x-reference on x2gw.FProcOutput.p_cmdreq prevents copy
// func:x2gw.FProcOutput..CopyCtor
inline               x2gw::FProcOutput::FProcOutput(const x2gw::FProcOutput &rhs) = delete;
// Set all fields to initial values.
// func:x2gw.RespProduceOp..Init
inline void          RespProduceOp_Init(x2gw::RespProduceOp& parent);
// func:x2gw.RespProduceOp..Ctor
inline               x2gw::RespProduceOp::RespProduceOp() __attribute__((nothrow));
// func:x2gw.RespProduceOp..EnumCtor
inline               x2gw::RespProduceOp::RespProduceOp(x2gw_RespProduceOpEnum arg) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.producer.XrefMaybe
bool                 producer_XrefMaybe(x2gw::FProducer &row);
// func:x2gw.FProducer..Uninit
void                 FProducer_Uninit(x2gw::FProducer& producer) __attribute__((nothrow));
// reftype Hook of x2gw.FProducer.h_ack prohibits copy
// user-defined fcleanup on x2gw.FProducer.rsp prevents copy
// func:x2gw.FProducer..AssignOp
x2gw::FProducer&     x2gw::FProducer::operator =(const x2gw::FProducer &rhs) = delete;
// func:x2gw.FProducer..Ctor
inline               x2gw::FProducer::FProducer() __attribute__((nothrow));
// func:x2gw.FProducer..Dtor
inline               x2gw::FProducer::~FProducer() __attribute__((nothrow));
// reftype Hook of x2gw.FProducer.h_ack prohibits copy
// user-defined fcleanup on x2gw.FProducer.rsp prevents copy
// func:x2gw.FProducer..CopyCtor
x2gw::FProducer::FProducer(const x2gw::FProducer &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.session.XrefMaybe
bool                 session_XrefMaybe(x2gw::FSession &row);
// func:x2gw.FSession..Uninit
void                 FSession_Uninit(x2gw::FSession& session) __attribute__((nothrow));
// reftype Llist of x2gw.FSession.zd_session_fetch prohibits copy
// reftype Llist of x2gw.FSession.zd_session_producer prohibits copy
// reftype Llist of x2gw.FSession.zd_session_fetch_queue prohibits copy
// reftype Thash of x2gw.FSession.ind_produce_pi prohibits copy
// reftype Thash of x2gw.FSession.ind_unacked prohibits copy
// value field x2gw.FSession.timeout is not copiable
// reftype Llist of x2gw.FSession.zd_session_packet prohibits copy
// reftype Llist of x2gw.FSession.cd_session_fetch_queue prohibits copy
// x-reference on x2gw.FSession.c_session_conn prevents copy
// reftype Thash of x2gw.FSession.ind_stream_user_id prohibits copy
// reftype Llist of x2gw.FSession.zd_session_kafka_fetch prohibits copy
// reftype Llist of x2gw.FSession.zd_session_member prohibits copy
// func:x2gw.FSession..AssignOp
x2gw::FSession&      x2gw::FSession::operator =(const x2gw::FSession &rhs) = delete;
// func:x2gw.FSession..Ctor
inline               x2gw::FSession::FSession() __attribute__((nothrow));
// func:x2gw.FSession..Dtor
inline               x2gw::FSession::~FSession() __attribute__((nothrow));
// reftype Llist of x2gw.FSession.zd_session_fetch prohibits copy
// reftype Llist of x2gw.FSession.zd_session_producer prohibits copy
// reftype Llist of x2gw.FSession.zd_session_fetch_queue prohibits copy
// reftype Thash of x2gw.FSession.ind_produce_pi prohibits copy
// reftype Thash of x2gw.FSession.ind_unacked prohibits copy
// value field x2gw.FSession.timeout is not copiable
// reftype Llist of x2gw.FSession.zd_session_packet prohibits copy
// reftype Llist of x2gw.FSession.cd_session_fetch_queue prohibits copy
// x-reference on x2gw.FSession.c_session_conn prevents copy
// reftype Thash of x2gw.FSession.ind_stream_user_id prohibits copy
// reftype Llist of x2gw.FSession.zd_session_kafka_fetch prohibits copy
// reftype Llist of x2gw.FSession.zd_session_member prohibits copy
// func:x2gw.FSession..CopyCtor
x2gw::FSession::FSession(const x2gw::FSession &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.session_conn.XrefMaybe
bool                 session_conn_XrefMaybe(x2gw::FSessionConn &row);
// func:x2gw.FSessionConn..Uninit
void                 FSessionConn_Uninit(x2gw::FSessionConn& session_conn) __attribute__((nothrow));
// func:x2gw.FSessionConn..AssignOp
inline x2gw::FSessionConn& x2gw::FSessionConn::operator =(const x2gw::FSessionConn &rhs) = delete;
// func:x2gw.FSessionConn..Ctor
inline               x2gw::FSessionConn::FSessionConn() __attribute__((nothrow));
// func:x2gw.FSessionConn..Dtor
inline               x2gw::FSessionConn::~FSessionConn() __attribute__((nothrow));
// func:x2gw.FSessionConn..CopyCtor
inline               x2gw::FSessionConn::FSessionConn(const x2gw::FSessionConn &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.stream.XrefMaybe
bool                 stream_XrefMaybe(x2gw::FStream &row);
// func:x2gw.FStream..Uninit
void                 FStream_Uninit(x2gw::FStream& stream) __attribute__((nothrow));
// reftype Llist of x2gw.FStream.zd_stream_fetch prohibits copy
// func:x2gw.FStream..AssignOp
inline x2gw::FStream& x2gw::FStream::operator =(const x2gw::FStream &rhs) = delete;
// func:x2gw.FStream..Ctor
inline               x2gw::FStream::FStream() __attribute__((nothrow));
// func:x2gw.FStream..Dtor
inline               x2gw::FStream::~FStream() __attribute__((nothrow));
// reftype Llist of x2gw.FStream.zd_stream_fetch prohibits copy
// func:x2gw.FStream..CopyCtor
inline               x2gw::FStream::FStream(const x2gw::FStream &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.topic.XrefMaybe
bool                 topic_XrefMaybe(x2gw::FTopic &row);
// func:x2gw.FTopic..Uninit
void                 FTopic_Uninit(x2gw::FTopic& topic) __attribute__((nothrow));
// func:x2gw.FTopic..AssignOp
inline x2gw::FTopic& x2gw::FTopic::operator =(const x2gw::FTopic &rhs) = delete;
// func:x2gw.FTopic..Ctor
inline               x2gw::FTopic::FTopic() __attribute__((nothrow));
// func:x2gw.FTopic..Dtor
inline               x2gw::FTopic::~FTopic() __attribute__((nothrow));
// func:x2gw.FTopic..CopyCtor
inline               x2gw::FTopic::FTopic(const x2gw::FTopic &rhs) = delete;
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:x2gw.FDb.user.XrefMaybe
bool                 user_XrefMaybe(x2gw::FUser &row);
// func:x2gw.FUser..Uninit
void                 FUser_Uninit(x2gw::FUser& user) __attribute__((nothrow));
// reftype Llist of x2gw.FUser.zd_user_conn prohibits copy
// func:x2gw.FUser..AssignOp
inline x2gw::FUser&  x2gw::FUser::operator =(const x2gw::FUser &rhs) = delete;
// func:x2gw.FUser..Ctor
inline               x2gw::FUser::FUser() __attribute__((nothrow));
// func:x2gw.FUser..Dtor
inline               x2gw::FUser::~FUser() __attribute__((nothrow));
// reftype Llist of x2gw.FUser.zd_user_conn prohibits copy
// func:x2gw.FUser..CopyCtor
inline               x2gw::FUser::FUser(const x2gw::FUser &rhs) = delete;
// Set all fields to initial values.
// func:x2gw.Fetch..Init
void                 Fetch_Init(x2gw::Fetch& parent);
// print string representation of ROW to string STR
// cfmt:x2gw.Fetch.String  printfmt:Tuple
// func:x2gw.Fetch..Print
void                 Fetch_Print(x2gw::Fetch& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.Fetch..Ctor
inline               x2gw::Fetch::Fetch() __attribute__((nothrow));
// Read fields of x2gw::FieldId from an ascii string.
// The format of the string is the format of the x2gw::FieldId's only field
// func:x2gw.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(x2gw::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.FieldId..Init
inline void          FieldId_Init(x2gw::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:x2gw.FieldId.String  printfmt:Raw
// func:x2gw.FieldId..Print
void                 FieldId_Print(x2gw::FieldId& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.FieldId..Ctor
inline               x2gw::FieldId::FieldId() __attribute__((nothrow));
// func:x2gw.FieldId..FieldwiseCtor
inline               x2gw::FieldId::FieldId(i32 in_value) __attribute__((nothrow));
// func:x2gw.FieldId..EnumCtor
inline               x2gw::FieldId::FieldId(x2gw_FieldIdEnum arg) __attribute__((nothrow));
// Read fields of x2gw::InCase from an ascii string.
// The format of the string is the format of the x2gw::InCase's only field
// func:x2gw.InCase..ReadStrptrMaybe
bool                 InCase_ReadStrptrMaybe(x2gw::InCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.InCase..Init
inline void          InCase_Init(x2gw::InCase& parent);
// func:x2gw.InCase..Ctor
inline               x2gw::InCase::InCase() __attribute__((nothrow));
// func:x2gw.InCase..FieldwiseCtor
inline               x2gw::InCase::InCase(u32 in_value) __attribute__((nothrow));
// func:x2gw.InCase..EnumCtor
inline               x2gw::InCase::InCase(x2gw_InCaseEnum arg) __attribute__((nothrow));
// Read fields of x2gw::KafkaInCase from an ascii string.
// The format of the string is the format of the x2gw::KafkaInCase's only field
// func:x2gw.KafkaInCase..ReadStrptrMaybe
bool                 KafkaInCase_ReadStrptrMaybe(x2gw::KafkaInCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.KafkaInCase..Init
inline void          KafkaInCase_Init(x2gw::KafkaInCase& parent);
// func:x2gw.KafkaInCase..Ctor
inline               x2gw::KafkaInCase::KafkaInCase() __attribute__((nothrow));
// func:x2gw.KafkaInCase..FieldwiseCtor
inline               x2gw::KafkaInCase::KafkaInCase(u32 in_value) __attribute__((nothrow));
// func:x2gw.KafkaInCase..EnumCtor
inline               x2gw::KafkaInCase::KafkaInCase(x2gw_KafkaInCaseEnum arg) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:x2gw.MemberProtocol.String  printfmt:Tuple
// func:x2gw.MemberProtocol..Print
void                 MemberProtocol_Print(x2gw::MemberProtocol& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.MemberProtocol..Ctor
inline               x2gw::MemberProtocol::MemberProtocol() __attribute__((nothrow));
// Read fields of x2gw::RespInCase from an ascii string.
// The format of the string is the format of the x2gw::RespInCase's only field
// func:x2gw.RespInCase..ReadStrptrMaybe
bool                 RespInCase_ReadStrptrMaybe(x2gw::RespInCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.RespInCase..Init
inline void          RespInCase_Init(x2gw::RespInCase& parent);
// func:x2gw.RespInCase..Ctor
inline               x2gw::RespInCase::RespInCase() __attribute__((nothrow));
// func:x2gw.RespInCase..FieldwiseCtor
inline               x2gw::RespInCase::RespInCase(u32 in_value) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.Session..Init
inline void          Session_Init(x2gw::Session& parent);
// print string representation of ROW to string STR
// cfmt:x2gw.Session.String  printfmt:Tuple
// func:x2gw.Session..Print
void                 Session_Print(x2gw::Session& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.Session..Ctor
inline               x2gw::Session::Session() __attribute__((nothrow));
// Read fields of x2gw::TableId from an ascii string.
// The format of the string is the format of the x2gw::TableId's only field
// func:x2gw.TableId..ReadStrptrMaybe
bool                 TableId_ReadStrptrMaybe(x2gw::TableId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.TableId..Init
inline void          TableId_Init(x2gw::TableId& parent);
// print string representation of ROW to string STR
// cfmt:x2gw.TableId.String  printfmt:Raw
// func:x2gw.TableId..Print
void                 TableId_Print(x2gw::TableId& row, algo::cstring& str) __attribute__((nothrow));
// func:x2gw.TableId..Ctor
inline               x2gw::TableId::TableId() __attribute__((nothrow));
// func:x2gw.TableId..FieldwiseCtor
inline               x2gw::TableId::TableId(i32 in_value) __attribute__((nothrow));
// func:x2gw.TableId..EnumCtor
inline               x2gw::TableId::TableId(x2gw_TableIdEnum arg) __attribute__((nothrow));
// Read fields of x2gw::UserInCase from an ascii string.
// The format of the string is the format of the x2gw::UserInCase's only field
// func:x2gw.UserInCase..ReadStrptrMaybe
bool                 UserInCase_ReadStrptrMaybe(x2gw::UserInCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:x2gw.UserInCase..Init
inline void          UserInCase_Init(x2gw::UserInCase& parent);
// func:x2gw.UserInCase..Ctor
inline               x2gw::UserInCase::UserInCase() __attribute__((nothrow));
// func:x2gw.UserInCase..FieldwiseCtor
inline               x2gw::UserInCase::UserInCase(u32 in_value) __attribute__((nothrow));
// func:x2gw.UserInCase..EnumCtor
inline               x2gw::UserInCase::UserInCase(x2gw_UserInCaseEnum arg) __attribute__((nothrow));
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.AckMsg
// this function is 'extrn' and implemented by user
void                 In_AckMsg(x2::AckMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.CmdDoneMsg
// this function is 'extrn' and implemented by user
void                 In_CmdDoneMsg(x2::CmdDoneMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.CmdOutputMsg
// this function is 'extrn' and implemented by user
void                 In_CmdOutputMsg(x2::CmdOutputMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.CreateAclMsg
// this function is 'extrn' and implemented by user
void                 In_CreateAclMsg(x2::CreateAclMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.CreateStreamMsg
// this function is 'extrn' and implemented by user
void                 In_CreateStreamMsg(x2::CreateStreamMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.CreateTopicMsg
// this function is 'extrn' and implemented by user
void                 In_CreateTopicMsg(x2::CreateTopicMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.CreateUserMsg
// this function is 'extrn' and implemented by user
void                 In_CreateUserMsg(x2::CreateUserMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.DataMsg
// this function is 'extrn' and implemented by user
void                 In_DataMsg(x2::DataMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.DefDiskMsg
// this function is 'extrn' and implemented by user
void                 In_DefDiskMsg(x2::DefDiskMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.DefIntfMsg
// this function is 'extrn' and implemented by user
void                 In_DefIntfMsg(x2::DefIntfMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.DefMetricMsg
// this function is 'extrn' and implemented by user
void                 In_DefMetricMsg(x2::DefMetricMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.DiskStateMsg
// this function is 'extrn' and implemented by user
void                 In_DiskStateMsg(x2::DiskStateMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.EnableMetricsMsg
// this function is 'extrn' and implemented by user
void                 In_EnableMetricsMsg(x2::EnableMetricsMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.IntfStateMsg
// this function is 'extrn' and implemented by user
void                 In_IntfStateMsg(x2::IntfStateMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.KafkaAclMsg
// this function is 'extrn' and implemented by user
void                 In_KafkaAclMsg(x2::KafkaAclMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.PubMetricMsg
// this function is 'extrn' and implemented by user
void                 In_PubMetricMsg(x2::PubMetricMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.SetUserPassMsg
// this function is 'extrn' and implemented by user
void                 In_SetUserPassMsg(x2::SetUserPassMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.StreamHbMsg
// this function is 'extrn' and implemented by user
void                 In_StreamHbMsg(x2::StreamHbMsg &msg);
// User-implemented callback function for dispatch In
// func:x2gw.In.x2.X2nodeStateMsg
// this function is 'extrn' and implemented by user
void                 In_X2nodeStateMsg(x2::X2nodeStateMsg &msg);
// func:x2gw.In..DispatchRaw
int                  InDispatchRaw(x2gw::InCase type, u8 *msg, u32 len);
// func:x2gw.In..Dispatch
int                  InDispatch(ams::MsgHeader& msg);
// void rettype useful for hooks
// func:x2gw.In..Dispatch2
void                 vInDispatch(ams::MsgHeader& msg);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.ApiVersionsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_ApiVersionsRequest(kafka2::ApiVersionsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.CreateAclsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_CreateAclsRequest(kafka2::CreateAclsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.CreateTopicsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_CreateTopicsRequest(kafka2::CreateTopicsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DeleteAclsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DeleteAclsRequest(kafka2::DeleteAclsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DeleteTopicsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DeleteTopicsRequest(kafka2::DeleteTopicsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DescribeAclsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DescribeAclsRequest(kafka2::DescribeAclsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DescribeClusterRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DescribeClusterRequest(kafka2::DescribeClusterRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DescribeConfigsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DescribeConfigsRequest(kafka2::DescribeConfigsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DescribeGroupsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DescribeGroupsRequest(kafka2::DescribeGroupsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.DescribeLogDirsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_DescribeLogDirsRequest(kafka2::DescribeLogDirsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.FetchRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_FetchRequest(kafka2::FetchRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.FindCoordinatorRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_FindCoordinatorRequest(kafka2::FindCoordinatorRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.HeartbeatRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_HeartbeatRequest(kafka2::HeartbeatRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.InitProducerIdRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_InitProducerIdRequest(kafka2::InitProducerIdRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.JoinGroupRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_JoinGroupRequest(kafka2::JoinGroupRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.LeaveGroupRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_LeaveGroupRequest(kafka2::LeaveGroupRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.ListGroupsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_ListGroupsRequest(kafka2::ListGroupsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.ListOffsetsRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_ListOffsetsRequest(kafka2::ListOffsetsRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.MetadataRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_MetadataRequest(kafka2::MetadataRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.OffsetCommitRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_OffsetCommitRequest(kafka2::OffsetCommitRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.OffsetFetchRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_OffsetFetchRequest(kafka2::OffsetFetchRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.ProduceRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_ProduceRequest(kafka2::ProduceRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.SaslAuthenticateRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_SaslAuthenticateRequest(kafka2::SaslAuthenticateRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.SaslHandshakeRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_SaslHandshakeRequest(kafka2::SaslHandshakeRequest &msg, u32 msg_len);
// User-implemented callback function for dispatch KafkaIn
// func:x2gw.KafkaIn.kafka2.SyncGroupRequest
// this function is 'extrn' and implemented by user
void                 KafkaIn_SyncGroupRequest(kafka2::SyncGroupRequest &msg, u32 msg_len);
// func:x2gw.KafkaIn..DispatchRaw
int                  KafkaInDispatchRaw(x2gw::KafkaInCase type, u8 *msg, u32 len);
// func:x2gw.KafkaIn..Dispatch
int                  KafkaInDispatch(kafka2::RequestHeader& msg, u32 msg_len);
// void rettype useful for hooks
// func:x2gw.KafkaIn..Dispatch2
void                 vKafkaInDispatch(kafka2::RequestHeader& msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.AUTH
// this function is 'extrn' and implemented by user
void                 MqttIn_AUTH(mqtt::AUTH &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.CONNECT
// this function is 'extrn' and implemented by user
void                 MqttIn_CONNECT(mqtt::CONNECT &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.DISCONNECT
// this function is 'extrn' and implemented by user
void                 MqttIn_DISCONNECT(mqtt::DISCONNECT &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.PINGREQ
// this function is 'extrn' and implemented by user
void                 MqttIn_PINGREQ(mqtt::PINGREQ &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.PUBACK
// this function is 'extrn' and implemented by user
void                 MqttIn_PUBACK(mqtt::PUBACK &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.PUBCOMP
// this function is 'extrn' and implemented by user
void                 MqttIn_PUBCOMP(mqtt::PUBCOMP &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.PUBLISH
// this function is 'extrn' and implemented by user
void                 MqttIn_PUBLISH(mqtt::PUBLISH &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.PUBREC
// this function is 'extrn' and implemented by user
void                 MqttIn_PUBREC(mqtt::PUBREC &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.PUBREL
// this function is 'extrn' and implemented by user
void                 MqttIn_PUBREL(mqtt::PUBREL &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.SUBSCRIBE
// this function is 'extrn' and implemented by user
void                 MqttIn_SUBSCRIBE(mqtt::SUBSCRIBE &msg, u32 msg_len);
// User-implemented callback function for dispatch MqttIn
// func:x2gw.MqttIn.mqtt.UNSUBSCRIBE
// this function is 'extrn' and implemented by user
void                 MqttIn_UNSUBSCRIBE(mqtt::UNSUBSCRIBE &msg, u32 msg_len);
// func:x2gw.MqttIn..DispatchRaw
int                  MqttInDispatchRaw(mqtt::PacketType type, u8 *msg, u32 len);
// func:x2gw.MqttIn..Dispatch
int                  MqttInDispatch(mqtt::MsgHeader& msg, u32 msg_len);
// void rettype useful for hooks
// func:x2gw.MqttIn..Dispatch2
void                 vMqttInDispatch(mqtt::MsgHeader& msg, u32 msg_len);
// func:x2gw.RespIn..DispatchRaw
int                  RespInDispatchRaw(x2gw::RespInCase type, u8 *msg, u32 len);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.ams.InputLineMsg
// this function is 'extrn' and implemented by user
void                 UserIn_InputLineMsg(ams::InputLineMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.AuthMsg
// this function is 'extrn' and implemented by user
void                 UserIn_AuthMsg(x2::AuthMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.CmdMsg
// this function is 'extrn' and implemented by user
void                 UserIn_CmdMsg(x2::CmdMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.CreditMetricMsg
// this function is 'extrn' and implemented by user
void                 UserIn_CreditMetricMsg(x2::CreditMetricMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.FetchMsg
// this function is 'extrn' and implemented by user
void                 UserIn_FetchMsg(x2::FetchMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.OpenStreamMsg
// this function is 'extrn' and implemented by user
void                 UserIn_OpenStreamMsg(x2::OpenStreamMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.PubMsg
// this function is 'extrn' and implemented by user
void                 UserIn_PubMsg(x2::PubMsg &msg);
// User-implemented callback function for dispatch UserIn
// func:x2gw.UserIn.x2.SubscribeMetricMsg
// this function is 'extrn' and implemented by user
void                 UserIn_SubscribeMetricMsg(x2::SubscribeMetricMsg &msg);
// func:x2gw.UserIn..DispatchRaw
int                  UserInDispatchRaw(x2gw::UserInCase type, u8 *msg, u32 len);
// func:x2gw.UserIn..Dispatch
int                  UserInDispatch(ams::MsgHeader& msg);
// void rettype useful for hooks
// func:x2gw.UserIn..Dispatch2
void                 vUserInDispatch(ams::MsgHeader& msg);
// Construct a new kafka::Frame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:x2gw...Frame_FmtByteAry
kafka::Frame *       Frame_FmtByteAry(algo::ByteAry &buf, algo::aryptr<u8 > payload);

report.amc  n_cppfile:0  n_cppline:6960  n_ctype:3262  n_func:99737  n_xref:1305  n_filemod:0
